

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Android架构 - Android高级工程师</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1.ViewModel如何知道View层的生命周期？事...">
  <meta name="author" content="MengLong Sun">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: false,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: false,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
      
      
    </div>
    <div class="center">Android架构</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://t7.baidu.com/it/u=3456342631,3385797977&fm=193&f=GIF" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Android架构</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 23, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>8165</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h3 id="1-ViewModel如何知道View层的生命周期？"><a href="#1-ViewModel如何知道View层的生命周期？" class="headerlink" title="1.ViewModel如何知道View层的生命周期？"></a>1.ViewModel如何知道View层的生命周期？</h3><p>事实上，如果你仅仅使用ViewModel，它是感知不了生命周期，它需要结合LiveData去感知生命周期，如果仅仅使用DataBinding去实现MVVM，它对数据源使用了弱引用，所以一定程度上可以避免内存泄漏的发生。</p>
<h3 id="2-MVVM和MVP的最大区别在哪？"><a href="#2-MVVM和MVP的最大区别在哪？" class="headerlink" title="2.MVVM和MVP的最大区别在哪？"></a>2.MVVM和MVP的最大区别在哪？</h3><p>MVP中的每个方法都需要你去主动调用，它其实是被动的，而MVVM中有数据驱动这个概念，当你的持有的数据状态发生变更的时候，你的View你可以监听到这个变化，从而主动去更新，这其实是主动的。</p>
<h3 id="3-MVC和MVP的区别是什么？"><a href="#3-MVC和MVP的区别是什么？" class="headerlink" title="3.MVC和MVP的区别是什么？"></a>3.MVC和MVP的区别是什么？</h3><p>MVP是MVC的进一步解耦，简单来讲，在MVC中，View层既可以和Controller层交互，又可以和Model层交互；而在MVP中，View层只能和Presenter层交互，Model层也只能和Presenter层交互，减少了View层和Model层的耦合，更容易定位错误的来源。</p>
<h3 id="4-MVC、MVP和MVVM是什么？"><a href="#4-MVC、MVP和MVVM是什么？" class="headerlink" title="4.MVC、MVP和MVVM是什么？"></a>4.MVC、MVP和MVVM是什么？</h3><p>MVC：Model-View-Controller，是一种分层解偶的框架，Model层提供本地数据和网络请求，View层处理视图，Controller处理逻辑，存在问题是Controller层和View层的划分不明显，Model层和View层的存在耦合。<br>MVP：Model-View-Presenter，是对MVC的升级，Model层和View层与MVC的意思一致，但Model层和View层不再存在耦合，而是通过Presenter层这个桥梁进行交流。<br>MVVM：Model-View-ViewModel，不同于上面的两个框架，ViewModel持有数据状态，当数据状态改变的时候，会自动通知View层进行更新。</p>
<h3 id="5-谈MVC-，MVP，MVVM"><a href="#5-谈MVC-，MVP，MVVM" class="headerlink" title="5.谈MVC ，MVP，MVVM"></a>5.谈MVC ，MVP，MVVM</h3><p>MVC:View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些 业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，及View。所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVP：MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负 责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。<br>MVVM：数据双向绑定，通过数据驱动UI，M提供数据，V视图，VM即数据驱动层</p>
<h3 id="6-简述Activity启动全部过程"><a href="#6-简述Activity启动全部过程" class="headerlink" title="6.简述Activity启动全部过程"></a>6.简述Activity启动全部过程</h3><p>app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。<br>我们创建一个新的项目，默认的根activity都是MainActivity，而所有的activity都是保存在堆栈中的，我们启动一个新的activity就会放在上一个activity上面，而我们从桌面点击应用图标的时候，由于launcher本身也是一个应用，当我们点击图标的时候，系统就会调用startActivitySately(),一般情况下，我们所启动的activity的相关信息都会保存在intent中，比如action，category等等。我们在安装这个应用的时候，系统也会启动一个PackaManagerService的管理服务，这个管理服务会对AndroidManifest.xml文件进行解析，从而得到应用程序中的相关信息，比如service，activity，Broadcast等等，然后获得相关组件的信息。当我们点击应用图标的时候，就会调用startActivitySately()方法，而这个方法内部则是调用startActivty(),而startActivity()方法最终还是会调用startActivityForResult()这个方法。而在startActivityForResult()这个方法。因为startActivityForResult()方法是有返回结果的，所以系统就直接给一个-1，就表示不需要结果返回了。而startActivityForResult()这个方法实际是通过Instrumentation类中的execStartActivity()方法来启动activity，Instrumentation这个类主要作用就是监控程序和系统之间的交互。而在这个execStartActivity()方法中会获取ActivityManagerService的代理对象，通过这个代理对象进行启动activity。启动会就会调用一个checkStartActivityResult()方法，如果说没有在配置清单中配置有这个组件，就会在这个方法中抛出异常了。当然最后是调用的是Application.scheduleLaunchActivity()进行启动activity，而这个方法中通过获取得到一个ActivityClientRecord对象，而这个ActivityClientRecord通过handler来进行消息的发送，系统内部会将每一个activity组件使用ActivityClientRecord对象来进行描述，而ActivityClientRecord对象中保存有一个LoaderApk对象，通过这个对象调用handleLaunchActivity来启动activity组件，而页面的生命周期方法也就是在这个方法中进行调用。</p>
<h3 id="7-大体说清一个应用程序安装到手机上时发生了什么"><a href="#7-大体说清一个应用程序安装到手机上时发生了什么" class="headerlink" title="7.大体说清一个应用程序安装到手机上时发生了什么"></a>7.大体说清一个应用程序安装到手机上时发生了什么</h3><p>(1）拷贝apk文件到指定目录：<br>用户安装的apk首先会被拷贝到/data/app目录下<br>/data/app目录是用户有权限访问的目录，在安装apk的时候会自动选择该目录存放用户安装的文件<br>系统出厂的apk文件则被放到了/system分区下,包括 /system/app，/system/vendor/app，以及 /system/priv-app 等等，该分区只有Root权限的用户才能<br>2）解压apk，拷贝文件，创建应用的数据目录：<br>为了加快app的启动速度，apk在安装的时候，会首先将app的可执行文件（dex）拷贝到 /data/dalvik-cache 目录，缓存起来。<br>然后，在/data/data/目录下创建应用程序的数据目录（以应用的包名命名），存放应用的相关数据，如数据库、xml文件、cache、二进制的so动态库等等。<br>3）解析apk的AndroidManifinest.xml文件：解析的内容会被存储到/data/system/packages.xml和/data/system/packages.list中。<br>packages.list：中指名了该应用默认存储的位置/data/data/cn.hadcn.example。<br>packages.xml：中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。</p>
<p>做完以上操作，就相当于应用在系统注册了，可以被系统识别。<br>注：目录是由 包名-1 组成，有时候此处是 -2。这是为了升级使用，升级时会新创建一个-1 或 -2的目录，如果升级成功，则删除原目录并更改packages.xml中codePath到新目录<br>在Dalvik模式下，会使用dexopt把base.apk中的dex文件优化为odex，存储在/data/dalvik-cache中，<br>如果是ART模式，则会使用dex2oat优化成oat文件也存储在该目录下，并且文件名一样，但文件大小会大很多，因为ART模式会在安装时把dex优化为机器码，所以在ART模式下的应用运行更快，但apk安装速度相对Dalvik模式下变慢，并且会占用更多的ROM。</p>
<h3 id="8-系统启动流程是什么？"><a href="#8-系统启动流程是什么？" class="headerlink" title="8.系统启动流程是什么？"></a>8.系统启动流程是什么？</h3><p>提示：Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程</p>
<p>第一步：启动电源以及系统启动<br>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。<br>第二步：引导程序<br>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。<br>引导程序是OEM厂商或者运营商加锁和限制的地方。引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。<br>Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。<br>传统的加载器包含的个文件，需要在这里说明：<br>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；<br>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签。<br>更多关于Android引导程序的可以在这里了解。<br>第三步：内核<br>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。<br>第四步：init进程<br>init是第一个进程，我们可以说它是root进程或者所有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。<br>init进程可以在/system/core/init找到。<br>init.rc文件可以在/system/core/rootdir/init.rc找到。<br>readme.txt可以在/system/core/init/readme.txt找到。<br>对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。<br>Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。<br>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。<br>Options（选项）：选项是对服务的描述。它们影响init进程如何以及何时启动服务。<br>在这个阶段你可以在设备的屏幕上看到“Android”logo了。<br>第五步<br>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。<br>Zygote加载进程<br>加载ZygoteInit类，源代码：/frameworks/base/core/java/com/android /internal/os/ZygoteInit.java<br>registerZygoteSocket()为zygote命令连接注册一个服务器套接字。preloadClassed “preloaded-classes”是一个简单的包含一系列需要预加载类的文本文件，你可以在/frameworks/base找到“preloaded-classes”文件。preloadResources() preloadResources也意味着本地主题、布局以及android.R文件中包含的所有东西都会用这个方法加载。在这个阶段，你可以看到启动动画。<br>第六步：系统服务或服务<br>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。<br>Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。<br>核心服务：<br>启动电源管理器；创建Activity管理器；启动电话注册；启动包管理器；设置Activity管理服务为系统进程；启动上下文管理器；启动系统Context Providers；启动电池服务；启动定时管理器；启动传感服务；启动窗口管理器；启动蓝牙服务；启动挂载服务。<br>其他服务：<br>启动状态栏服务；启动硬件服务；启动网络状态服务；启动网络连接服务；启动通知管理器；启动设备存储监视服务；启动定位管理器；启动搜索服务；启动剪切板服务；启动登记服务；启动壁纸服务；启动音频服务；启动耳机监听；启动AdbSettingsObserver（处理adb命令）。<br>第七步：引导完成<br>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
<h3 id="9-Ubuntu编译安卓系统"><a href="#9-Ubuntu编译安卓系统" class="headerlink" title="9.Ubuntu编译安卓系统"></a>9.Ubuntu编译安卓系统</h3><p>1.初始化编译环境<br>. build/envsetup.sh<br>2.选择编译目标<br>lunch aosp_arm64-eng<br>3.开始编译<br>make -j8</p>
<h3 id="10-AIDL理解（此处延伸：简述Binder）"><a href="#10-AIDL理解（此处延伸：简述Binder）" class="headerlink" title="10.AIDL理解（此处延伸：简述Binder）"></a>10.AIDL理解（此处延伸：简述Binder）</h3><p>AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。</p>
<p>Binde机制简单理解:<br>在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，<br>Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。</p>
<h3 id="11-从0设计一款App整体架构，如何去做？"><a href="#11-从0设计一款App整体架构，如何去做？" class="headerlink" title="11.从0设计一款App整体架构，如何去做？"></a>11.从0设计一款App整体架构，如何去做？</h3><p>无非就是技术选择（使用哪些第三方框架），使用那种设计模式（MVP，MVC，MVVM为什么选这个？），包的结构，分类等等</p>
<h3 id="12-MVC-MVP-MVVM原理和区别"><a href="#12-MVC-MVP-MVVM原理和区别" class="headerlink" title="12.MVC MVP MVVM原理和区别"></a>12.MVC MVP MVVM原理和区别</h3><p>MVP模式，对应着Model—业务逻辑和实体模型,view–对应着activity，负责View的绘制以及与用户交互,Presenter–负责View和Model之间的交互,MVP模式是在MVC模式的基础上，将Model与View彻底分离使得项目的耦合性更低，在Mvc中项目中的activity对应着mvc中的C–Controllor,而项目中的逻辑处理都是在这个C中处理，同时View与Model之间的交互，也是也就是说，mvc中所有的逻辑交互和用户交互，都是放在Controllor中，也就是activity中。View和model是可以直接通信的。<br>MVP模式：则是分离的更加彻底，分工更加明确Model—业务逻辑和实体模型，view–负责与用户交互，Presenter 负责完成View于Model间的交互，MVP和MVC最大的区别是MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的<br>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。可以说是MVP的升级版<br>唯一的区别是，它采用双向绑定(data-binding)：View 的变动，自动反映在 ViewModel，反之亦然。</p>
<h3 id="13-Android-的大体架构图"><a href="#13-Android-的大体架构图" class="headerlink" title="13.Android 的大体架构图"></a>13.Android 的大体架构图</h3><p>Android的系统架构采用了分层架构的思想，如图1所示。从上层到底层共包括四层，分别是应用层、应用框架层、系统库和Android运行时和Linux内核。</p>
<h3 id="14-目前Android系统支持以下七种不用的CPU架构"><a href="#14-目前Android系统支持以下七种不用的CPU架构" class="headerlink" title="14.目前Android系统支持以下七种不用的CPU架构"></a>14.目前Android系统支持以下七种不用的CPU架构</h3><p>ARMv5——armeabi<br>ARMv7 ——armeabi-v7a<br>ARMv8——arm64- v8a<br>x86——x86<br>MIPS ——mips<br>MIPS64——mips64<br>x86_64——x86_64</p>
<h3 id="15-Android各个版本间的差异"><a href="#15-Android各个版本间的差异" class="headerlink" title="15.Android各个版本间的差异"></a>15.Android各个版本间的差异</h3><h4 id="android版本间兼容问题"><a href="#android版本间兼容问题" class="headerlink" title="# android版本间兼容问题"></a># android版本间兼容问题</h4><p>Android 6.0：运行时权限，对几个比较危险的权限进行判断，除了在清单文件定义之外，还要程序运行时动态的申请，只有用户同意了，才可以使用相关功能</p>
<p>Android 7.0：应用间共享文件限制，就是禁止向外公开 file://URI，解决办法就是通过 fileProvider，发送 content://URI 类型的 uri，授予它临时访问权限，需要在清单文件进行注册，并指定共享目录</p>
<p>Android 8.0：通知栏要设置通知渠道，否则无法正常显示，这个根据 Android 新的 api 设置一下对应的渠道就好了；另外还有未知应用安装权限，在做 app 内部更新下载的时候，需要先判断有没有打开这个权限，否则会崩溃，无法安装；</p>
<p>Android 9.0：限制 Http 请求，希望所有的请求都是 https 的，解决办法是在清单文件里加上一个网络完全配置；</p>
<p>Android 10.0：禁止访问 imei 等手机唯一标示信息，需要做唯一标识的备用方案；</p>
<p>这里如果是代码逻辑上的，可以在代码里进行 api 版本的判断</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>MengLong Sun</li>
    <li><strong>本文链接：</strong><a href="http://www.jianzhioffer.com/topic/topic_Android%E6%9E%B6%E6%9E%84/index.html" title="http:&#x2F;&#x2F;www.jianzhioffer.com&#x2F;topic&#x2F;topic_Android%E6%9E%B6%E6%9E%84&#x2F;index.html">http:&#x2F;&#x2F;www.jianzhioffer.com&#x2F;topic&#x2F;topic_Android%E6%9E%B6%E6%9E%84&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
  <nav class="nav">
    <a href="/resume/resume_8/"><i class="iconfont iconleft"></i>经典风格前端开发求职简历灰蓝word简历模板</a>
    <a href="/topic/topic_java%E8%BF%9B%E9%98%B6/">java进阶<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ViewModel%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93View%E5%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-text">1.ViewModel如何知道View层的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MVVM%E5%92%8CMVP%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">2.MVVM和MVP的最大区别在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MVC%E5%92%8CMVP%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.MVC和MVP的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MVC%E3%80%81MVP%E5%92%8CMVVM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.MVC、MVP和MVVM是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%88MVC-%EF%BC%8CMVP%EF%BC%8CMVVM"><span class="toc-text">5.谈MVC ，MVP，MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%80%E8%BF%B0Activity%E5%90%AF%E5%8A%A8%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">6.简述Activity启动全部过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A4%A7%E4%BD%93%E8%AF%B4%E6%B8%85%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%88%B0%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">7.大体说清一个应用程序安装到手机上时发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8.系统启动流程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F"><span class="toc-text">9.Ubuntu编译安卓系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-AIDL%E7%90%86%E8%A7%A3%EF%BC%88%E6%AD%A4%E5%A4%84%E5%BB%B6%E4%BC%B8%EF%BC%9A%E7%AE%80%E8%BF%B0Binder%EF%BC%89"><span class="toc-text">10.AIDL理解（此处延伸：简述Binder）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%8E0%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AC%BEApp%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8E%BB%E5%81%9A%EF%BC%9F"><span class="toc-text">11.从0设计一款App整体架构，如何去做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-MVC-MVP-MVVM%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">12.MVC MVP MVVM原理和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Android-%E7%9A%84%E5%A4%A7%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">13.Android 的大体架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%9B%AE%E5%89%8DAndroid%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81%E4%BB%A5%E4%B8%8B%E4%B8%83%E7%A7%8D%E4%B8%8D%E7%94%A8%E7%9A%84CPU%E6%9E%B6%E6%9E%84"><span class="toc-text">14.目前Android系统支持以下七种不用的CPU架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Android%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">15.Android各个版本间的差异</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
  
  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>