

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>java基础 - Android高级工程师</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1.二分查找算法 ？定义：二分查找也称为折半查找，它是...">
  <meta name="author" content="MengLong Sun">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: false,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: false,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">java基础</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a><p><a target="_blank" href="https://beian.miit.gov.cn/">京ICP备20023327号-1</a></p></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/../../images/cover/cover_21.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">java基础</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>August 24, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>16408</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h3 id="1-二分查找算法-？"><a href="#1-二分查找算法-？" class="headerlink" title="1.二分查找算法 ？"></a>1.二分查找算法 ？</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>二分查找也称为折半查找，它是一种效率较高的查找方法。</p>
<h5 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h5><p>数组必须是有序的，递增或递减。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>比较次数较少、查找速度快、平均性能好。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>待查表为顺序表，插入和删除困难。</p>
<h5 id="查找思想："><a href="#查找思想：" class="headerlink" title="查找思想："></a>查找思想：</h5><ol>
<li><p>首先确定确定整个查找区间的中间位置mid = (start + end)/2；</p>
</li>
<li><p>用待查关键字值与中间位置的关键字值进行比较，若相等则返回下标，不相等有两种情况：</p>
<ol>
<li><p>arr[mid] &gt; key 查找范围缩小到左半区域，具体表现为：start不变，end = mid - 1;</p>
</li>
<li><p>arr[mid] &lt; key 查找范围缩小到右半区域，具体表现为：end不变，start = mid + 1; </p>
</li>
</ol>
</li>
<li><p>对确定的缩小区域，再进行折半查找，重复以上步骤。</p>
</li>
</ol>
<p>注意点：</p>
<p>循环条件，只有满足start &lt;= end才执行</p>
<p>两种实现方式：</p>
<ol>
<li>非递归：</li>
</ol>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs excel">/**<br> * @param arr：需要查找的有序数组<br> * @param <span class="hljs-built_in">left</span>：数组的左边界<br> * @param <span class="hljs-built_in">right</span>：数组的右边界<br> * @param key：需要查找的key<br> * @return： 返回找到的下标，找不到返回-<span class="hljs-number">1</span><br> */<br>public static <span class="hljs-built_in">int</span> binarySearch1(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> ,<span class="hljs-built_in">int</span> key) &#123;<br>    while ( <span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span> ) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">if</span> (key &lt; arr[<span class="hljs-built_in">mid</span>]) &#123;<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>        &#125; else <span class="hljs-built_in">if</span> (key &gt; arr[<span class="hljs-built_in">mid</span>]) &#123;<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>        &#125;else&#123;<br>            return <span class="hljs-built_in">mid</span>;<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="2">
<li>递归方式</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param arr：需要查找的有序数组</span><br><span class="hljs-comment"> * @param left：数组的左边界</span><br><span class="hljs-comment"> * @param right：数组的右边界</span><br><span class="hljs-comment"> * @param key：需要查找的key</span><br><span class="hljs-comment"> * @return： 返回找到的下标，找不到返回-1</span><br><span class="hljs-comment"> */</span><br>public static <span class="hljs-built_in">int</span> binary<span class="hljs-constructor">Search(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span> ,<span class="hljs-params">int</span> <span class="hljs-params">key</span>)</span> &#123;<br><span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> mid = (left + right)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (key &lt; arr<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span>) &#123;<br>        return binary<span class="hljs-constructor">Search(<span class="hljs-params">arr</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span> - 1, <span class="hljs-params">key</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span>) &#123;<br>        return binary<span class="hljs-constructor">Search(<span class="hljs-params">arr</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">right</span>, <span class="hljs-params">key</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        return mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-冒泡排序算法-？"><a href="#2-冒泡排序算法-？" class="headerlink" title="2.冒泡排序算法 ？"></a>2.冒泡排序算法 ？</h3><p>定义：</p>
<p>冒泡排序算法也称为下沉排序。在这种类型的排序中，要排序的列表的相邻元素之间互相比较。如果它们按顺序排列错误，将交换值并以正确的顺序排列，直到最终结果“浮”出水面。</p>
<p>代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">int[] numbers = new int[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>&#125;;<br>int i, <span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; numbers.length - 1; i++) &#123;</span><br>    for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; numbers.length - 1 - i; j++) &#123;</span><br>        if (numbers[<span class="hljs-keyword">j] </span>&lt; numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]) &#123;<br>            int temp = numbers[<span class="hljs-keyword">j];</span><br><span class="hljs-keyword"></span>            numbers[<span class="hljs-keyword">j] </span>= numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>];<br>            numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二次for为什么要 -i 不 -i 对排序结果有影响吗？</p>
<p>因为i后面已经排过序了，不 -i 对排序结果没有影响，只是i后面的值每次又比较了一遍。</p>
<h3 id="3-类加载的过程？"><a href="#3-类加载的过程？" class="headerlink" title="3.类加载的过程？"></a>3.类加载的过程？</h3><p>类加载的过程可以分为：</p>
<p>加载：将类的全限定名转化为二进制流，再将二进制流转化为方法区中的类型信息，从而生成一个Class对象。<br>验证：对类的验证，包括格式、字节码、属性等。<br>准备：为类变量分配内存并设置初始值。<br>解析：将常量池的符号引用转化为直接引用。<br>初始化：执行类中定义的Java程序代码，包括类变量的赋值动作和构造函数的赋值。<br>使用<br>卸载</p>
<h3 id="4-说一下四种引用以及他们的区别？"><a href="#4-说一下四种引用以及他们的区别？" class="headerlink" title="4.说一下四种引用以及他们的区别？"></a>4.说一下四种引用以及他们的区别？</h3><p>强引用：强引用还在，垃圾搜集器就不会回收被引用的对象。<br>软引用：对于软引用关联的对象，在系统发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>弱引用：被若引用关联的对象只能存活到下一次GC之前。<br>虚引用：为对象设置虚引用的目的仅仅是为了GC之前收到一个系统通知。</p>
<h3 id="5-如何判断对象可回收？"><a href="#5-如何判断对象可回收？" class="headerlink" title="5.如何判断对象可回收？"></a>5.如何判断对象可回收？</h3><p>判断一个对象可以回收通常采用的算法是引用几算法和可达性算法。由于互相引用导致的计数不好判断，Java采用的可达性算法。</p>
<p>可达性算法的思路是：通过一些列被成为GC Roots的对象作为起始点，自上往下从这些起点往下搜索，搜索所有走过的路径称为引用链，如果一个对象没有跟任何引用链相关联的时候，则证明该对象不可用，所以这些对象就会被判定为可以回收。</p>
<h3 id="6-String-s1-“abc”和String-s2-new-String-“abc”-的区别，生成对象的情况"><a href="#6-String-s1-“abc”和String-s2-new-String-“abc”-的区别，生成对象的情况" class="headerlink" title="6.String s1 = “abc”和String s2 = new String(“abc”)的区别，生成对象的情况"></a>6.String s1 = “abc”和String s2 = new String(“abc”)的区别，生成对象的情况</h3><p>指向方法区：”abc”是常量，所以它会在方法区中分配内存，如果方法区已经给”abc”分配过内存，则s1会直接指向这块内存区域。<br>指向Java堆：new String(“abc”)是重新生成了一个Java实例，它会在Java堆中分配一块内存。<br>所以s1和s2的内存地址肯定不一样，但是内容一样。</p>
<h3 id="7-什么是类型擦除？"><a href="#7-什么是类型擦除？" class="headerlink" title="7.什么是类型擦除？"></a>7.什么是类型擦除？</h3><p>不管泛型的类型传入哪一种类型实参，对于Java来说，都会被当成同一类处理，在内存中也只占用一块空间。通俗一点来说，就是泛型只作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的信息擦除，也就是说，成功编译过后的class文件是不包含任何泛型信息的。</p>
<h3 id="8-说一下对泛型的理解？"><a href="#8-说一下对泛型的理解？" class="headerlink" title="8.说一下对泛型的理解？"></a>8.说一下对泛型的理解？</h3><p>泛型的本质是参数化类型，在不创建新的类型的情况下，通过泛型指定不同的类型来控制形参具体限制的类型。也就是说在泛型的使用中，操作的数据类型被指定为一个参数，这种参数可以被用在类、接口和方法中，分别被称为泛型类、泛型接口和泛型方法。</p>
<p>泛型是Java中的一种语法糖，能够在代码编写的时候起到类型检测的作用，但是虚拟机是不支持这些语法的。</p>
<p>泛型的优点：</p>
<p>类型安全，避免类型的强转。<br>提高了代码的可读性，不必要等到运行的时候才去强制转换。</p>
<h3 id="9-HashMap的特点是什么？HashMap的原理？"><a href="#9-HashMap的特点是什么？HashMap的原理？" class="headerlink" title="9.HashMap的特点是什么？HashMap的原理？"></a>9.HashMap的特点是什么？HashMap的原理？</h3><p>HashMap的特点：</p>
<p>基于Map接口，存放键值对。<br>允许key/value为空。<br>非多线程安全。<br>不保证有序，也不保证使用的过程中顺序不会改变。<br>简单来讲，核心是数组+链表/红黑树，HashMap的原理就是存键值对的时候：</p>
<p>通过键的Hash值确定数组的位置。<br>找到以后，如果该位置无节点，直接存放。<br>该位置有节点即位置发生冲突，遍历该节点以及后续的节点，比较key值，相等则覆盖。<br>没有就新增节点，默认使用链表，相连节点数超过8的时候，在jdk 1.8中会变成红黑树。<br>如果Hashmap中的数组使用情况超过一定比例，就会扩容，默认扩容两倍。<br>当然这是存入的过程，其他过程可以自行查阅。这里需要注意的是：</p>
<p>key的hash值计算过程是高16位不变，低16位和高16位取抑或，让更多位参与进来，可以有效的减少碰撞的发生。<br>初始数组容量为16，默认不超过的比例为0.75。</p>
<h3 id="10-Java中抽象类和接口的特点？"><a href="#10-Java中抽象类和接口的特点？" class="headerlink" title="10.Java中抽象类和接口的特点？"></a>10.Java中抽象类和接口的特点？</h3><p>共同点：</p>
<p>抽象类和接口都不能生成具体的实例。<br>都是作为上层使用。<br>不同点：</p>
<p>抽象类可以有属性和成员方法，接口不可以。<br>一个类只能继承一个类，但是可以实现多个接口。<br>抽象类中的变量是普通变量，接口中的变量是静态变量。<br>抽象类表达的是is-a的关系，接口表达的是like-a的关系。</p>
<h3 id="11-String-StringBuffer-StringBuilder的区别"><a href="#11-String-StringBuffer-StringBuilder的区别" class="headerlink" title="11.String,StringBuffer,StringBuilder的区别"></a>11.String,StringBuffer,StringBuilder的区别</h3><p>String不可改变对象，一旦创建就不能修改</p>
<p>String str=”aaa”; str=”bbb”;<br>以上代码虽然改变了str，但是执行过程是回收str，把值赋给一个新的str<br>StringBuffer创建之后，可以去修改<br>StringBuilder也可修改，执行效率高于StringBuffer，不安全<br>当字符赋值少使用String<br>字符赋值频繁使用StringBuilder<br>当多个线程同步操作数据，使用StringBuffer</p>
<h3 id="12-同步锁对于静态方法锁的对象是什么？"><a href="#12-同步锁对于静态方法锁的对象是什么？" class="headerlink" title="12.同步锁对于静态方法锁的对象是什么？"></a>12.同步锁对于静态方法锁的对象是什么？</h3><p>class本身</p>
<h3 id="13-final-可以修饰类和方法吗？"><a href="#13-final-可以修饰类和方法吗？" class="headerlink" title="13.final 可以修饰类和方法吗？"></a>13.final 可以修饰类和方法吗？</h3><p>可以修饰class表示该类无法被继承，也可以修饰方法表示该方法无法被重写</p>
<h3 id="14-手写出单例模式"><a href="#14-手写出单例模式" class="headerlink" title="14.手写出单例模式"></a>14.手写出单例模式</h3><p>单例模式：分为恶汉式和懒汉式</p>
<p>恶汉式：（效率高）</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>        <br>       <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton getInstance() &#123;<br>        	<span class="hljs-built_in">	return </span>instance ;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>懒汉式：（线程安全）</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class Singleton02 &#123;<br>       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton02 instance;<br><br>       <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton02 getInstance() &#123;<br>           <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>                synchronized (Singleton02.class)&#123;<br>                       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>                           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton02();<br>                        &#125;<br>                &#125;<br>            &#125;<br>           <span class="hljs-built_in"> return </span>instance;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="15-差值器和估值器"><a href="#15-差值器和估值器" class="headerlink" title="15.差值器和估值器"></a>15.差值器和估值器</h3><p>差值器： 根据时间流逝的百分比计算当前属性改变的百分比。<br>估值器： 根据当前属性改变的百分比计算改变后的属性值</p>
<h3 id="16-谈谈对接口与回调的理解"><a href="#16-谈谈对接口与回调的理解" class="headerlink" title="16.谈谈对接口与回调的理解"></a>16.谈谈对接口与回调的理解</h3><p>接口回调就是指: 可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法。实际上，当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法，这一过程称为对象功能的接口回调。</p>
<h3 id="17-WebSocket与socket的区别"><a href="#17-WebSocket与socket的区别" class="headerlink" title="17.WebSocket与socket的区别"></a>17.WebSocket与socket的区别</h3><p>1.WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。<br>2.Socket是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口。在设计模式中,Socket其实就是一个门面模式,它把…<br>3.区别 Socket是传输控制层协议,WebSocket是应用层协议。</p>
<h3 id="18-HttpClient与HttpUrlConnection的区别-此处延伸：Volley里用的哪种请求方式（2-3前HttpClient，2-3后HttpUrlConnection）"><a href="#18-HttpClient与HttpUrlConnection的区别-此处延伸：Volley里用的哪种请求方式（2-3前HttpClient，2-3后HttpUrlConnection）" class="headerlink" title="18.HttpClient与HttpUrlConnection的区别 (此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection）"></a>18.HttpClient与HttpUrlConnection的区别 (此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection）</h3><p>首先HttpClient和HttpUrlConnection 这两种方式都支持Https协议，都是以流的形式进行上传或者下载数据，也可以说是以流的形式进行数据的传输，还有ipv6,以及连接池等功能。HttpClient这个拥有非常多的API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话，很难进行扩展，也就是这个原因，Google在Android6.0的时候，直接就弃用了这个HttpClient.<br>而HttpUrlConnection相对来说就是比较轻量级了，API比较少，容易扩展，并且能够满足Android大部分的数据传输。比较经典的一个框架volley，在2.3版本以前都是使用HttpClient,在2.3以后就使用了HttpUrlConnection。</p>
<h3 id="19-client如何确定自己发送的消息被server收到"><a href="#19-client如何确定自己发送的消息被server收到" class="headerlink" title="19.client如何确定自己发送的消息被server收到?"></a>19.client如何确定自己发送的消息被server收到?</h3><p>HTTP协议里，有请求就有响应，根据响应的状态吗就能知道。</p>
<h3 id="20-如何验证证书的合法性"><a href="#20-如何验证证书的合法性" class="headerlink" title="20.如何验证证书的合法性?"></a>20.如何验证证书的合法性?</h3><p>1、证书是否是信任的有效证书。所谓信任：浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。所谓有效，就是看看web服务器证书是否在有效期，是否被吊销了。</p>
<p>2、对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一种是用证书做个信封，看对方是否能解开。以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证正式是否吊销可以采用黑名单方式或者OCSP方式。黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实时连接CA去验证，优点是实时，缺点是效率不高。</p>
<h3 id="21-HTTP与HTTPS的区别以及如何实现安全性"><a href="#21-HTTP与HTTPS的区别以及如何实现安全性" class="headerlink" title="21.HTTP与HTTPS的区别以及如何实现安全性"></a>21.HTTP与HTTPS的区别以及如何实现安全性</h3><p>区别：http是明文传输，传输的数据很可能被中间节点获取，从而导致数据传输不安全<br>https是加密传输，可以保证数据的传输安全<br>如何实现：http是应用层协议，它会将要传输的数据以明文的方式给传输层，这样显然不安全。https则是在应用层与传输层之间又加了一层，该层遵守SSL/TLS协议，用于数据加密。</p>
<h3 id="22-HTTP报文结构"><a href="#22-HTTP报文结构" class="headerlink" title="22.HTTP报文结构"></a>22.HTTP报文结构</h3><p>一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。<br>1.请求行<br>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1<br>2.请求头部<br>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。<br>3.空行<br>它的作用是通过一个空行，告诉服务器请求头部到此为止。<br>4.请求数据<br>若方法字段是GET，则此项为空，没有数据。若方法字段是POST,则通常来说此处放置的就是要提交的数据</p>
<h3 id="23-HTTP链接的特点"><a href="#23-HTTP链接的特点" class="headerlink" title="23.HTTP链接的特点"></a>23.HTTP链接的特点</h3><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br>从建立连接到关闭连接的过程称为“一次连接”。</p>
<h3 id="24-Http位于TCP-IP模型中的第几层？为什么说Http是可靠的数据传输协议？"><a href="#24-Http位于TCP-IP模型中的第几层？为什么说Http是可靠的数据传输协议？" class="headerlink" title="24.Http位于TCP/IP模型中的第几层？为什么说Http是可靠的数据传输协议？"></a>24.Http位于TCP/IP模型中的第几层？为什么说Http是可靠的数据传输协议？</h3><p>tcp/ip的五层模型：<br>从下到上：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层<br>其中tcp/ip位于模型中的网络层，处于同一层的还有ICMP（网络控制信息协议）。http位于模型中的应用层<br>由于tcp/ip是面向连接的可靠协议，而http是在传输层基于tcp/ip协议的，所以说http是可靠的数据传输协议。</p>
<h3 id="25-Http-https区别，此处延伸：https的实现原理"><a href="#25-Http-https区别，此处延伸：https的实现原理" class="headerlink" title="25.Http https区别，此处延伸：https的实现原理"></a>25.Http https区别，此处延伸：https的实现原理</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>https实现原理：<br>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。<br>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>（5）Web服务器利用自己的私钥解密出会话密钥。<br>（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<h3 id="26-TCP与UDP的应用"><a href="#26-TCP与UDP的应用" class="headerlink" title="26.TCP与UDP的应用"></a>26.TCP与UDP的应用</h3><p>从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。<br>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h3 id="27-TCP与UDP的区别"><a href="#27-TCP与UDP的区别" class="headerlink" title="27.TCP与UDP的区别"></a>27.TCP与UDP的区别</h3><p>tcp是面向连接的，由于tcp连接需要三次握手，所以能够最低限度的降低风险，保证连接的可靠性。<br>udp 不是面向连接的，udp建立连接前不需要与对象建立连接，无论是发送还是接收，都没有发送确认信号。所以说udp是不可靠的。<br>由于udp不需要进行确认连接，使得UDP的开销更小，传输速率更高，所以实时行更好。</p>
<h3 id="28-为什么不能用两次握手进行连接？"><a href="#28-为什么不能用两次握手进行连接？" class="headerlink" title="28.为什么不能用两次握手进行连接？"></a>28.为什么不能用两次握手进行连接？</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。</p>
<h3 id="29-为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#29-为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="29.为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>29.为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="30-TCP的3次握手和四次挥手"><a href="#30-TCP的3次握手和四次挥手" class="headerlink" title="30.TCP的3次握手和四次挥手"></a>30.TCP的3次握手和四次挥手</h3><p>三次握手：<br>第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x<br>第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y<br>第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1</p>
<p>四次挥手：<br>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p>
<h3 id="31-从网络加载一个10M的图片，说下注意事项"><a href="#31-从网络加载一个10M的图片，说下注意事项" class="headerlink" title="31.从网络加载一个10M的图片，说下注意事项"></a>31.从网络加载一个10M的图片，说下注意事项</h3><p>图片缓存、异常恢复、质量压缩，从这几方面说就好了</p>
<h3 id="32-多线程有什么要注意的问题？"><a href="#32-多线程有什么要注意的问题？" class="headerlink" title="32.多线程有什么要注意的问题？"></a>32.多线程有什么要注意的问题？</h3><p>给线程起有意义的名字，这样方便找Bug<br>缩小同步范围，从而减少锁的争用，例如对于 synchronized，应该尽量使用同步块而不是同步方法<br>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。<br>使用BlockingQueue实现生产者消费者问题<br>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable<br>使用本地变量和不可变类来保证线程安全<br>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务</p>
<h3 id="33-谈谈对多线程的理解"><a href="#33-谈谈对多线程的理解" class="headerlink" title="33.谈谈对多线程的理解"></a>33.谈谈对多线程的理解</h3><p>线程是由一个主线程和很多个子线程组成的，主线程消失，子线程也会消失，但是子线程消失其中一个主线程不会消失<br>线程的生命周期分为5个步骤像人的一生一样，这5个步骤分别对应了5个方法<br>新生–&gt;启动–&gt;运行–&gt;阻塞–&gt;销毁<br>继承Thread类or实现runnable方法–&gt;start–&gt;run–&gt;sleep(睡眠)or wait(挂起)–&gt;destroy</p>
<h3 id="34-什么是线程池，如何使用"><a href="#34-什么是线程池，如何使用" class="headerlink" title="34.什么是线程池，如何使用?"></a>34.什么是线程池，如何使用?</h3><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）</p>
<h3 id="35-死锁的四个必要条件？怎么避免死锁？"><a href="#35-死锁的四个必要条件？怎么避免死锁？" class="headerlink" title="35.死锁的四个必要条件？怎么避免死锁？"></a>35.死锁的四个必要条件？怎么避免死锁？</h3><p>死锁产生的原因：</p>
<p>1、系统资源的竞争，系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p>
<p>2、进程运行推进顺序不合适</p>
<p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>死锁的避免与预防：</p>
<p>死锁避免的基本思想:<br>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。<br>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。<br>死锁避免和死锁预防的区别：<br>死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</p>
<h3 id="36-ReentrantLock-、synchronized和volatile比较"><a href="#36-ReentrantLock-、synchronized和volatile比较" class="headerlink" title="36.ReentrantLock 、synchronized和volatile比较"></a>36.ReentrantLock 、synchronized和volatile比较</h3><p>java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<h3 id="37-synchronized与Lock的区别及使用场景"><a href="#37-synchronized与Lock的区别及使用场景" class="headerlink" title="37.synchronized与Lock的区别及使用场景"></a>37.synchronized与Lock的区别及使用场景</h3><p>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低；<br>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。<br>使用场景：在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h3 id="38-synchronized-和volatile-关键字的区别"><a href="#38-synchronized-和volatile-关键字的区别" class="headerlink" title="38.synchronized 和volatile 关键字的区别"></a>38.synchronized 和volatile 关键字的区别</h3><p>1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
<h3 id="39-volatile的作用，原理，性能。"><a href="#39-volatile的作用，原理，性能。" class="headerlink" title="39.volatile的作用，原理，性能。"></a>39.volatile的作用，原理，性能。</h3><p>作用：1、保持内存可见性 2、防止指令重排<br>原理：获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。<br>lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。<br>性能：读操作与普通变量无差别，写操作会慢一些，大多情况比锁消耗低。</p>
<h3 id="40-Synchronized用法及原理"><a href="#40-Synchronized用法及原理" class="headerlink" title="40.Synchronized用法及原理"></a>40.Synchronized用法及原理</h3><p>用法：修饰静态方法、实例方法、代码块<br>原理：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zc19921215/article/details/84780335">https://blog.csdn.net/zc19921215/article/details/84780335</a></p>
<h3 id="41-线程间操作List"><a href="#41-线程间操作List" class="headerlink" title="41.线程间操作List"></a>41.线程间操作List</h3><p>List list = Collections.synchronizedList(new ArrayList());</p>
<h3 id="42-两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"><a href="#42-两个进程同时要求写或者读，能不能实现？如何防止进程的同步？" class="headerlink" title="42.两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"></a>42.两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</h3><p>可以实现的。<br>同步方式有： 互斥锁、条件变量、读写锁、记录锁(文件锁)和信号灯</p>
<h3 id="43-如何保证线程安全？"><a href="#43-如何保证线程安全？" class="headerlink" title="43.如何保证线程安全？"></a>43.如何保证线程安全？</h3><p>1.synchronized；<br>2.Object方法中的wait,notify；<br>3.ThreadLocal机制 来实现的。</p>
<h3 id="44-讲一下java中的同步的方法-另一种问法：数据一致性如何保证？"><a href="#44-讲一下java中的同步的方法-另一种问法：数据一致性如何保证？" class="headerlink" title="44.讲一下java中的同步的方法(另一种问法：数据一致性如何保证？)"></a>44.讲一下java中的同步的方法(另一种问法：数据一致性如何保证？)</h3><p>1.即有synchronized关键字修饰的方法。<br>2.同步代码块(如：双重判断的单例模式)<br>3.使用特殊域变量(volatile)实现线程同步<br>4.使用重入锁实现线程同步<br>5.使用局部变量实现线程同步</p>
<h3 id="45-线程如何关闭？"><a href="#45-线程如何关闭？" class="headerlink" title="45.线程如何关闭？"></a>45.线程如何关闭？</h3><p>一种是调用它里面的stop()方法<br>另一种就是你自己设置一个停止线程的标记 （推荐这种）</p>
<h3 id="46-在Java中wait和seelp方法的不同；"><a href="#46-在Java中wait和seelp方法的不同；" class="headerlink" title="46.在Java中wait和seelp方法的不同；"></a>46.在Java中wait和seelp方法的不同；</h3><p>wait是Object的方法，是对象锁，锁住对象不再往下执行，当执行notify的时候才会往下执行。</p>
<p>sleep是Thread的方法，会释放cpu资源，当睡眠结束的时候会继续执行。</p>
<h3 id="47-如何控制某个方法允许并发访问线程的个数？"><a href="#47-如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="47.如何控制某个方法允许并发访问线程的个数？"></a>47.如何控制某个方法允许并发访问线程的个数？</h3><p>semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）<br>semaphore.release() 释放一个信号量，此时信号量个数+1</p>
<h3 id="48-run-和start-方法区别"><a href="#48-run-和start-方法区别" class="headerlink" title="48.run()和start()方法区别"></a>48.run()和start()方法区别</h3><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="49-为什么要有线程，而不是仅仅用进程？"><a href="#49-为什么要有线程，而不是仅仅用进程？" class="headerlink" title="49.为什么要有线程，而不是仅仅用进程？"></a>49.为什么要有线程，而不是仅仅用进程？</h3><p>线程可以增加并发的程度啊。其实多进程也是可以并发，但是为什么要是线程呢？因为线程是属于进程的，是个轻量级的对象。所以再切换线程时只需要做少量的工作，而切换进程消耗很大。这是从操作系统角度讲。<br>从用户程序角度讲，有些程序在逻辑上需要线程，比如扫雷，它需要一个线程等待用户的输入，另一个线程的来更新时间。还有一个例子就是聊天程序，一个线程是响应用户输入，一个线程是响应对方输入。如果没有多线程，那么只能你说一句我说一句，你不说我这里就不能动，我还不能连续说。所以用户程序有这种需要，操作系统就要提供响应的机制</p>
<h3 id="50-开启线程的三种方式？"><a href="#50-开启线程的三种方式？" class="headerlink" title="50.开启线程的三种方式？"></a>50.开启线程的三种方式？</h3><p>java有三种创建线程的方式，分别是继承Thread类、实现Runable接口和使用线程池</p>
<h3 id="51-String为什么要设计成不可变的？"><a href="#51-String为什么要设计成不可变的？" class="headerlink" title="51.String为什么要设计成不可变的？"></a>51.String为什么要设计成不可变的？</h3><p>1、字符串池的需求<br>字符串池是方法区（Method Area）中的一块特殊的存储区域。当一个字符串已经被创建并且该字符串在 池 中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如: string2）的字符串将会导致另一个引用（如: string1）出现脏数据。<br>2、允许字符串缓存哈希码<br>在java中常常会用到字符串的哈希码，例如： HashMap 。String的不变性保证哈希码始终一，因此，他可以不用担心变化的出现。 这种方法意味着不必每次使用时都重新计算一次哈希码——这样，效率会高很多。<br>3、安全<br>String广泛的用于java 类中的参数，如：网络连接（Network connetion），打开文件（opening files ）等等。如果String不是不可变的，网络连接、文件将会被改变——这将会导致一系列的安全威胁。操作的方法本以为连接上了一台机器，但实际上却不是。由于反射中的参数都是字符串，同样，也会引起一系列的安全问题。</p>
<h3 id="52-Java中String的了解"><a href="#52-Java中String的了解" class="headerlink" title="52.Java中String的了解"></a>52.Java中String的了解</h3><p>在源码中string是用final 进行修饰，它是不可更改，不可继承的常量。</p>
<h3 id="53-说说你对Java反射的理解"><a href="#53-说说你对Java反射的理解" class="headerlink" title="53.说说你对Java反射的理解"></a>53.说说你对Java反射的理解</h3><p>JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性。 从对象出发，通过反射（Class类）可以取得取得类的完整信息（类名 Class类型，所在包、具有的所有方法 Method[]类型、某个方法的完整信息（包括修饰符、返回值类型、异常、参数类型）、所有属性 Field[]、某个属性的完整信息、构造器 Constructors），调用类的属性或方法自己的总结： 在运行过程中获得类、对象、方法的所有信息。</p>
<h3 id="54-Java中实现多态的机制是什么？"><a href="#54-Java中实现多态的机制是什么？" class="headerlink" title="54.Java中实现多态的机制是什么？"></a>54.Java中实现多态的机制是什么？</h3><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现<br>重写Overriding是父类与子类之间多态性的一种表现<br>重载Overloading是一个类中多态性的一种表现.</p>
<p>55.Java的异常体系</p>
<p>Throwable，Error，Exception</p>
<h3 id="56-静态代理和动态代理的区别，什么场景使用？"><a href="#56-静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="56.静态代理和动态代理的区别，什么场景使用？"></a>56.静态代理和动态代理的区别，什么场景使用？</h3><p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。<br>场景：著名的Spring框架、Hibernate框架等等都是动态代理的使用例子</p>
<h3 id="57-string-转换成-integer的方式及原理"><a href="#57-string-转换成-integer的方式及原理" class="headerlink" title="57.string 转换成 integer的方式及原理"></a>57.string 转换成 integer的方式及原理</h3><p>String —&gt;integer Intrger.parseInt(string);<br>Integer—&gt; string Integer.toString();<br>原理：<br>parseInt(String s)–内部调用parseInt(s,10)（默认为10进制）<br>正常判断null，进制范围，length等<br>判断第一个字符是否是符号位<br>循环遍历确定每个字符的十进制值<br>通过*= 和-= 进行计算拼接<br>判断是否为负值 返回结果。</p>
<h3 id="58-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#58-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="58.成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>58.成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h3><p>java中内部类主要分为：</p>
<p>成员内部类<br>局部内部类(嵌套在方法和作用域内)<br>匿名内部类（没构造方法）<br>静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>因为Java不支持多继承，支持实现多个接口。但有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<h3 id="59-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#59-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="59.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>59.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h3><p>可继承 不可重写 而是被隐藏<br>如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成。</p>
<h3 id="60-Serializable-和Parcelable-的区别"><a href="#60-Serializable-和Parcelable-的区别" class="headerlink" title="60.Serializable 和Parcelable 的区别"></a>60.Serializable 和Parcelable 的区别</h3><p>Serializable  Java的序列化接口  在磁盘上读写    效率低  由于在读写的时候有大量的变量产生，内部执行大量的io操作</p>
<p>Parcelable   Android的序列化接口  在内存上读写  效率高  使用麻烦，对象不能保存在磁盘上</p>
<h3 id="61-final，finally，finalize的区别"><a href="#61-final，finally，finalize的区别" class="headerlink" title="61.final，finally，finalize的区别"></a>61.final，finally，finalize的区别</h3><p>final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写<br>finally:与try…catch…共同使用，确保无论是否出现异常都能被调用到<br>finalize:类的方法,垃圾回收之前会调用此方法,子类可以重写finalize()方法实现对资源的回收</p>
<h3 id="62-进程和线程的区别"><a href="#62-进程和线程的区别" class="headerlink" title="62.进程和线程的区别"></a>62.进程和线程的区别</h3><p>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。<br>进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。<br>一个进程内可拥有多个线程，进程可开启进程，也可开启线程。<br>一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。</p>
<h3 id="63-父类的静态方法能否被子类重写"><a href="#63-父类的静态方法能否被子类重写" class="headerlink" title="63.父类的静态方法能否被子类重写"></a>63.父类的静态方法能否被子类重写</h3><p>不能，父类的静态方法能够被子类继承，但是不能够被子类重写，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法。</p>
<h3 id="64-抽象类与接口的应用场景"><a href="#64-抽象类与接口的应用场景" class="headerlink" title="64.抽象类与接口的应用场景"></a>64.抽象类与接口的应用场景</h3><p>如果父类的方法必须要有默认实现，就可以用抽象类；</p>
<p>如果实现多继承，那就使用接口；</p>
<p>由于java不支持多继承，不可以集成多个父类，但是可以实现多个接口，因此可以用接口来解决这个问题。</p>
<p>如果有一些基本功能在不断改变，那就比较适合用抽象类。</p>
<p>如果有一些基本功能在不断改变，并且使用接口的话，那么就需要改变实现这个接口的所以类。</p>
<h3 id="65-抽象类和接口区别"><a href="#65-抽象类和接口区别" class="headerlink" title="65.抽象类和接口区别"></a>65.抽象类和接口区别</h3><p>相同：<br>1、都能被继承<br>2、继承的类都必须将未实现的函数实现<br>3、只关注方法的定义，不关注方法的实现</p>
<p>差异：<br>1、一个子类可以继承多个接口，但是只能继承一个父类<br>2、抽象类在对象中只能表示一种对象，接口可以被很多对象继承</p>
<h3 id="66-什么是内部类？内部类的作用"><a href="#66-什么是内部类？内部类的作用" class="headerlink" title="66.什么是内部类？内部类的作用"></a>66.什么是内部类？内部类的作用</h3><p>内部类：将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p>
<p>作用：</p>
<p>1、每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整；</p>
<p>2、方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏；</p>
<p>3、方便编写事件驱动程序；</p>
<p>4、方便编写线程代码</p>
<h3 id="67-谈谈对java多态的理解"><a href="#67-谈谈对java多态的理解" class="headerlink" title="67.谈谈对java多态的理解"></a>67.谈谈对java多态的理解</h3><p>1、多态是指一种行为具有多种不同的表现形式，子类与父类之间的重写，类中的方法重载都是属于多态的表现；</p>
<p>2、多态的三要素：继承、重写、父类引用指向子类对象；</p>
<p>3、多态的好处：可以消除类型之间的耦合关系，具有接口性、简化性、可扩展性、灵活性。</p>
<h3 id="68-int与integer的区别"><a href="#68-int与integer的区别" class="headerlink" title="68.int与integer的区别"></a>68.int与integer的区别</h3><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p>
<h3 id="69-char、int、long、double各占多少字节数"><a href="#69-char、int、long、double各占多少字节数" class="headerlink" title="69.char、int、long、double各占多少字节数"></a>69.char、int、long、double各占多少字节数</h3><p>char:2字节、int:4字节、long\double:8字节</p>
<h3 id="70-java中-和equals和hashCode的区别"><a href="#70-java中-和equals和hashCode的区别" class="headerlink" title="70.java中==和equals和hashCode的区别"></a>70.java中==和equals和hashCode的区别</h3><p>==是运算符，用来比较两个值、两个对象的内存地址是否相等；<br>equals是Object类的方法，默认情况下比较两个对象是否是同一个对象，内部实现是通过“==”来实现的。<br>hashCoed也是Object类里面的方法，返回值是一个对象的哈希码，同一个对象哈希码一定相等，但不同对象哈希码也有可能相等。</p>
<h3 id="71-String-StringBuffer-StringBuilder的区别"><a href="#71-String-StringBuffer-StringBuilder的区别" class="headerlink" title="71.String/StringBuffer/StringBuilder的区别"></a>71.String/StringBuffer/StringBuilder的区别</h3><p>String 一旦创建不可改变，重新赋值其实是创建了一个新的对象</p>
<p>StringBuilder 效率高  线程不安全，因为有缓冲区</p>
<p>StringBuffer  效率低  线程安全</p>
<h3 id="72-线程池都有哪些状态？"><a href="#72-线程池都有哪些状态？" class="headerlink" title="72.线程池都有哪些状态？"></a>72.线程池都有哪些状态？</h3><p>线程池有5种状态：Running运行、ShutDown关机、Stop停止、Tidying清理、Terminated终止。</p>
<h3 id="73-什么是死锁？"><a href="#73-什么是死锁？" class="headerlink" title="73.什么是死锁？"></a>73.什么是死锁？</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
<h3 id="74-说一下-synchronized-底层实现原理？"><a href="#74-说一下-synchronized-底层实现原理？" class="headerlink" title="74.说一下 synchronized 底层实现原理？"></a>74.说一下 synchronized 底层实现原理？</h3><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>MengLong Sun</li>
    <li><strong>本文链接：</strong><a href="http://www.jianzhioffer.com/topic/topic_java%E5%9F%BA%E7%A1%80/index.html" title="http:&#x2F;&#x2F;www.jianzhioffer.com&#x2F;topic&#x2F;topic_java%E5%9F%BA%E7%A1%80&#x2F;index.html">http:&#x2F;&#x2F;www.jianzhioffer.com&#x2F;topic&#x2F;topic_java%E5%9F%BA%E7%A1%80&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
  <nav class="nav">
    <a href="/topic/topic_%E9%9F%B3%E8%A7%86%E9%A2%91/"><i class="iconfont iconleft"></i>音视频</a>
    <a href="/topic/topic_%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%89%93%E5%8C%85/">签名/打包<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%EF%BC%9F"><span class="toc-text">1.二分查找算法 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%EF%BC%9F"><span class="toc-text">2.冒泡排序算法 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.类加载的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.说一下四种引用以及他们的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-text">5.如何判断对象可回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-String-s1-%E2%80%9Cabc%E2%80%9D%E5%92%8CString-s2-new-String-%E2%80%9Cabc%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">6.String s1 &#x3D; “abc”和String s2 &#x3D; new String(“abc”)的区别，生成对象的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-text">7.什么是类型擦除？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">8.说一下对泛型的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HashMap%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FHashMap%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">9.HashMap的特点是什么？HashMap的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Java%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">10.Java中抽象类和接口的特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.String,StringBuffer,StringBuilder的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%90%8C%E6%AD%A5%E9%94%81%E5%AF%B9%E4%BA%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%94%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12.同步锁对于静态方法锁的对象是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-final-%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">13.final 可以修饰类和方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%89%8B%E5%86%99%E5%87%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">14.手写出单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%B7%AE%E5%80%BC%E5%99%A8%E5%92%8C%E4%BC%B0%E5%80%BC%E5%99%A8"><span class="toc-text">15.差值器和估值器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%B0%88%E8%B0%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">16.谈谈对接口与回调的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-WebSocket%E4%B8%8Esocket%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">17.WebSocket与socket的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-HttpClient%E4%B8%8EHttpUrlConnection%E7%9A%84%E5%8C%BA%E5%88%AB-%E6%AD%A4%E5%A4%84%E5%BB%B6%E4%BC%B8%EF%BC%9AVolley%E9%87%8C%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%882-3%E5%89%8DHttpClient%EF%BC%8C2-3%E5%90%8EHttpUrlConnection%EF%BC%89"><span class="toc-text">18.HttpClient与HttpUrlConnection的区别 (此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-client%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E8%A2%ABserver%E6%94%B6%E5%88%B0"><span class="toc-text">19.client如何确定自己发送的消息被server收到?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-text">20.如何验证证书的合法性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">21.HTTP与HTTPS的区别以及如何实现安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">22.HTTP报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-HTTP%E9%93%BE%E6%8E%A5%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">23.HTTP链接的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Http%E4%BD%8D%E4%BA%8ETCP-IP%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%B1%82%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Http%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">24.Http位于TCP&#x2F;IP模型中的第几层？为什么说Http是可靠的数据传输协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Http-https%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%AD%A4%E5%A4%84%E5%BB%B6%E4%BC%B8%EF%BC%9Ahttps%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">25.Http https区别，此处延伸：https的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-TCP%E4%B8%8EUDP%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">26.TCP与UDP的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">27.TCP与UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">28.为什么不能用两次握手进行连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-text">29.为什么连接的时候是三次握手，关闭的时候却是四次握手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-TCP%E7%9A%843%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">30.TCP的3次握手和四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BB%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA10M%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E8%AF%B4%E4%B8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">31.从网络加载一个10M的图片，说下注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">32.多线程有什么要注意的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%B0%88%E8%B0%88%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">33.谈谈对多线程的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">34.什么是线程池，如何使用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">35.死锁的四个必要条件？怎么避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-ReentrantLock-%E3%80%81synchronized%E5%92%8Cvolatile%E6%AF%94%E8%BE%83"><span class="toc-text">36.ReentrantLock 、synchronized和volatile比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">37.synchronized与Lock的区别及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-synchronized-%E5%92%8Cvolatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">38.synchronized 和volatile 关键字的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-volatile%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%A7%E8%83%BD%E3%80%82"><span class="toc-text">39.volatile的作用，原理，性能。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-Synchronized%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">40.Synchronized用法及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%93%8D%E4%BD%9CList"><span class="toc-text">41.线程间操作List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%97%B6%E8%A6%81%E6%B1%82%E5%86%99%E6%88%96%E8%80%85%E8%AF%BB%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">42.两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">43.如何保证线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E8%AE%B2%E4%B8%80%E4%B8%8Bjava%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95-%E5%8F%A6%E4%B8%80%E7%A7%8D%E9%97%AE%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-text">44.讲一下java中的同步的方法(另一种问法：数据一致性如何保证？)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%EF%BC%9F"><span class="toc-text">45.线程如何关闭？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%9C%A8Java%E4%B8%ADwait%E5%92%8Cseelp%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9B"><span class="toc-text">46.在Java中wait和seelp方法的不同；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-text">47.如何控制某个方法允许并发访问线程的个数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-run-%E5%92%8Cstart-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-text">48.run()和start()方法区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BB%85%E4%BB%85%E7%94%A8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">49.为什么要有线程，而不是仅仅用进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">50.开启线程的三种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-text">51.String为什么要设计成不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-Java%E4%B8%ADString%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">52.Java中String的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Java%E5%8F%8D%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">53.说说你对Java反射的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">54.Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">56.静态代理和动态代理的区别，什么场景使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-string-%E8%BD%AC%E6%8D%A2%E6%88%90-integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">57.string 转换成 integer的方式及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">58.成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">59.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-Serializable-%E5%92%8CParcelable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">60.Serializable 和Parcelable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">61.final，finally，finalize的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">62.进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="toc-text">63.父类的静态方法能否被子类重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">64.抽象类与接口的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB"><span class="toc-text">65.抽象类和接口区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">66.什么是内部类？内部类的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E8%B0%88%E8%B0%88%E5%AF%B9java%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">67.谈谈对java多态的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-int%E4%B8%8Einteger%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">68.int与integer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-char%E3%80%81int%E3%80%81long%E3%80%81double%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">69.char、int、long、double各占多少字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-java%E4%B8%AD-%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">70.java中&#x3D;&#x3D;和equals和hashCode的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">71.String&#x2F;StringBuffer&#x2F;StringBuilder的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">72.线程池都有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">73.什么是死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E8%AF%B4%E4%B8%80%E4%B8%8B-synchronized-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">74.说一下 synchronized 底层实现原理？</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a><p><a target="_blank" href="https://beian.miit.gov.cn/">京ICP备20023327号-1</a></p></p></div>
  
</footer>
  
  
  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>