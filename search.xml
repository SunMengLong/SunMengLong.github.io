<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android中自定义checkbox样式</title>
    <url>/AndroidView/Android%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zuolongsnail/article/details/7106586">https://blog.csdn.net/zuolongsnail/article/details/7106586</a></p>
]]></content>
      <categories>
        <category>AndroidView</category>
      </categories>
  </entry>
  <entry>
    <title>RecycleView将指定item滚动到顶部</title>
    <url>/AndroidView/RecycleView%E5%B0%86%E6%8C%87%E5%AE%9Aitem%E6%BB%9A%E5%8A%A8%E5%88%B0%E9%A1%B6%E9%83%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/pkorochi/article/details/90640213">https://blog.csdn.net/pkorochi/article/details/90640213</a></p>
]]></content>
      <categories>
        <category>AndroidView</category>
      </categories>
  </entry>
  <entry>
    <title>Dialog从底部弹出</title>
    <url>/AndroidView/BottomDialog/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zhangqunshuai/article/details/80858219">https://blog.csdn.net/zhangqunshuai/article/details/80858219</a></p>
]]></content>
      <categories>
        <category>AndroidView</category>
      </categories>
  </entry>
  <entry>
    <title>TextView改变部分字体颜色</title>
    <url>/AndroidView/TextChangePartColor/</url>
    <content><![CDATA[<p><a href="https://www.iteye.com/blog/zhoujianghai-1048823">https://www.iteye.com/blog/zhoujianghai-1048823</a></p>
]]></content>
      <categories>
        <category>AndroidView</category>
      </categories>
  </entry>
  <entry>
    <title>自定义相机</title>
    <url>/CustomView/CustomCamera/</url>
    <content><![CDATA[<p><a href="https://github.com/aserbao/AndroidCamera">https://github.com/aserbao/AndroidCamera</a></p>
]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
  </entry>
  <entry>
    <title>TextView末尾添加“查看全文”</title>
    <url>/CustomView/ExpandLongTextView/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/dodouaj/article/details/52212835?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/dodouaj/article/details/52212835?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
  </entry>
  <entry>
    <title>仿微信联系人快速索引View，A到Z</title>
    <url>/CustomView/%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%94%E7%B3%BB%E4%BA%BA%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95AZView/</url>
    <content><![CDATA[<p><a href="http://www.bubuko.com/infodetail-2319010.html?__cf_chl_jschl_tk__=65808acb5b4f33d937a772f430b81bba217d4041-1608537726-0-AfV6yKNvP2OHoS1QFoppLRRJ0X90aV-wRMVfAZpDnEcHD5Vl6jfL0esjvppsPT4-RHFXcU0lNM8V4hKLhnY2sSXd3RsLm8Pu4yPspGc22ednYEA9VRwmshmlFAs8kZ4gAhhx3ICeteJ7hmIq0DWtZFXg1zWMU0_R_D_YohpTO3PWm_-Ya0aOutwMDtN5YSjQ05DODok3FwrcJsr17CwMq640IYxqkWEUx1NL4P_ZeSNkTEyRlsJPJaSesMDMewX4rc_aPDO3OEGg5gKWJS_5OYpWCFXYF04t5r24r3XJhBP6fm5guGkz3eSMM3DQYGkWEgvqMds6szq-QPwemngqF1U">http://www.bubuko.com/infodetail-2319010.html?__cf_chl_jschl_tk__=65808acb5b4f33d937a772f430b81bba217d4041-1608537726-0-AfV6yKNvP2OHoS1QFoppLRRJ0X90aV-wRMVfAZpDnEcHD5Vl6jfL0esjvppsPT4-RHFXcU0lNM8V4hKLhnY2sSXd3RsLm8Pu4yPspGc22ednYEA9VRwmshmlFAs8kZ4gAhhx3ICeteJ7hmIq0DWtZFXg1zWMU0_R_D_YohpTO3PWm_-Ya0aOutwMDtN5YSjQ05DODok3FwrcJsr17CwMq640IYxqkWEUx1NL4P_ZeSNkTEyRlsJPJaSesMDMewX4rc_aPDO3OEGg5gKWJS_5OYpWCFXYF04t5r24r3XJhBP6fm5guGkz3eSMM3DQYGkWEgvqMds6szq-QPwemngqF1U</a></p>
]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
  </entry>
  <entry>
    <title>生成类似钉钉、微信 群聊组合头像Bitmap</title>
    <url>/CustomView/%E7%BB%84%E5%90%88%E5%A4%B4%E5%83%8FView/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/mx_xxs/article/details/102594136">https://blog.csdn.net/mx_xxs/article/details/102594136</a></p>
<p><a href="https://www.wanandroid.com/blog/show/2180">https://www.wanandroid.com/blog/show/2180</a></p>
]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
  </entry>
  <entry>
    <title>Android——顶部弹出Snackbar</title>
    <url>/CustomView/%E9%A1%B6%E9%83%A8%E5%BC%B9%E5%87%BASnackbar/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/yz1743585120/article/details/102609543">https://blog.csdn.net/yz1743585120/article/details/102609543</a></p>
]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
  </entry>
  <entry>
    <title>Android 8.0 启动Service适配(Not allowed to start service Intent)</title>
    <url>/exception/Android%208.0%E5%90%AF%E5%8A%A8Service%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/gxlgxjhll/article/details/88684993">https://blog.csdn.net/gxlgxjhll/article/details/88684993</a></p>
]]></content>
      <categories>
        <category>常见异常</category>
      </categories>
  </entry>
  <entry>
    <title>Android 8.0透明Activity报错 &quot;Only fullscreen activities can request orientation&quot;</title>
    <url>/exception/Android8.0%E9%80%8F%E6%98%8EActivity%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/LoveDou0816/article/details/79129324?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/LoveDou0816/article/details/79129324?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
]]></content>
      <categories>
        <category>常见异常</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidVpnService返回空，Android VPN Service Builder.establish() returns null</title>
    <url>/exception/AndroidVpnService%E8%BF%94%E5%9B%9E%E7%A9%BA/</url>
    <content><![CDATA[<p>作为VpnService.Builder.establish <a href="http://developer.android.com/reference/android/net/VpnService.Builder.html">文档</a> ： </p>
<p> <code>Returns ParcelFileDescriptor of the VPN interface, or null if the application is not prepared.</code> </p>
<p> 需要先调用VpnService.prepare： </p>
<p>参考博客：<a href="https://www.656463.com/wenda/AndroidVPNServiceBuilderestablis_147">https://www.656463.com/wenda/AndroidVPNServiceBuilderestablis_147</a></p>
]]></content>
      <categories>
        <category>常见异常</category>
      </categories>
  </entry>
  <entry>
    <title>Android收集程序崩溃日志</title>
    <url>/exception/Android%E6%94%B6%E9%9B%86%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/xy4_android/article/details/80846610">https://blog.csdn.net/xy4_android/article/details/80846610</a></p>
]]></content>
      <categories>
        <category>常见异常</category>
      </categories>
  </entry>
  <entry>
    <title>执行github拉取代码出现错误OpenSSLSSL_readSSL_ERROR_SYSCALLerrno10054解决方法github报github上传下载代码报错</title>
    <url>/exception/github%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>最近在系统学习多线程并发的课程，课程中讲到了unsafe类，由于unsafe类在jdk中看不到源码，在idea中打开是反编译的，看不到具体的注释，所以去github上拉取openjdk的源码，openjdk上可以看到源码注释，但是在拉取时，一开始是好好地，但是拉取了一二十分钟后，突然报错了</p>
<p><img  src="../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExNzQ2OTk=,size_16,color_FFFFFF,t_70.png"  ><span class="image-caption">img</span></p>
<p>以前在github上拉取过很多图书的源码（买了很多技术书籍），拉取代码都是正常的，就是这次出错了，</p>
<p>解决方法也很简单：</p>
<p>继续输入命令</p>
<p>  git config http.sslVerify “false”</p>
<p>还是会报错的话：fatal: not in a git directory</p>
<p><img  src="../../images/20200611153034947.png"  ><span class="image-caption">img</span></p>
<p>那么，再次输入命令：</p>
<p> git config –global http.sslVerify “false”</p>
<p><img  src="../../images/20200611153155868.png"  ><span class="image-caption">img</span></p>
<p>再次克隆会报错，那就是原先执行clone时的那份文件没删除，删除，然后重新执行git clone命令</p>
]]></content>
      <categories>
        <category>常见异常</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo部署</title>
    <url>/hexo/Hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="修改网站基本信息："><a href="#修改网站基本信息：" class="headerlink" title="修改网站基本信息："></a>修改网站基本信息：</h4><p>参考文档：<a href="https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc">https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc</a></p>
<p>本地配置文件：.\blog\themes\zhaoo\_config.yml</p>
<h4 id="本地部署："><a href="#本地部署：" class="headerlink" title="本地部署："></a>本地部署：</h4><p>删除.\blog\public\content.json及.\blog\public\search.xml</p>
<p>hexo clean  //清除缓存</p>
<p>hexo g  //构建</p>
<p>hexo clean  //清除缓存</p>
<p>hexo g  //构建</p>
<p>将.\blog\public\search.xml替换为.\blog\source\download\search.xml</p>
<p>hexo s  //本地部署</p>
<p>hexo d  //更新至github</p>
<h4 id="更新博客："><a href="#更新博客：" class="headerlink" title="更新博客："></a>更新博客：</h4><p>博客位置：.\blog\source_posts</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo撰写文章</title>
    <url>/hexo/hexo%E5%86%99%E6%96%87%E7%AB%A0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>写文章教程：<a href="https://blog.csdn.net/wsmrzx/article/details/81478945">https://blog.csdn.net/wsmrzx/article/details/81478945</a></p>
<p>添加图片教程：<a href="https://www.jianshu.com/p/47c61c924669">https://www.jianshu.com/p/47c61c924669</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo最全搭建教程</title>
    <url>/hexo/hexo%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo无法搜索的终极解决办法</title>
    <url>/hexo/hexo%E6%97%A0%E6%B3%95%E6%90%9C%E7%B4%A2%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><img  src="../../images/15145248387556-16388730440412.jpg"  ><span class="image-caption">img</span></p>
<p>以前在 Hexo 的 next 主题上遇到了搜索框无法加载出来的问题，已经一系列分析查找，终于完美的解决了 Hexo 博客的 next 主题的搜索问题，同理其他 Hexo 主题解决方法大致相同。</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本次是在<code>Hexo</code>博客下的<code>next</code>主题进行测试的。一般<code>Hexo</code>博客无法搜索主要有<code>2</code>种以下情况:</p>
<ul>
<li><code>搜索插件没有配置好</code></li>
<li><code>文章中包含特殊字符</code></li>
</ul>
<p><code>Hexo</code> 的搜索出了问题，点击搜索会一直转圈圈，搜索无法加载出来，如下图所示:</p>
<p><img  src="../../images/15145228365294.png"  ><span class="image-caption">img</span></p>
<p>下面分别对这<code>2</code>情况进行解决。</p>
<h1 id="搜索插件的配置"><a href="#搜索插件的配置" class="headerlink" title="搜索插件的配置"></a>搜索插件的配置</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>浏览器审查元素，转到网络模块，然后点击搜索，发现<code>search.xml</code>的状态为<code>404</code>的状态，这表明这个文件不存在。</p>
<p><img  src="../../images/15145231219074.png"  ><span class="image-caption">img</span></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>编辑 <code>站点配置文件</code>，新增以下内容到任意位置：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><code class="hljs r">search:<br>  path: search.xml<br>  field: post<br>  format: html<br>  limit: <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<p>编辑 <code>主题配置文件</code>，启用本地搜索功能：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><code class="hljs r"><span class="hljs-comment"># Local search</span><br>local_search:<br>  enable: true<br></code></pre></td></tr></table></figure>

<p><strong>安装搜索插件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs ru">C:\Users\CTF\Documents\GG<br>λ npm install hexo-generator-searchdb --save<br><br>+ hexo-generator-searchdb@1.0.8<br>added 119 packages in 8.327s<br></code></pre></td></tr></table></figure>

<p>然后再重新生成静态文件，会发现 <code>Hexo</code> 博客的搜索功能已经可以正常使用了。</p>
<h1 id="文章中特殊字符"><a href="#文章中特殊字符" class="headerlink" title="文章中特殊字符"></a>文章中特殊字符</h1><h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><p>确保了搜索插件配置没有问题的情况下，有时候我们还是会遇到无法搜索的问题，浏览器调试发现:</p>
<p><img  src="../../images/1514523841767.png"  ><span class="image-caption">img</span></p>
<p>此时的<code>search.xml</code>文件存在，但是点击搜索的时候去找<code>search.xml</code>资源的时候发现是<code>304</code>的状态码，说明这个<code>xml</code>文件解析异常。</p>
<p>浏览器直接访问<code>search.xml</code>文件看看:</p>
<p><img  src="../../images/15145240023077.png"  ><span class="image-caption">img</span><br>果然 <code>search.xml</code> 文件无法正常的解析。</p>
<p>查看返回包，找到文件中特殊字符的所在位置:</p>
<p><img  src="../../images/15145241354418.png"  ><span class="image-caption">img</span></p>
<p>用<code>Sublime Text3</code>和 <code>Visual Studio Code</code> 分别打开文件对比看看，这两个编辑器都找到了特殊字符。</p>
<p><img  src="../../images/15145243584788.png"  ><span class="image-caption">img</span></p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>既然知道了文件中特殊字符所造成生成的<code>search.xml</code>文件无法正常解析的话，那么解决也好解决了，就是删掉这些特殊字符。如果特殊字符比较多的话，建议使用 <code>Visual Studio Code</code> 去批量删除。<br>首先<code>标记特殊字符</code>，然后<code>Ctrl</code>+<code>F</code>键，全部查找出来。<code>展开替换按钮</code>，全部替换为<code>空</code>就可以啦。</p>
<p><img  src="../../images/15145246587889.png"  ><span class="image-caption">img</span></p>
<p>然后再重新生成静态文件，会发现 <code>Hexo</code> 博客的搜索功能已经可以正常使用了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>zhaoo主题配置文档</title>
    <url>/hexo/zhaoo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p><a href="https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc/#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc/#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>万能列表适配器BaseRecyclerViewAdapter</title>
    <url>/github/AdapterX/</url>
    <content><![CDATA[<p>github地址：<a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper">https://github.com/CymChad/BaseRecyclerViewAdapterHelper</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>Lottie动画库</title>
    <url>/github/AnimatorX/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>　　Lottie是Airbnb开源的一个面向IOS、Android、React Native的动画库，能分析Adobe After Effects导出的动画，并且能让原生App像使用静态素材一样使用这些动画，完美实现动画效果。<br>　　现在使用个平台的native代码实现一套复杂的动画是一件很困难并且很耗时的事，需要为不同尺寸的屏幕加载不同的素材资源，还需要写大量难维护的代码，而Lottie可以做到同一个通话文件在不同平台上实现相同的效果，极少减少开发时间，实现不同的动画，只需要设置不同的动画文件即可，极少减少开发和维护成本。</p>
<p>使用说明：<a href="https://www.jianshu.com/p/282d098cf928?utm_source=oschina-app">https://www.jianshu.com/p/282d098cf928?utm_source=oschina-app</a></p>
<p>github地址：<a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>MagicIndicator指示器</title>
    <url>/github/IndicatorX/</url>
    <content><![CDATA[<h3 id="支持高定制化的指示器"><a href="#支持高定制化的指示器" class="headerlink" title="支持高定制化的指示器"></a>支持高定制化的指示器</h3><p>github地址：<a href="https://github.com/hackware1993/MagicIndicator">https://github.com/hackware1993/MagicIndicator</a></p>
<p>使用说明：<a href="https://www.jianshu.com/p/2865812fed41/">https://www.jianshu.com/p/2865812fed41/</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>MPChart折线图</title>
    <url>/github/MPChartX/</url>
    <content><![CDATA[<p>github地址：<a href="https://github.com/PhilJay/MPAndroidChart">https://github.com/PhilJay/MPAndroidChart</a></p>
<p>使用说明：<a href="https://www.jianshu.com/p/2f0ff59ec911">https://www.jianshu.com/p/2f0ff59ec911</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>跑马灯库</title>
    <url>/github/MarqueeViewX/</url>
    <content><![CDATA[<p>俗名：可垂直跑、可水平跑的跑马灯<br>学名：可垂直翻、可水平翻的翻页公告</p>
<p>github地址：<a href="https://github.com/sunfusheng/MarqueeView/">https://github.com/sunfusheng/MarqueeView/</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>NewbieGuide新手引导库</title>
    <url>/github/NewbieGuideX/</url>
    <content><![CDATA[<h3 id="Android-快速实现新手引导层的库，通过简洁链式调用，一行代码实现引导层的显示"><a href="#Android-快速实现新手引导层的库，通过简洁链式调用，一行代码实现引导层的显示" class="headerlink" title="Android 快速实现新手引导层的库，通过简洁链式调用，一行代码实现引导层的显示"></a>Android 快速实现新手引导层的库，通过简洁链式调用，一行代码实现引导层的显示</h3><p>github地址：<a href="https://github.com/huburt-Hu/NewbieGuide">https://github.com/huburt-Hu/NewbieGuide</a></p>
<p>使用说明：<a href="https://www.jianshu.com/p/9609e547c128">https://www.jianshu.com/p/9609e547c128</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>EasyPopup弹框</title>
    <url>/github/PopupX/</url>
    <content><![CDATA[<p>PopupWindow Wrapper. 对 PopupWindow 的封装。可指定相对于 anchor view 各个方位弹出，设置背景变暗，指定 ViewGroup 背景变暗等特性。</p>
<p>github地址：<a href="https://github.com/zyyoona7/EasyPopup/">https://github.com/zyyoona7/EasyPopup/</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>阴影Layout</title>
    <url>/github/ShadowLayoutX/</url>
    <content><![CDATA[<p>可定制化阴影的万能阴影布局ShadowLayout 2.0 震撼上线。效果赶超CardView。阴影支持x,y轴偏移，支持阴影扩散程度，支持阴影圆角，支持单边或多边不显示阴影；控件支持动态设置shape和selector（项目里再也不用画shape了）；支持随意更改颜色值，支持随意更改颜色值，支持随意更改颜色值。重要的事情说三遍</p>
<p>github地址：<a href="https://github.com/zhoushunli/ShadowLayout">https://github.com/zhoushunli/ShadowLayout</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>XUpdate检测升级库</title>
    <url>/github/UpdateX/</url>
    <content><![CDATA[<p>一个轻量级、高可用性的Android全量版本更新框架。</p>
<p>github地址：<a href="https://github.com/xuexiangjys/XUpdate">https://github.com/xuexiangjys/XUpdate</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidUtilCode工具库</title>
    <url>/github/UtilX/</url>
    <content><![CDATA[<p>今天给大家推荐的这个项目是「<strong>AndroidUtilCode</strong>」—— 一个强大易用 Android 卓工具类库，它合理地封装了 Android 开发中常用的函数，具有完善的 Demo 和单元测试，利用其封装好的 APIs 可以大大提高开发效率。</p>
<p>github地址：<a href="https://github.com/Blankj/AndroidUtilCode">https://github.com/Blankj/AndroidUtilCode</a></p>
<p>使用说明博客：<a href="https://blog.csdn.net/Yofreg/article/details/105843227">https://blog.csdn.net/Yofreg/article/details/105843227</a></p>
]]></content>
      <categories>
        <category>github常用框架</category>
      </categories>
  </entry>
  <entry>
    <title>彩色创意风格行政管理求职简历模板</title>
    <url>/resume/resume_1/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_1.png"></p>
<p><a href="/download/resume/1%E5%BD%A9%E8%89%B2%E5%88%9B%E6%84%8F%E9%A3%8E%E6%A0%BC%E8%A1%8C%E6%94%BF%E7%AE%A1%E7%90%86%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>经典风格java工程师黑色求职简历word简历模板</title>
    <url>/resume/resume_10/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_10.png"></p>
<p><a href="/download/resume/10%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BCjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%BB%91%E8%89%B2%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>经典风格java工程师求职简历青草绿word简历模板</title>
    <url>/resume/resume_11/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_11.png"></p>
<p><a href="/download/resume/11%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BCjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86%E9%9D%92%E8%8D%89%E7%BB%BFword%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>蓝粉现代风UI设计师求职简历word简历模板</title>
    <url>/resume/resume_12/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_12.png"></p>
<p><a href="/download/resume/12%E8%93%9D%E7%B2%89%E7%8E%B0%E4%BB%A3%E9%A3%8EUI%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>蓝色方块财务实习生求职简历word简历模板</title>
    <url>/resume/resume_13/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_13.png"></p>
<p><a href="/download/resume/13%E8%93%9D%E8%89%B2%E6%96%B9%E5%9D%97%E8%B4%A2%E5%8A%A1%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>蓝色简洁风工程师成套Word简历模板</title>
    <url>/resume/resume_14/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_14.png"></p>
<p><a href="/download/resume/14%E8%93%9D%E8%89%B2%E7%AE%80%E6%B4%81%E9%A3%8E%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E5%A5%97Word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>蓝色简约商务C语言工程师求职简历word模板</title>
    <url>/resume/resume_15/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_15.png"></p>
<p><a href="/download/resume/15%E8%93%9D%E8%89%B2%E7%AE%80%E7%BA%A6%E5%95%86%E5%8A%A1C%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86word%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>彩色时间轴产品运营求职简历word简历模板</title>
    <url>/resume/resume_2/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_2.png"></p>
<p><a href="/download/resume/2%E5%BD%A9%E8%89%B2%E6%97%B6%E9%97%B4%E8%BD%B4%E4%BA%A7%E5%93%81%E8%BF%90%E8%90%A5%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>纯色简约软件工程师成套简历word简历模板</title>
    <url>/resume/resume_3/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_3.png"></p>
<p><a href="/download/resume/3%E7%BA%AF%E8%89%B2%E7%AE%80%E7%BA%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E5%A5%97%E7%AE%80%E5%8E%86word%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>纯色运维工程师求职简约简历word模板</title>
    <url>/resume/resume_4/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_4.png"></p>
<p><a href="/download/resume/4%E7%BA%AF%E8%89%B2%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%B1%82%E8%81%8C%E7%AE%80%E7%BA%A6%E7%AE%80%E5%8E%86word%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>黑白灰简洁市场销售word个人简历模板</title>
    <url>/resume/resume_5/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_5.png"></p>
<p><a href="/download/resume/5%E9%BB%91%E7%99%BD%E7%81%B0%E7%AE%80%E6%B4%81%E5%B8%82%E5%9C%BA%E9%94%80%E5%94%AEword%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>互联网产品经理现代风格简历模板</title>
    <url>/resume/resume_6/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_6.png"></p>
<p><a href="/download/resume/6%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%8E%B0%E4%BB%A3%E9%A3%8E%E6%A0%BC%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>简洁简历封面模板word简历模板word简历模板</title>
    <url>/resume/resume_7/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_7.png"></p>
<p><a href="/download/resume/7%E7%AE%80%E6%B4%81%E7%AE%80%E5%8E%86%E5%B0%81%E9%9D%A2%E6%A8%A1%E6%9D%BFword%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BFword%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.doc" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>经典风格前端开发求职简历灰蓝word简历模板</title>
    <url>/resume/resume_8/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_8.png"></p>
<p><a href="/download/resume/8%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86%E7%81%B0%E8%93%9Dword%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>经典风格行政文秘求职简历蓝优雅绿word简历模板</title>
    <url>/resume/resume_9/</url>
    <content><![CDATA[<p><img src="../../images/resume/resume_9.png"></p>
<p><a href="/download/resume/9%E7%BB%8F%E5%85%B8%E9%A3%8E%E6%A0%BC%E8%A1%8C%E6%94%BF%E6%96%87%E7%A7%98%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86%E8%93%9D%E4%BC%98%E9%9B%85%E7%BB%BFword%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.docx" title="简历模版">点击下载</a></p>
]]></content>
      <categories>
        <category>简历模版</category>
      </categories>
  </entry>
  <entry>
    <title>React学习记录</title>
    <url>/react/react%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/q1ngqingsky/article/details/106579219">http-server在本地测试react/vue项目</a></p>
<p><a href="https://ant.design/docs/react/introduce-cn">Ant Design</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/151286410">React 本地存储localStorage用法</a></p>
<p><a href="https://blog.csdn.net/liwusen/article/details/86482467">React优化长列表</a></p>
<p><a href="https://www.runoob.com/react/react-tutorial.html">React 教程 | 菜鸟教程</a></p>
<p><a href="https://github.com/brickspert/blog/issues/1#init">从零搭建React全家桶框架教程</a></p>
<p>[<a href="https://www.cnblogs.com/minnie-huang/p/12812562.html">webpack]zsh: command not found: webpack</a></p>
<p><a href="https://blog.csdn.net/weixin_42280089/article/details/88937175">Mac下git配置及与VScode配合使用</a></p>
<p><a href="https://blog.csdn.net/weixin_43788115/article/details/107006719">React中使用echarts（折线图）</a></p>
<p><a href="https://blog.csdn.net/qq_42817227/article/details/86150176">react中react-router路由重定向（登录成功后跳转到首页）</a></p>
<p><a href="https://www.cnblogs.com/xiaoyaoweb/p/13025011.html">react 国际化 react-i18next</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/45204328">react route跳转+传参的简单demo</a></p>
<p><a href="https://blog.csdn.net/wei1273356078/article/details/106332444">webpack配置-source-map（让错误无处可逃）_wei1273356078的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>ReactNative学习记录</title>
    <url>/rn/rn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><a href="https://reactnative.cn/docs/getting-started">简介 · React Native 中文网</a></li>
<li><a href="https://www.cnblogs.com/plBlog/p/12342806.html">react-native调试方法</a></li>
<li><a href="https://blog.csdn.net/wolfking0608/article/details/80567331">React-native 程序第一个HelloWorld的编写</a></li>
<li><a href="https://blog.csdn.net/qq_25827845/article/details/52974991">React—Native开发之 Could not connect to development server（Android）解决方法</a></li>
<li><a href="https://blog.csdn.net/jetable/article/details/96994287">mac搭建并运行react-native项目</a></li>
<li><a href="https://blog.csdn.net/navywang123456/article/details/88584029?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-9.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-9.control">RN的第一个项目：导航+底部条切换+页面跳转</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/59099133">推荐几个 React Native UI 库</a></li>
<li><a href="https://blog.csdn.net/YU_M_K/article/details/80718304?utm_source=blogxgwz4">React-Native之引导页跳转到主页</a></li>
<li><a href="https://blog.csdn.net/z372574152/article/details/105121458/">React Native多语言切换</a></li>
<li><a href="https://blog.csdn.net/weixin_44824839/article/details/107656131">react native中软键盘收起时使输入框失去焦点</a></li>
<li><a href="https://blog.csdn.net/mochiwxtianya/article/details/88393026">React-Native 最完美的提示组件: Toast@2.0</a></li>
<li><a href="https://www.jianshu.com/p/a17945343d4e/">react-native启动页配置</a></li>
<li><a href="https://blog.csdn.net/weixin_43729943/article/details/108330056">React Native导航栏系列（一）</a></li>
<li><a href="https://www.jianshu.com/p/364f334cabbc">React Native创建底部导航栏（Bottom Tab） - 简书</a></li>
<li><a href="https://blog.csdn.net/menglong0329/article/details/117921330">RN创建第一个项目_menglong0329的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_36355271/article/details/104606158">React Native 导航react-navigation 报错找不到的问题__ZHANGJUNPING的博客-CSDN博客</a></li>
<li><a href="https://www.reactnavigation.org.cn/docs/guide-quick-start">快速开始 · React Navigation中文网</a></li>
<li><a href="https://www.jianshu.com/p/6405bce68cec">Mac zsh: command not found zsh 所有命令在终端失效 - 简书</a></li>
<li><a href="https://blog.csdn.net/duoduo_11011/article/details/86647011">CheckBox</a></li>
<li><a href="https://blog.51cto.com/u_13955864/2173335">react native本地存储_漫漫的king的技术博客_51CTO博客</a></li>
<li><a href="https://blog.csdn.net/rushichunqiu/article/details/82894607">react-native 生成二维码并截图保存的功能实现_rushichunqiu的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_33721382/article/details/103483118">更新RN版本后Android端打包APP问题解决</a></li>
<li><a href="https://blog.csdn.net/qq_38356174/article/details/95360470">React Native实现扫描二维码功能基于react-native-camera</a></li>
<li>[<a href="https://www.cnblogs.com/wukong1688/p/10911222.html">RN] React Native 仿美团下拉筛选菜单控件 - wukong1688 - 博客园</a></li>
<li><a href="https://www.cnblogs.com/plBlog/p/12358882.html">react native两次点击返回按钮退出APP - simple-love - 博客园</a></li>
<li><a href="https://blog.csdn.net/u011135887/article/details/74909670?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-1-74909670.pc_agg_rank_aggregation&utm_term=reactnative%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F&spm=1000.2123.3001.4430">React native 沉浸式状态栏解决方案</a></li>
<li><a href="https://www.hangge.com/blog/cache/detail_1613.html">React Native - 状态栏组件（StatusBar）的使用详解</a></li>
<li><a href="https://www.fontke.com/tool/pickrgb/">RGB色彩拾取器,RGB拾色器 - 在线工具 - 字客网</a></li>
<li><a href="https://blog.csdn.net/snow51/article/details/80669507">Shadow 阴影效果</a></li>
<li><a href="https://www.cnblogs.com/zhenfei-jiang/p/9454352.html">一款基于react-native的弹窗提示组件 - 非常007 - 博客园</a></li>
<li><a href="https://blog.csdn.net/weixin_38233549/article/details/103601068">(3条消息) react-native开发Android篇——修改包名、打包apk、TypeError: Network request failed_辣辣的草莓酱-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_41534645/article/details/80149803">(3条消息) react native 使用navigation进行页面反向传值（亲测有效）_三七二十一的博客-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/liuw-flexi/p/11653607.html">React Native 中 跨页面间通信解决方案之 react-native-event-bus - liuw_flexi - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>RN</category>
      </categories>
  </entry>
  <entry>
    <title>APng图片展示</title>
    <url>/study/APng%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>github地址：<a href="https://github.com/penfeizhou/APNG4Android">https://github.com/penfeizhou/APNG4Android</a></p>
<h3 id="Add-dependency-in-build-gradle"><a href="#Add-dependency-in-build-gradle" class="headerlink" title="Add dependency in build.gradle"></a>Add dependency in build.gradle</h3><figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">repositories</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">mavenCentral</span>()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Animated-WebP"><a href="#Animated-WebP" class="headerlink" title="Animated WebP"></a>Animated WebP</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>    <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.github.penfeizhou.android.animation:awebp:<span class="hljs-variable">$&#123;VERSION&#125;</span>&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="APNG"><a href="#APNG" class="headerlink" title="APNG"></a>APNG</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>    <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.github.penfeizhou.android.animation:apng:<span class="hljs-variable">$&#123;VERSION&#125;</span>&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Gif"><a href="#Gif" class="headerlink" title="Gif"></a>Gif</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>    <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.github.penfeizhou.android.animation:gif:<span class="hljs-variable">$&#123;VERSION&#125;</span>&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Notice-Before-Use"><a href="#Notice-Before-Use" class="headerlink" title="Notice Before Use!"></a><code>Notice Before Use!</code></h3><p><code>Don&#39;t put APNG resources in your drawable or mipmap directory!</code> During the process of release building of an Android app, the aapt tool will zip &amp; modify the frame info of the APNG file, which will lead to an abnormal behavior when playing it. Thus, please put the APNG resources in <code>raw</code> or <code>assets</code> folder instead.</p>
<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Load from asset file</span><br>AssetStreamLoader assetLoader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AssetStreamLoader(<span class="hljs-params">context</span>, <span class="hljs-string">&quot;wheel.png&quot;</span>)</span>;<br><br><br><span class="hljs-comment">// Load form Resource</span><br>ResourceStreamLoader resourceLoader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ResourceStreamLoader(<span class="hljs-params">context</span>, R.<span class="hljs-params">drawable</span>.<span class="hljs-params">sample</span>)</span>;<br><br><br><span class="hljs-comment">// Load from file</span><br>FileStreamLoader fileLoader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileStreamLoader(<span class="hljs-string">&quot;/sdcard/Pictures/1.webp&quot;</span>)</span>;<br><br><br><span class="hljs-comment">// Create APNG Drawable</span><br>APNGDrawable apngDrawable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">APNGDrawable(<span class="hljs-params">assetLoader</span>)</span>;<br><br><span class="hljs-comment">//Create Animated webp drawable</span><br>WebPDrawable webpDrawable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WebPDrawable(<span class="hljs-params">assetLoader</span>)</span>;<br><br><span class="hljs-comment">// Auto play</span><br>imageView.set<span class="hljs-constructor">ImageDrawable(<span class="hljs-params">apngDrawable</span>)</span>;<br><br><br><span class="hljs-comment">// Not needed.default controlled by content</span><br>apngDrawable.set<span class="hljs-constructor">LoopLimit(10)</span>;<br><br><br><span class="hljs-comment">// Implement Animatable2Compat</span><br>drawable.register<span class="hljs-constructor">AnimationCallback(<span class="hljs-params">new</span> Animatable2Compat.AnimationCallback()</span> &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">AnimationStart(Drawable <span class="hljs-params">drawable</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">AnimationStart(<span class="hljs-params">drawable</span>)</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="Glide-support"><a href="#Glide-support" class="headerlink" title="Glide support"></a>Glide support</h2><h3 id="Add-dependency-in-build-gradle-1"><a href="#Add-dependency-in-build-gradle-1" class="headerlink" title="Add dependency in build.gradle"></a>Add dependency in build.gradle</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">repositories</span> &#123;<br>    ...<br>    mavenCentral()<br>&#125;<br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-string">&#x27;com.github.penfeizhou.android.animation:glide-plugin:$&#123;VERSION&#125;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Direct-use"><a href="#Direct-use" class="headerlink" title="Direct use"></a>Direct use</h3><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Glide</span><span class="hljs-selector-class">.with</span>(imageView)<span class="hljs-selector-class">.load</span>(<span class="hljs-string">&quot;https://misc.aotu.io/ONE-SUNDAY/SteamEngine.png&quot;</span>)<span class="hljs-selector-class">.into</span>(imageView);<br><span class="hljs-selector-tag">Glide</span><span class="hljs-selector-class">.with</span>(imageView)<span class="hljs-selector-class">.load</span>(<span class="hljs-string">&quot;https://isparta.github.io/compare-webp/image/gif_webp/webp/2.webp&quot;</span>)<span class="hljs-selector-class">.into</span>(imageView);<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Activity状态保存和恢复</title>
    <url>/study/Activity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>Android中启动一个Activity如果点击Home键该Activity是不会被销毁的，但是当进行某些操作时某些数据就会丢失，如下：</p>
<p>Java class:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">package com.king.activitytest2;<br><br>import android.support.v7.app.AppCompatActivity;<br>import android.os.Bundle;<br>import android.view.View;<br>import android.widget.Button;<br>import android.widget.EditText;<br>import android.widget.Toast;<br><br>public <span class="hljs-keyword">class</span> MainActivity extends AppCompatActivity implements View.OnClickListener&#123;<br>    <span class="hljs-keyword">private</span> EditText editText;<br>    <span class="hljs-keyword">private</span> Button buttonSet,buttonRead;<br>    <span class="hljs-comment">//定义一个常量</span><br>    double pai;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>        <span class="hljs-comment">//获取控件</span><br>        editText=(EditText)find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">edit1</span>)</span>;<br>        buttonSet=(Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">btn_Set</span>)</span>;<br>        buttonRead=(Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">btn_Read</span>)</span>;<br><br>        <span class="hljs-comment">//设置监听事件</span><br>        buttonSet.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">this</span>)</span>;<br>        buttonRead.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">this</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>        switch (view.get<span class="hljs-constructor">Id()</span>)&#123;<br>            case <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>id.btn_Set:<br>                editText.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;圆周率为：&quot;</span>)</span>;<br>                pai=<span class="hljs-number">3.141592654</span>;<br>                break;<br>            case <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>id.btn_Read:<br>                String str=editText.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+pai;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(MainActivity.<span class="hljs-params">this</span>,<span class="hljs-params">str</span>,Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;<br>                break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>xml布局文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;com.king.activitytest2.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edit1&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;设置&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_Set&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;46dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@+id/edit1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentLeft</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentStart</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;35dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;35dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;读取&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_Read&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignTop</span>=<span class="hljs-string">&quot;@+id/btn_Set&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentRight</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentEnd</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginRight</span>=<span class="hljs-string">&quot;46dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;46dp&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里在程序中定义了一个double类型的变量，当我们点击读取按钮时会将该变量的值加在后面并显示，打开程序然后进行操作，一切正常：</p>
<p><img  src="../../images/865264-20160811221959296-1698831865.jpg"  ><span class="image-caption">img</span></p>
<p>但是我们点击设置之后将屏幕横过来，咦，pai跑哪去了？</p>
<p><img  src="../../images/865264-20160811222132875-757420970.jpg"  ><span class="image-caption">img</span></p>
<p>其实这里当我们进行横竖屏切换时，迫于系统机制，该Activity已经被销毁了。但是为什么这个页面还存在呢，这是因为这个销毁并不是用户去主动退出，所以Android系统实现了这些状态的保存功能，但是一些数据达不到被保留的要求，并没有被保留，就像程序中可怜的pai就被抛弃了！</p>
<p>那我们需要在像这种横竖屏切换过程中保留数据该如何做呢，这里我们就需要重写onSaveInstanceState()方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>   protected void on<span class="hljs-constructor">SaveInstanceState(Bundle <span class="hljs-params">outState</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">SaveInstanceState(<span class="hljs-params">outState</span>)</span>;<br>       <span class="hljs-comment">//将需要保存的数据放入Bundle中</span><br>       outState.put<span class="hljs-constructor">Double(<span class="hljs-string">&quot;pai&quot;</span>,<span class="hljs-params">pai</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>保存解决了，那我们如何取出呢？很简单，只需要在onCreate()方法中判断其参数是否为null，不为null便将其取出。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>    protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>        <span class="hljs-comment">//将pai保存</span><br>        <span class="hljs-keyword">if</span>(savedInstanceState!=null)<br>            pai=savedInstanceState.get<span class="hljs-constructor">Double(<span class="hljs-string">&quot;pai&quot;</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>现在我们可以看到屏幕切换之后pai也没有被销毁。</p>
<p> <img  src="../../images/865264-20160811222238218-211813764.jpg"  ><span class="image-caption">img</span></p>
<p>沉迷学习，日渐消瘦！</p>
<p><img  src="https://images2015.cnblogs.com/blog/865264/201608/865264-20160811222543375-1908230744.jpg"  ><span class="image-caption">img</span></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Andorid 任意界面实现悬浮窗</title>
    <url>/study/Andorid%E4%BB%BB%E6%84%8F%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%82%AC%E6%B5%AE%E7%AA%97/</url>
    <content><![CDATA[<p><a href="https://www.ucloud.cn/yun/14180.html">https://www.ucloud.cn/yun/14180.html</a></p>
<p><a href="https://jitpack.io/p/yhaolpz/FixedFloatWindow">https://jitpack.io/p/yhaolpz/FixedFloatWindow</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android 生成自己的implementation依赖</title>
    <url>/study/Android%20%E7%94%9F%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84implementation%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qianxiangsen/article/details/107683275">https://blog.csdn.net/qianxiangsen/article/details/107683275</a></p>
<p><a href="https://jitpack.io/#SunMengLong/NewbieGuide/v1.0">https://jitpack.io/#SunMengLong/NewbieGuide/v1.0</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android SDK版本名和API level对照表</title>
    <url>/study/AndroidSDK%E7%89%88%E6%9C%AC%E5%90%8D%E5%92%8CAPIlevel%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">SDK版本名</th>
<th align="left">API Level</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Android 11.0 (R)</td>
<td align="left">30</td>
</tr>
<tr>
<td align="left">Android 10.0 (Q)</td>
<td align="left">29</td>
</tr>
<tr>
<td align="left">Android 9.0 (Pie)</td>
<td align="left">28</td>
</tr>
<tr>
<td align="left">Android 8.1 (Oreo)</td>
<td align="left">27</td>
</tr>
<tr>
<td align="left">Android 8.0 (Oreo)</td>
<td align="left">26</td>
</tr>
<tr>
<td align="left">Android 7.1.1 (Nougat)</td>
<td align="left">25</td>
</tr>
<tr>
<td align="left">Android 7.0 (Nougat)</td>
<td align="left">24</td>
</tr>
<tr>
<td align="left">Android 6.0 (Marshmallow)</td>
<td align="left">23</td>
</tr>
<tr>
<td align="left">Android 5.1 (Lollipop)</td>
<td align="left">22</td>
</tr>
<tr>
<td align="left">Android 5.0 (Lollipop)</td>
<td align="left">21</td>
</tr>
<tr>
<td align="left">Android 4.4W (KitKat Wear)</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">Android 4.4 (KitKat)</td>
<td align="left">19</td>
</tr>
<tr>
<td align="left">Android 4.3 (Jelly Bean)</td>
<td align="left">18</td>
</tr>
<tr>
<td align="left">Android 4.2 (Jelly Bean)</td>
<td align="left">17</td>
</tr>
<tr>
<td align="left">Android 4.1 (Jelly Bean)</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Android 4.0.3 (IceCreamSandwich)</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">Android 4.0 (IceCreamSandwich)</td>
<td align="left">14</td>
</tr>
<tr>
<td align="left">Android 3.2 (Honeycomb)</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">Android 3.1 (Honeycomb)</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">Android 3.0 (Honeycomb)</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">Android 2.3.3 (Gingerbread)</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">Android 2.3 (Gingerbread)</td>
<td align="left">9</td>
</tr>
<tr>
<td align="left">Android 2.2 (Froyo)</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">Android 2.1 (Eclair)</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Android 2.0.1 (Eclair)</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Android 2.0 (Eclair)</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Android 1.6 (Dout)</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">Android 1.5 (Cupcake)</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Android 1.1 (Base)</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Android 1.0 (Base)</td>
<td align="left">1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android:导出项目的秘钥</title>
    <url>/study/AndroidStudio%E5%AF%BC%E5%87%BA%E7%A7%98%E9%92%A5/</url>
    <content><![CDATA[<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>在谷歌应用市场上传APP时需要的秘钥</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1.Build<br>2.Generate Signed Bundle / APK<br>2.1 Android App Bundle<br>2.2 然后选择key.jks文件，并填写密码，勾选最底部 Export encrypted key for enrolling published apps in Goolgle Play App singing<br>2.3 点击 next 按钮，再选择 release<br>2.4 点击 Finish<br>这样就在桌面生成了一个“private_key.pepk”文件</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidStudio连接MUMU模拟器</title>
    <url>/study/AndroidStudio%E8%BF%9E%E6%8E%A5MUMU%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
    <content><![CDATA[<h1 id="AndroidStudio连接MUMU模拟器"><a href="#AndroidStudio连接MUMU模拟器" class="headerlink" title="AndroidStudio连接MUMU模拟器"></a>AndroidStudio连接MUMU模拟器</h1><p>想连接模拟器，发现不能连接不上，其他模拟器好像可以，但因为习惯mumu了，于是还是百度查找原因吧……</p>
<p><img  src="../../images/1717472-20190622144152309-769028259.png"  ><span class="image-caption">img</span></p>
<p>输入D:\Program Files\Android\Sdk\platform-tools　　　　（adb所在的路径）</p>
<p><img  src="../../images/1717472-20190622144518618-1816739469.png"  ><span class="image-caption">img</span></p>
<p>再输入：adb connect 127.0.0.1:7555</p>
<p><img  src="../../images/1717472-20190622145329850-286055028.png"  ><span class="image-caption">img</span></p>
<p><img  src="../../images/1717472-20190622145442087-129604883.png"  ><span class="image-caption">img</span></p>
<p>夜神模拟器：adb connect 127.0.0.1:62001</p>
<p>逍遥安卓模拟器：adb connect 127.0.0.1:21503</p>
<p>天天模拟器：adb connect 127.0.0.1:6555 </p>
<p>海马玩模拟器：adb connect 127.0.0.1:53001</p>
<p>网易MUMU模拟器：adb connect 127.0.0.1:7555</p>
<p>原生模拟器：adb connect (你的IP地址)：5555</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android中监听Home键的4种方法总结</title>
    <url>/study/Android%E4%B8%AD%E7%9B%91%E5%90%ACHome%E9%94%AE%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了Android中监听Home键的4种方法总结,主要讲解了onSaveInstanceState方法、onUserLeaveHint方法、ACTION_CLOSE_SYSTEM_DIALOGS、framework PhoneWindowManager.java等4种方法,需要的朋友可以参考下：</p>
<p>因为home键是系统键，情况特殊一些。看了一下网上的资料，说下面的方法可以。（其实不行）</p>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onAttachedToWindow</span>(<span class="hljs-params"></span>)</span> &#123;<br>	<span class="hljs-built_in">this</span>.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD);<br>	<span class="hljs-built_in">super</span>.onAttachedToWindow();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>加了权限之后也不行。<br>复制代码 代码如下:</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">&lt; <span class="hljs-keyword">uses</span>-permission android:<span class="hljs-keyword">name</span>=“android.permission.DISABLE_KEYGUARD” &gt;<br></code></pre></td></tr></table></figure>

<p>ok~ 下面来说下activity里面可行的几种方法：</p>
<p><strong>方法1：onSaveInstanceState方法</strong></p>
<p>下面这个方法可以处理home的监听问题。</p>
<p>复制代码 代码如下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSaveInstanceState</span>(<span class="hljs-params">Bundle outState</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>但这个方法不是很好，不推荐</p>
<p><strong>方法2：onUserLeaveHint方法</strong></p>
<p>复制代码 代码如下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onUserLeaveHint</span>(<span class="hljs-params"></span>)</span> &#123;<br>	Log.d(“aeon”,“onUserLeaveHint”);<br>	<span class="hljs-built_in">super</span>.onUserLeaveHint();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法会在onSaveInstanceState之前执行，根据api的解释，这个方法还比较合适的。</p>
<p><strong>方法3：ACTION_CLOSE_SYSTEM_DIALOGS</strong></p>
<p>在使用广播监听方面可以使用ACTION_CLOSE_SYSTEM_DIALOGS</p>
<p>复制代码 代码如下:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//注册Receiver</span><br>HomeKeyEventBroadCastReceiver receiver = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HomeKeyEventBroadCastReceiver()</span>; <br>register<span class="hljs-constructor">Receiver(<span class="hljs-params">receiver</span>, <span class="hljs-params">new</span> IntentFilter(Intent. ACTION_CLOSE_SYSTEM_DIALOGS)</span>);  <br></code></pre></td></tr></table></figure>

<p><strong>方法4：framework PhoneWindowManager.java 处理</strong></p>
<p>想要完全监听home键需要在framework层去处理。<br>/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java<br>里面去修改private void handleLongPressOnHome() 这个方法。</p>
<p>复制代码 代码如下:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void handle<span class="hljs-constructor">LongPressOnHome()</span> &#123;<br><span class="hljs-comment">// We can’t initialize this in init() since the configuration hasn’t been loaded yet.</span><br>	<span class="hljs-keyword">if</span> (mLongPressOnHomeBehavior &lt; <span class="hljs-number">0</span>) &#123;<br>		mLongPressOnHomeBehavior<br>		= mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">Integer(R.<span class="hljs-params">integer</span>.<span class="hljs-params">config_longPressOnHomeBehavior</span>)</span>;<br>		<span class="hljs-keyword">if</span> (mLongPressOnHomeBehavior &lt; LONG_PRESS_HOME_NOTHING<span class="hljs-operator"> ||</span><br><span class="hljs-operator">				</span>mLongPressOnHomeBehavior &gt; LONG_PRESS_HOME_RECENT_SYSTEM_UI) &#123;<br>					mLongPressOnHomeBehavior = LONG_PRESS_HOME_NOTHING;<br>		&#125;<br>&#125;<br><br>    <span class="hljs-keyword">if</span> (mLongPressOnHomeBehavior != LONG_PRESS_HOME_NOTHING) &#123;  <br>        perform<span class="hljs-constructor">HapticFeedbackLw(<span class="hljs-params">null</span>, HapticFeedbackConstants.LONG_PRESS, <span class="hljs-params">false</span>)</span>; <br>        send<span class="hljs-constructor">CloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS)</span>;  <br><br>        <span class="hljs-comment">// Eat the longpress so it won&#x27;t dismiss the recent apps dialog when </span><br>        <span class="hljs-comment">// the user lets go of the home key  </span><br>        mHomeLongPressed = <span class="hljs-literal">true</span>;  <br>    &#125;  <br><br>    <span class="hljs-keyword">if</span> (mLongPressOnHomeBehavior<span class="hljs-operator"> == </span>LONG_PRESS_HOME_RECENT_DIALOG) &#123;  <br>        show<span class="hljs-constructor">OrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_SHOW_OR_DISMISS)</span>;  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mLongPressOnHomeBehavior<span class="hljs-operator"> == </span>LONG_PRESS_HOME_RECENT_SYSTEM_UI) &#123; <br>        <span class="hljs-keyword">try</span> &#123;  <br>            IStatusBarService statusbar = get<span class="hljs-constructor">StatusBarService()</span>;  <br>            <span class="hljs-keyword">if</span> (statusbar != null) &#123;  <br>                statusbar.toggle<span class="hljs-constructor">RecentApps()</span>;  <br>            &#125;  <br>        &#125; catch (RemoteException e) &#123;  <br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>e(TAG, <span class="hljs-string">&quot;RemoteException when showing recent apps&quot;</span>, e);  <br>            <span class="hljs-comment">// re-acquire status bar service next time it is needed.  </span><br>            mStatusBarService = null;  <br>        &#125;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android实时监听网络状态</title>
    <url>/study/Android%E5%AE%9E%E6%97%B6%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>Android开发实时监听网络状态变化一般有两种方法：</p>
<ol>
<li><p>新建一个基类BasicActivity.class，在基类中注册网络监听广播NetworkChangeReceiver.class，所有页面的Activity都继承此基类BasicActivity.class</p>
<p>(1) 网络状态改变监听类：NetWorkChangeReceiver.class</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">package com.rxandroid.receiver;<br> <br>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.net.ConnectivityManager;<br>import android.net.NetworkInfo;<br>import android.net.wifi.WifiManager;<br>import android.util.Log;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听网络状态变化</span><br><span class="hljs-comment"> * Created by Travis on 2017/10/11.</span><br><span class="hljs-comment"> */</span><br> <br>public <span class="hljs-keyword">class</span> NetWorkChangReceiver extends BroadcastReceiver &#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接类型</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param type</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String get<span class="hljs-constructor">ConnectionType(<span class="hljs-params">int</span> <span class="hljs-params">type</span>)</span> &#123;<br>        String connType = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span><span class="hljs-operator"> == </span>ConnectivityManager.TYPE_MOBILE) &#123;<br>            connType = <span class="hljs-string">&quot;3G网络数据&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span><span class="hljs-operator"> == </span>ConnectivityManager.TYPE_WIFI) &#123;<br>            connType = <span class="hljs-string">&quot;WIFI网络&quot;</span>;<br>        &#125;<br>        return connType;<br>    &#125;<br> <br>    @Override<br>    public void on<span class="hljs-constructor">Receive(Context <span class="hljs-params">context</span>, Intent <span class="hljs-params">intent</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WifiManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">WIFI_STATE_CHANGED_ACTION</span>.</span></span>equals(intent.get<span class="hljs-constructor">Action()</span>)) &#123;<span class="hljs-comment">// 监听wifi的打开与关闭，与wifi的连接无关</span><br>            <span class="hljs-built_in">int</span> wifiState = intent.get<span class="hljs-constructor">IntExtra(WifiManager.EXTRA_WIFI_STATE, 0)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;wifiState:&quot;</span> + wifiState);<br>            switch (wifiState) &#123;<br>                case WifiManager.WIFI_STATE_DISABLED:<br>                    break;<br>                case WifiManager.WIFI_STATE_DISABLING:<br>                    break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 监听网络连接，包括wifi和移动数据的打开和关闭,以及连接上可用的连接都会接到监听</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectivityManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">CONNECTIVITY_ACTION</span>.</span></span>equals(intent.get<span class="hljs-constructor">Action()</span>)) &#123;<br>            <span class="hljs-comment">//获取联网状态的NetworkInfo对象</span><br>            NetworkInfo info = intent.get<span class="hljs-constructor">ParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO)</span>;<br>            <span class="hljs-keyword">if</span> (info != null) &#123;<br>                <span class="hljs-comment">//如果当前的网络连接成功并且网络连接可用</span><br>                <span class="hljs-keyword">if</span> (NetworkInfo.State.CONNECTED<span class="hljs-operator"> == </span>info.get<span class="hljs-constructor">State()</span><span class="hljs-operator"> &amp;&amp; </span>info.is<span class="hljs-constructor">Available()</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (info.get<span class="hljs-constructor">Type()</span><span class="hljs-operator"> == </span>ConnectivityManager.TYPE_WIFI<span class="hljs-operator"> || </span>info.get<span class="hljs-constructor">Type()</span><span class="hljs-operator"> == </span>ConnectivityManager.TYPE_MOBILE) &#123;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;TAG&quot;</span>, get<span class="hljs-constructor">ConnectionType(<span class="hljs-params">info</span>.<span class="hljs-params">getType</span>()</span>) + <span class="hljs-string">&quot;连上&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;TAG&quot;</span>, get<span class="hljs-constructor">ConnectionType(<span class="hljs-params">info</span>.<span class="hljs-params">getType</span>()</span>) + <span class="hljs-string">&quot;断开&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2)基类 BasicActivity</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.rxandroid.activity;<br> <br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">IntentFilter</span>;<br><span class="hljs-keyword">import</span> android.net.<span class="hljs-type">ConnectivityManager</span>;<br><span class="hljs-keyword">import</span> android.net.wifi.<span class="hljs-type">WifiManager</span>;<br><span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;<br><span class="hljs-keyword">import</span> android.support.v7.app.<span class="hljs-type">AppCompatActivity</span>;<br> <br><span class="hljs-keyword">import</span> com.rxandroid.receiver.<span class="hljs-type">NetWorkChangReceiver</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Activity基类:实时获取网络状态</span><br><span class="hljs-comment"> * create by Travis1022 on 2017-10-11</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> boolean isRegistered = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">NetWorkChangReceiver</span> netWorkChangReceiver;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        <span class="hljs-comment">//注册网络状态监听广播</span><br>        netWorkChangReceiver = <span class="hljs-keyword">new</span> <span class="hljs-type">NetWorkChangReceiver</span>();<br>        <span class="hljs-type">IntentFilter</span> filter = <span class="hljs-keyword">new</span> <span class="hljs-type">IntentFilter</span>();<br>        filter.addAction(<span class="hljs-type">WifiManager</span>.<span class="hljs-type">WIFI_STATE_CHANGED_ACTION</span>);<br>        filter.addAction(<span class="hljs-type">WifiManager</span>.<span class="hljs-type">NETWORK_STATE_CHANGED_ACTION</span>);<br>        filter.addAction(<span class="hljs-type">ConnectivityManager</span>.<span class="hljs-type">CONNECTIVITY_ACTION</span>);<br>        registerReceiver(netWorkChangReceiver, filter);<br>        isRegistered = <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onDestroy() &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        <span class="hljs-comment">//解绑</span><br>        <span class="hljs-keyword">if</span> (isRegistered) &#123;<br>            unregisterReceiver(netWorkChangReceiver);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3) 在AndroidManifest.xml中声明广播以及对应的网络权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 网络状态 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span><br> <br> <br>  <span class="hljs-comment">&lt;!--监听网络状态--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.receiver.NetWorkChangReceiver&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.wifi.STATE_CHANGE&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>此时就可以实时监听网络状态了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发keyStore的配置</title>
    <url>/study/Android%E5%BC%80%E5%8F%91keyStore%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="Android开发keyStore的配置"><a href="#Android开发keyStore的配置" class="headerlink" title="Android开发keyStore的配置"></a>Android开发keyStore的配置</h3><ol>
<li>将生成的keystore文件保存在项目更目录下</li>
</ol>
<p><img  src="../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0NTI2NDAzNjQ5,size_16,color_FFFFFF,t_70.png"  ><span class="image-caption">在这里插入图片描述</span></p>
<ol start="2">
<li><p>配置keystore路径和密码</p>
<p>方式一、在build.gradle中直接配置keystore密码</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">signingConfigs</span> &#123;<br>        <span class="hljs-section">config</span> &#123;<br>            <span class="hljs-attribute">keyAlias</span> <span class="hljs-string">&#x27;test123&#x27;</span><br>            keyPassword <span class="hljs-string">&#x27;test123&#x27;</span><br>            storeFile file(<span class="hljs-string">&#x27;../test.jks&#x27;</span>)<br>            storePassword <span class="hljs-string">&#x27;test123&#x27;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>方式二、将路径和密码保存在配置文件中<br>（1）在根目录下创建signing.properties文件</p>
</li>
</ol>
<p><img  src="../../images/20200327160154976.png"  ><span class="image-caption">在这里插入图片描述</span></p>
<p>​        （2）在文件中配置如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">RELEASE_KEY_ALIAS</span> = test123<br><span class="hljs-attr">RELEASE_KEY_PASSWORD</span> = test123<br><span class="hljs-attr">RELEASE_STORE_PASSWORD</span> = test123<br><span class="hljs-attr">RELEASE_STORE_FILE</span> = ../test.jks<br></code></pre></td></tr></table></figure>

<p>​        （3)在build.gradle中配置如下</p>
<p>​                1. 在上方添加</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> keystorePropertiesFile = rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;signing.properties&quot;</span>)<br><span class="hljs-keyword">def</span> keystoreProperties = <span class="hljs-keyword">new</span> Properties()<br>keystoreProperties.load(<span class="hljs-keyword">new</span> FileInputStream(keystorePropertiesFile))<br></code></pre></td></tr></table></figure>



<p>​                2. 在android下添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">signingConfigs &#123;<br>    config &#123;<br>        keyAlias keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;RELEASE_KEY_ALIAS&#x27;</span>]</span><br>        keyPassword keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;RELEASE_KEY_PASSWORD&#x27;</span>]</span><br>        storeFile file(keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;RELEASE_STORE_FILE&#x27;</span>]</span>)<br>        storePassword keystoreProperties<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;RELEASE_STORE_PASSWORD&#x27;</span>]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>完成</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android清除缓存的实现</title>
    <url>/study/Android%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这个功能目前手机上都是由别的软件完成的，很少使用，这个时补充自己的知识所了解的，不说了直接上代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheUtil</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存大小</span><br><span class="hljs-comment">     * @param context</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     * @throws Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getTotalCacheSize</span><span class="hljs-params">(Context context)</span> throws Exception </span>&#123;<br>        <span class="hljs-keyword">long</span> cacheSize = <span class="hljs-built_in">getFolderSize</span>(context.<span class="hljs-built_in">getCacheDir</span>());<br>        <span class="hljs-keyword">if</span> (Environment.<span class="hljs-built_in">getExternalStorageState</span>().<span class="hljs-built_in">equals</span>(Environment.MEDIA_MOUNTED)) &#123;<br>            cacheSize += <span class="hljs-built_in">getFolderSize</span>(context.<span class="hljs-built_in">getExternalCacheDir</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getFormatSize</span>(cacheSize);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 清理所有缓存</span><br><span class="hljs-comment">     * @param context</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearAllCache</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-built_in">deleteDir</span>(context.<span class="hljs-built_in">getCacheDir</span>());<br>        <span class="hljs-keyword">if</span> (Environment.<span class="hljs-built_in">getExternalStorageState</span>().<span class="hljs-built_in">equals</span>(Environment.MEDIA_MOUNTED)) &#123;<br>            <span class="hljs-built_in">deleteDir</span>(context.<span class="hljs-built_in">getExternalCacheDir</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteDir</span><span class="hljs-params">(<span class="hljs-built_in">File</span> dir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dir != null &amp;&amp; dir.<span class="hljs-built_in">isDirectory</span>()) &#123;<br>            <span class="hljs-keyword">String</span>[] children = dir.<span class="hljs-built_in">list</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) &#123;<br>                <span class="hljs-keyword">boolean</span> success = <span class="hljs-built_in">deleteDir</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-built_in">File</span></span>(dir, children[i]));<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dir.<span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件</span><br>    <span class="hljs-comment">//Context.getExternalFilesDir() --&gt; SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据</span><br>    <span class="hljs-comment">//Context.getExternalCacheDir() --&gt; SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFolderSize</span><span class="hljs-params">(<span class="hljs-built_in">File</span> file)</span> throws Exception </span>&#123;<br>        <span class="hljs-keyword">long</span> size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">File</span>[] fileList = file.<span class="hljs-built_in">listFiles</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fileList.length; i++) &#123;<br>                <span class="hljs-comment">// 如果下面还有文件</span><br>                <span class="hljs-keyword">if</span> (fileList[i].<span class="hljs-built_in">isDirectory</span>()) &#123;<br>                    size = size + <span class="hljs-built_in">getFolderSize</span>(fileList[i]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    size = size + fileList[i].<span class="hljs-built_in">length</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (Exception e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 格式化单位</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param size</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getFormatSize</span><span class="hljs-params">(<span class="hljs-keyword">double</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> kiloByte = size / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">if</span> (kiloByte &lt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">//            return size + &quot;Byte&quot;;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0K&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> megaByte = kiloByte / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">if</span> (megaByte &lt; <span class="hljs-number">1</span>) &#123;<br>            BigDecimal result1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDecimal</span>(Double.<span class="hljs-built_in">toString</span>(kiloByte));<br>            <span class="hljs-keyword">return</span> result1.<span class="hljs-built_in">setScale</span>(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP)<br>                    .<span class="hljs-built_in">toPlainString</span>() + <span class="hljs-string">&quot;KB&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> gigaByte = megaByte / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">if</span> (gigaByte &lt; <span class="hljs-number">1</span>) &#123;<br>            BigDecimal result2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDecimal</span>(Double.<span class="hljs-built_in">toString</span>(megaByte));<br>            <span class="hljs-keyword">return</span> result2.<span class="hljs-built_in">setScale</span>(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP)<br>                    .<span class="hljs-built_in">toPlainString</span>() + <span class="hljs-string">&quot;MB&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> teraBytes = gigaByte / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">if</span> (teraBytes &lt; <span class="hljs-number">1</span>) &#123;<br>            BigDecimal result3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDecimal</span>(Double.<span class="hljs-built_in">toString</span>(gigaByte));<br>            <span class="hljs-keyword">return</span> result3.<span class="hljs-built_in">setScale</span>(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP)<br>                    .<span class="hljs-built_in">toPlainString</span>() + <span class="hljs-string">&quot;GB&quot;</span>;<br>        &#125;<br>        BigDecimal result4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDecimal</span>(teraBytes);<br>        <span class="hljs-keyword">return</span> result4.<span class="hljs-built_in">setScale</span>(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).<span class="hljs-built_in">toPlainString</span>()<br>                + <span class="hljs-string">&quot;TB&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android签名文件制作指导</title>
    <url>/study/Android%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%8C%87%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="JDK中keytool-常用命令"><a href="#JDK中keytool-常用命令" class="headerlink" title="JDK中keytool 常用命令:"></a>JDK中keytool 常用命令:</h2><p>-genkey   在用户主目录中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书</p>
<p>(在没有指定生成位置的情况下,keystore会存在用户系统默认目录，如：对于window xp系统，会生成在系统的C:/Documents and Settings/UserName/文件名为“.keystore”)</p>
<p>-alias  产生别名</p>
<p>-keystore  指定密钥库的名称(产生的各类信息将不在.keystore文件中)</p>
<p>-keyalg  指定密钥的算法 (如 RSA DSA（如果不指定默认采用DSA）)</p>
<p>-validity  指定创建的证书有效期多少天</p>
<p>-keysize  指定密钥长度</p>
<p>-storepass  指定密钥库的密码(获取keystore信息所需的密码)</p>
<p>-keypass  指定别名条目的密码(私钥的密码)</p>
<p>-dname  指定密钥库拥有者信息</p>
<p>-list  显示密钥库中的证书信息  -v参数显示详细信息</p>
<p>-export  将别名指定的证书导出到文件 </p>
<p>-file  参数指定导出到文件的文件名</p>
<p>-delete  删除密钥库中某条目</p>
<p>-printcert  查看导出的证书信息</p>
<p>-keypasswd  修改密钥库中指定别名的密码</p>
<p>-storepasswd  修改密钥库的密码</p>
<p>-import  将已签名数字证书导入密钥库</p>
<p>下面是各选项的缺省值。 </p>
<p>-alias “mykey”</p>
<p>-keyalg “DSA”</p>
<p>-keysize 1024</p>
<p>-validity 90</p>
<p>-keystore 用户宿主目录中名为 .keystore 的文件</p>
<p>-file 读时为标准输入，写时为标准输出</p>
<h2 id="1-keystore的生成："><a href="#1-keystore的生成：" class="headerlink" title="1. keystore的生成："></a>1. keystore的生成：</h2><p>分阶段生成：</p>
<p> keytool -genkey-alias xxx(别名) -keypass xxx(别名密码) -keyalg RSA(算法) -keysize 1024(密钥长度) -validity 365(有效期，单位：天) -keystore x:/xxx.keystore(指定生成密钥库的位置和密钥库名称) -storepass 123456(密钥库密码)；回车输入相关信息即可；</p>
<p>一次性生成：</p>
<p> keytool -genkey-alias xxx -keypass xxx -keyalg RSA -keysize 1024 -validity 365 -keystore x:/xxx.keystore -storepass 123456 -dname “CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)”;(中英文即可)</p>
<p><img  src="../../images/20170731110635735.png"  ><span class="image-caption">img</span></p>
<h2 id="2-keystore信息的查看："><a href="#2-keystore信息的查看：" class="headerlink" title="2. keystore信息的查看："></a>2. keystore信息的查看：</h2><p>keytool -list -v-keystore x:/xxx/xxx.keystore -storepass 123456</p>
<p>显示内容：</p>
<p><img  src="../../images/20170731110933930.png"  ><span class="image-caption">img</span></p>
<p>缺省情况下，-list 命令打印证书的 MD5 指纹。而如果指定了 -v 选项，将以可读格式打印证书，如果指定了 -rfc 选项，将以可打印的编码格式输出证书。</p>
<p>keytool -list -rfc-keystore x:/xxx.keystore -storepass 123456</p>
<p>显示内容：</p>
<p> <img  src="../../images/20170731111016098.png"  ><span class="image-caption">img</span></p>
<h2 id="3-证书的导出："><a href="#3-证书的导出：" class="headerlink" title="3. 证书的导出："></a>3. 证书的导出：</h2><p>keytool -export -aliasxxx -keystore x:/xxx.keystore -file x:/xxx.crt(指定导出的证书位置及证书名称) -storepass 123456</p>
<p><img  src="../../images/20170731111045957.png"  ><span class="image-caption">img</span></p>
<h2 id="4-查看导出的证书信息"><a href="#4-查看导出的证书信息" class="headerlink" title="4. 查看导出的证书信息"></a>4. 查看导出的证书信息</h2><p>keytool -printcert-file xxx.crt</p>
<p>在windows下可以双击xxx.crt查看</p>
<h2 id="5-证书的导入："><a href="#5-证书的导入：" class="headerlink" title="5. 证书的导入："></a>5. 证书的导入：</h2><p>现在将xxx.crt 加入到xxx.keystore中：</p>
<p>keytool -import-alias xxx(指定导入证书的别名，如果不指定默认为mykey，别名唯一，否则导入出错) -file x:/xxx.crt -keystore x:/xxx.keystore -storepass 123456</p>
<h2 id="6-别名删除："><a href="#6-别名删除：" class="headerlink" title="6. 别名删除："></a>6. 别名删除：</h2><p> keytool -delete -alias xxx(指定需删除的别名) -keystore xxx.keystore -storepass 123456</p>
<h2 id="7-别名密码的修改："><a href="#7-别名密码的修改：" class="headerlink" title="7. 别名密码的修改："></a>7. 别名密码的修改：</h2><p>keytool -keypasswd -aliasxxx(需要修改密码的别名) -keypass xxx(原始密码) -new 123456(别名的新密码) -keystore x:/xxx.keystore -storepass 123456</p>
<h2 id="8-Keystore密码的修改："><a href="#8-Keystore密码的修改：" class="headerlink" title="8. Keystore密码的修改："></a>8. Keystore密码的修改：</h2><p> keytool-storepasswd -keystore x:/xxx.keystore(需修改密码的keystore) -storepass 123456(原始密码) -new xxx(新密码)</p>
<h2 id="9-修改keystore中别名为xxx的信息"><a href="#9-修改keystore中别名为xxx的信息" class="headerlink" title="9. 修改keystore中别名为xxx的信息"></a>9. 修改keystore中别名为xxx的信息</h2><p>keytool -selfcert -alias xxx-keypass xxx -keystore x:/xxx.keystore -storepass 123456 -dname “cn=xxx,ou=xxx,o=xxx,c=cn”</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>GooglePlay签名机制，GooglePlay签名维护签名更新</title>
    <url>/study/GooglePlay%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/shulianghan/article/details/119025832">https://blog.csdn.net/shulianghan/article/details/119025832</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>ImageView获取Bitmap</title>
    <url>/study/ImageView%E8%8E%B7%E5%8F%96Bitmap/</url>
    <content><![CDATA[<p>直奔主题吧，也不会扯皮，哈哈哈。</p>
<p>首先很多人从ImageView中获取Bitmap首选的方案可能是这样的：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bitmap </span><span class="hljs-keyword">bitmap </span>= ((<span class="hljs-keyword">BitmapDrawable) </span>mImageView.getBackground()).getBitmap();<br></code></pre></td></tr></table></figure>

<p>这样获取那，相信大家都会遇到一个疑惑的问题，就是为什么有时候会获取成功，但是有时候却会报类型转换异常。本人是小菜鸟其实也不知道原因，这里给出解决方案。</p>
<p>解决方案：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">mImageView.set<span class="hljs-constructor">DrawingCacheEnabled(<span class="hljs-params">true</span>)</span>;<br>Bitmap bitmap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bitmap</span>.</span></span>create<span class="hljs-constructor">Bitmap(<span class="hljs-params">mImageView</span>.<span class="hljs-params">getDrawingCache</span>()</span>);<br>mImageView.set<span class="hljs-constructor">DrawingCacheEnabled(<span class="hljs-params">false</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>只需要这三行代码即可轻松搞定。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java中如何将中文转换成拼音字母</title>
    <url>/study/Java%E4%B8%AD%E5%B0%86%E4%B8%AD%E6%96%87%E8%BD%AC%E6%8D%A2%E6%88%90%E6%8B%BC%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p>需要jar包：pinyin4j-5.5.0.jar<br>工具类：ChinesePinYin</p>
<p>百度云网盘地址：<a href="https://pan.baidu.com/s/1lK7SUSSfmQqoz2CNa8ogtg">https://pan.baidu.com/s/1lK7SUSSfmQqoz2CNa8ogtg</a><br>密码：zaj8</p>
<p>工具类：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.PinyinHelper;<br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.<span class="hljs-keyword">format</span>.HanyuPinyinCaseType;<br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.<span class="hljs-keyword">format</span>.HanyuPinyinOutputFormat;<br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.<span class="hljs-keyword">format</span>.HanyuPinyinToneType;<br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.<span class="hljs-keyword">format</span>.HanyuPinyinVCharType;<br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.<span class="hljs-keyword">format</span>.<span class="hljs-keyword">exception</span>.BadHanyuPinyinOutputFormatCombination;<br><br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ChinesePinYin &#123;<br>    <span class="hljs-built_in">public</span> static String getPinYin(String inputString) &#123;<br>        HanyuPinyinOutputFormat <span class="hljs-keyword">format</span> = <span class="hljs-built_in">new</span> HanyuPinyinOutputFormat();<br>        <span class="hljs-keyword">format</span>.setCaseType(HanyuPinyinCaseType.LOWERCASE);<br>        <span class="hljs-keyword">format</span>.setToneType(HanyuPinyinToneType.WITHOUT_TONE);<br>        <span class="hljs-keyword">format</span>.setVCharType(HanyuPinyinVCharType.WITH_V);<br><br>        <span class="hljs-type">char</span>[] input = inputString.trim().toCharArray();<br>        String output = &quot;&quot;;<br>        try &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">input</span>.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">Character</span>.toString(<span class="hljs-keyword">input</span>[i]).matches(&quot;[\\u4E00-\\u9FA5]+&quot;)) &#123;  //判断字符是否是中文<br>                    //toHanyuPinyinStringArray 如果传入的不是汉字，就不能转换成拼音，那么直接返回<span class="hljs-keyword">null</span><br>                    //由于中文有很多是多音字，所以这些字会有多个String，在这里我们默认的选择第一个作为pinyin<br>                    String[] <span class="hljs-keyword">temp</span> = PinyinHelper.toHanyuPinyinStringArray(<span class="hljs-keyword">input</span>[i], <span class="hljs-keyword">format</span>);<br>                    output += <span class="hljs-keyword">temp</span>[<span class="hljs-number">0</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    output += <span class="hljs-type">Character</span>.toString(<span class="hljs-keyword">input</span>[i]);<br>                &#125;<br>            &#125;<br>        &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123;<br>            e.printStackTrace();<br>//    		<span class="hljs-keyword">Log</span>.v(TAG, &quot;BadHanyuPinyinOutputFormatCombination&quot;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取出拼音中第一个字母,一般第一个字母的使用时比较常见的</span><br><span class="hljs-comment">     * @param chines</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">public</span> static String converterToFirstSpell(String chines) &#123;<br>        String pinyinName = &quot;&quot;;<br>        <span class="hljs-type">char</span>[] nameChar = chines.toCharArray();<br>        HanyuPinyinOutputFormat defaulFormat = <span class="hljs-built_in">new</span> HanyuPinyinOutputFormat();<br>        defaulFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);<br>        defaulFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);<br>        defaulFormat.setVCharType(HanyuPinyinVCharType.WITH_V);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nameChar.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nameChar[i] &gt; <span class="hljs-number">128</span>) &#123;<br>                try &#123;<br>                    pinyinName += PinyinHelper.toHanyuPinyinStringArray(nameChar[i], defaulFormat)[<span class="hljs-number">0</span>].charAt(<span class="hljs-number">0</span>);<br>                &#125; catch (BadHanyuPinyinOutputFormatCombination ex) &#123;<br>                    ex.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pinyinName += nameChar[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pinyinName;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>main方法测试：</p>
<pre><code>public static void main(String[] args) &#123;
    String str=ChinesePinYin.getPinYin(&quot;我爱南京&quot;);
    System.out.println(str);
&#125;

woainanjing

Process finished with exit code 0
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android Wireguard源码编译</title>
    <url>/study/Wireguard-Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h4 id="网站参考："><a href="#网站参考：" class="headerlink" title="网站参考："></a>网站参考：</h4><h6 id="Wireguard官网：https-www-wireguard-com"><a href="#Wireguard官网：https-www-wireguard-com" class="headerlink" title="Wireguard官网：https://www.wireguard.com/"></a>Wireguard官网：<a href="https://www.wireguard.com/">https://www.wireguard.com/</a></h6><h6 id="Wireguard各平台源码下载：https-git-zx2c4-com-wireguard"><a href="#Wireguard各平台源码下载：https-git-zx2c4-com-wireguard" class="headerlink" title="Wireguard各平台源码下载：https://git.zx2c4.com/wireguard"></a>Wireguard各平台源码下载：<a href="https://git.zx2c4.com/wireguard">https://git.zx2c4.com/wireguard</a></h6><h6 id="F-Droid平台编译Wireguard安卓源码：https-f-droid-org-zh-Hans-packages-com-wireguard-android"><a href="#F-Droid平台编译Wireguard安卓源码：https-f-droid-org-zh-Hans-packages-com-wireguard-android" class="headerlink" title="F-Droid平台编译Wireguard安卓源码：https://f-droid.org/zh_Hans/packages/com.wireguard.android/"></a>F-Droid平台编译Wireguard安卓源码：<a href="https://f-droid.org/zh_Hans/packages/com.wireguard.android/">https://f-droid.org/zh_Hans/packages/com.wireguard.android/</a></h6><h6 id="F-Droid平台技术在线交流："><a href="#F-Droid平台技术在线交流：" class="headerlink" title="F-Droid平台技术在线交流："></a>F-Droid平台技术在线交流：</h6><p><a href="https://matrix.f-droid.org/room/!ZmSZzxujGNoCyoCETU:matrix.org/?anchor=$158859813316519lIkhf:matrix.org&amp;offset=720">https://matrix.f-droid.org/room/!ZmSZzxujGNoCyoCETU:matrix.org/?anchor=$158859813316519lIkhf:matrix.org&amp;offset=720</a></p>
<h4 id="编译工具版本："><a href="#编译工具版本：" class="headerlink" title="编译工具版本："></a>编译工具版本：</h4><h6 id="Android-Studio-："><a href="#Android-Studio-：" class="headerlink" title="Android Studio ："></a>Android Studio ：</h6><p>Android Studio Arctic Fox | 2020.3.1 Patch 3<br>Build #AI-203.7717.56.2031.7784292, built on October 1, 2021</p>
<h6 id="NDK：-21-2-6472646"><a href="#NDK：-21-2-6472646" class="headerlink" title="NDK： 21.2.6472646"></a>NDK： 21.2.6472646</h6><h6 id="Cmake：3-10-2-49888404"><a href="#Cmake：3-10-2-49888404" class="headerlink" title="Cmake：3.10.2.49888404"></a>Cmake：3.10.2.49888404</h6><h6 id="JDK：1-8-0-181"><a href="#JDK：1-8-0-181" class="headerlink" title="JDK：1.8.0_181"></a>JDK：1.8.0_181</h6><h6 id="另外需安装：c编译器mingw，百度网盘下载地址："><a href="#另外需安装：c编译器mingw，百度网盘下载地址：" class="headerlink" title="另外需安装：c编译器mingw，百度网盘下载地址："></a>另外需安装：c编译器mingw，百度网盘下载地址：</h6><p>链接：<a href="https://pan.baidu.com/s/14c48KLTafoEsrEhs4eIyQQ">https://pan.baidu.com/s/14c48KLTafoEsrEhs4eIyQQ</a><br>提取码：732y</p>
<p>安装相关插件，如图：</p>
<p><img src="../../images/study/mingw.jpg"></p>
<p>编译成功的安卓源代码：</p>
<p>链接：<a href="https://pan.baidu.com/s/11fi_rN--8e07cZvhymFQjg">https://pan.baidu.com/s/11fi_rN--8e07cZvhymFQjg</a><br>提取码：6iuy</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>android strings.xml转义字符, 注意细节解决</title>
    <url>/study/android-strings.xml%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong>XML转义字符<br>以下为XML标志符的数字和字符串转义符<br>“   (“ 或 “)<br>‘   (‘ 或 ‘)<br>&amp;   (&amp; 或 &amp;)<br>lt(&lt;) (&lt; 或 &lt;)<br>gt(&gt;) (&gt; 或 &gt;)</strong> </p>
<p><strong>如题：<br>比如：在string.xml中定义如下一个字符串，<br><string name="first">大家好，欢迎来到eoeandroid社区。welcome to here！</string><br>我想以<br>大家好，欢迎来到eoeandroid社区。<br>welcome to here！<br>两行的形式输出,如何做？加\n，看下面：</strong><br><strong><string name="hello">大家好，欢迎来到eoeandroid社区。\nwelcome to here！</string></strong> </p>
<p>**<br>android中的空格编码 string.xml前后加空格的技巧<br><string name="space">  我来看空格</string><br> 这个就代表着空格** </p>
<p><strong>1. 遇到如下错误的时候说明你需要在单引号签名加转义字符():<br>Description Resource Path Location Type error: Apostrophe not preceded by \ (in Search’ Titles) strings.xml<br>只要将定义的字符串中的单引号(‘), 修改为(&#39;)即可</strong> </p>
<p>**2. 变量文本格式(%s)提示：<br>Multiple annotations found at this line:<br>- error: Multiple substitutions specified in non-positional format; did you mean to add the formatted=”false”<br>attribute?<br>- error: Unexpected end tag string<br>这是由于新的SDK(虽然从没用过老的)采用了新版本的aapt(Android项目编译器), 这个版本的aapt编译起来会比老版本更加的严格, 在Android最新的开发文档中描述String的部分，已经说明了如何去设置 %s 等符号, 可以点击去看.<br>简单解决方法就是:把%s之类的变量格式替换成%1$s, %1表示第一个位置的变量, $s表示为字符串类型<br>例如: </p>
<p><string name="welcome_messages">Your First Var is %1$s! You Second Var is %2$d.</string>** </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>仿微信@好友功能 輸入@跳转、删除整块</title>
    <url>/study/%E4%BB%BF%E5%BE%AE%E4%BF%A1@%E5%A5%BD%E5%8F%8B%E5%8A%9F%E8%83%BD%20%E8%BC%B8%E5%85%A5@%E8%B7%B3%E8%BD%AC%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B4%E5%9D%97/</url>
    <content><![CDATA[<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">最近在做聊天功能的时候，有一个需求是仿照微信做<span class="hljs-meta">@好友的功能，本来以为挺简单，但是做到这块的时候，发现和想象的有点不一样，什么整块删除，块可编辑，总之，加个</span><span class="hljs-meta">@的功能很简单，但是要做和微信的一样还是费了一些功夫，下面是一个demo仅供参考，防止遗忘</span><br></code></pre></td></tr></table></figure>

<h4 id="先上个效果图"><a href="#先上个效果图" class="headerlink" title="先上个效果图"></a>先上个效果图</h4><p><img  src="../../images/SouthEast.gif"  ><span class="image-caption">这里写图片描述</span></p>
<p>就是这么个功能</p>
<p>我又照着做了这个，仅供参考</p>
<p><img  src="../../images/SouthEast.gif"  ><span class="image-caption">这里写图片描述</span></p>
<ol>
<li>分析需求<br>输入@跳转到联系人界面，选中一个或者多个好友返回到当前界面<br>按退格键删除整块内容<br>块内的内容可编辑，编辑完了之后将不附带@功能，只是单纯的文字</li>
<li>开始编码<br>既然是文本输入首先继承EditText自定义一个控件</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatEditText</span> </span>&#123;<br>    public <span class="hljs-type">MsgEditText</span>(<span class="hljs-type">Context</span> context) &#123;<br>        <span class="hljs-keyword">super</span>(context);<br>    &#125;<br>    <br>    public <span class="hljs-type">MsgEditText</span>(<span class="hljs-type">Context</span> context, <span class="hljs-type">AttributeSet</span> attrs) &#123;<br>        <span class="hljs-keyword">super</span>(context, attrs);<br>    &#125;<br>    <br>    public <span class="hljs-type">MsgEditText</span>(<span class="hljs-type">Context</span> context, <span class="hljs-type">AttributeSet</span> attrs, int defStyleAttr) &#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到底从哪里开始入手呢，首先完成变成块的需求，<br>无意中看到这个项目<a href="https://github.com/g707175425/CloudEditText">https://github.com/g707175425/CloudEditText</a> ，他是这么写的</p>
<p> private void generateOneSpan(Spannable spannableString, UnSpanText unSpanText) {<br>        //生成一个TextView<br>        View spanView = getSpanView(getContext(),      unSpanText.showText.toString(), getMeasuredWidth());<br>        //再将TextView转换为一个图片<br>        BitmapDrawable bitmpaDrawable = (BitmapDrawable) UIUtils.convertViewToDrawable(spanView);<br>        bitmpaDrawable.setBounds(0, 0, bitmpaDrawable.getIntrinsicWidth(), bitmpaDrawable.getIntrinsicHeight());<br>        //最后将这个图片放到Span里，<br>        MyImageSpan what = new MyImageSpan(bitmpaDrawable, unSpanText.showText.toString(),unSpanText.returnText);<br>        final int start = unSpanText.start;<br>        final int end = unSpanText.end;<br>        spannableString.setSpan(what, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);<br>        //设置一个Span<br>        spannableString.setSpan(touchableSpan, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);<br>    }</p>
<p>看到这里我们就记得了一个关于SpanableString的用法，它可以设置图片，可以随意的设置文字的背景的前景，等等一系列比较酷炫的效果，而且只需要一个TextView，如果需要深入了解Span，可自行百度和Google，我看的是这篇博客<a href="http://blog.csdn.net/u012422440/article/details/52155924%EF%BC%8C%E5%85%B3%E4%BA%8ESpan%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%B0%B1%E6%9C%89%E4%BA%86%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0">http://blog.csdn.net/u012422440/article/details/52155924，关于Span的进阶用法，于是就有了下面的实现</a></p>
<pre><code>//这个是需要成块删除的内容
private class MyTextSpan extends MetricAffectingSpan &#123;
    private String showText;
    private long userId;

    //userId是为了适应需求，如果不需要请自行去掉
    public MyTextSpan(String showText, long userId) &#123;
        this.showText = showText;
        this.userId = userId;
    &#125;


    public String getShowText() &#123;
        return showText;
    &#125;

    public long getUserId() &#123;
        return userId;
    &#125;

    @Override
    public void updateMeasureState(TextPaint p) &#123;

    &#125;

    @Override
    public void updateDrawState(TextPaint tp) &#123;

    &#125;
&#125;

//这个是非整块删除的内容，当然你如果想也是可以删除的
private class UnSpanText &#123;
    int start;
    int end;
    String returnText;

    UnSpanText(int start, int end, String returnText) &#123;
        this.start = start;
        this.end = end;
        this.returnText = returnText;
    &#125;
&#125;
</code></pre>
<p>刚开始我是这么写的</p>
<pre><code>//外部调用一个增加Span的方法
public void addSpan(String showText, String returnText, long userId) &#123;
    getText().append(showText);
    SpannableString spannableString = new SpannableString(getText());
    makeSpan(spannableString, new UnSpanText(spannableString.length() - showText.length(), spannableString.length(), showText, returnText), userId);
    setText(spannableString);
    setSelection(spannableString.length());
&#125;


//生成一个需要整体删除的Span
private void makeSpan(Spannable sps, UnSpanText unSpanText, long userId) &#123;
    MyTextSpan what = new MyTextSpan(unSpanText.returnText, userId);
    int start = unSpanText.start;
    int end = unSpanText.end;
    sps.setSpan(what, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
&#125;
</code></pre>
<p>写到现在这个整块添加已经做好了，下面开始做整块删除，刚开始的时候我是模仿上面的CloudEditText写的，但我发现好像会用各种问题，于是想了一种方法</p>
<pre><code>@Override
protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123;
    super.onTextChanged(text, start, lengthBefore, lengthAfter);
    //向前删除一个字符，@后的内容必须大于一个字符，可以在后面加一个空格
    if (lengthBefore == 1 &amp;&amp; lengthAfter == 0) &#123;
        MyTextSpan[] spans = getText().getSpans(0, getText().length(), MyTextSpan.class);
        for (MyTextSpan myImageSpan : spans) &#123;
            if (getText().getSpanEnd(myImageSpan) == start &amp;&amp; !text.toString().endsWith(myImageSpan.getShowText())) &#123;
                getText().delete(getText().getSpanStart(myImageSpan), getText().getSpanEnd(myImageSpan));
                break;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<p>上面的意思就是，如果你在EditText中执行删除一个字符的时候，判断前面一个是否是一个Span，如果是自定义的Span就把Span一同删除，关于这个，我可是测试可各种操作才定为这样的</p>
<p>最后是获取需要@的人员名单</p>
<pre><code>//获取用户Id列表,这只是个参考，可根据需求修改
public String getUserIdString() &#123;
    MyTextSpan[] spans = getText().getSpans(0, getText().length(), MyTextSpan.class);
    StringBuilder builder = new StringBuilder();
    for (MyTextSpan myTextSpan : spans) &#123;
        String realText = getText().toString().substring(getText().getSpanStart(myTextSpan), getText().getSpanEnd(myTextSpan));
        String showText = myTextSpan.getShowText();
        if (realText.equals(showText)) &#123;
            builder.append(myTextSpan.getUserId()).append(&quot;,&quot;);
        &#125;
    &#125;
    if (!TextUtils.isEmpty(builder.toString())) &#123;
        builder.deleteCharAt(builder.length() - 1);
    &#125;
    return builder.toString();
&#125;
</code></pre>
<p>最后我就大方的放个地址你们自己看吧<br><a href="https://github.com/ddssingsong/AtFriend">https://github.com/ddssingsong/AtFriend</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>判断Activity是否在前台</title>
    <url>/study/%E5%88%A4%E6%96%ADActivity%E6%98%AF%E5%90%A6%E5%9C%A8%E5%89%8D%E5%8F%B0/</url>
    <content><![CDATA[<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityUtils</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断某个界面是否在前台</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>activity 要判断的Activity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return </span>是否在前台显示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isForeground</span>(<span class="hljs-params">Activity activity</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> isForeground(activity, activity.getClass().getName());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断某个界面是否在前台</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>context   Context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>className 界面的类名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return </span>是否在前台显示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isForeground</span>(<span class="hljs-params">Context context, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span> || TextUtils.isEmpty(className))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);<br>        List&lt;ActivityManager.RunningTaskInfo&gt; list = am.getRunningTasks(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            ComponentName cpn = list.get(<span class="hljs-number">0</span>).topActivity;<br>            <span class="hljs-keyword">if</span> (className.equals(cpn.getClassName()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用的时候： </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ActivityUtils</span>.</span></span>is<span class="hljs-constructor">Foreground(<span class="hljs-params">getContext</span>()</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatingActivity</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Name()</span>))&#123;&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>呼吸动画</title>
    <url>/study/%E5%91%BC%E5%90%B8%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p><img  src="../../images/5f4b4f5eb3ef6b2e5d4a.jpgtplv-t2oaga2asx-zoom-crop-mark130413041304734.awebp"  ><span class="image-caption"> 更加自然的渐变——呼吸动画</span></p>
<h1 id="更加自然的渐变——呼吸动画"><a href="#更加自然的渐变——呼吸动画" class="headerlink" title="更加自然的渐变——呼吸动画"></a>更加自然的渐变——呼吸动画</h1><p>本篇主要介绍通过定义属性动画来拟合呼吸函数的变化曲线，以实现更加自然的渐隐和渐显效果，当然也可以作用于其他属性的自然过渡。</p>
<p>这个函数是在这篇介绍交互的文章中发现的（<a href="https://link.juejin.cn/?target=https://isux.tencent.com/animation-factor.html%23comment-form">让界面动画更自然</a>）。</p>
<p><img  src="../../images/7740a88f87eb00242017f2120afb0b71tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p><img  src="../../images/cd62352159216573ed38d5fe44063181tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p><img  src="../../images/e2626703ec4f5f52995530ae102ca63btplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p>k=1/3，t=6, n={1,2,3,…}</p>
<p>(函数，及以上图片出自上文提到的链接)</p>
<p>此函数周期为6，貌似n是控制周期的，是不是呢，试一下。</p>
<p>这里令n=1进行MATLAB绘制函数图像，语句如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>=<span class="hljs-number">0</span>:<span class="hljs-number">0</span>.<span class="hljs-number">0000001</span>:<span class="hljs-number">6</span>;  <br><span class="hljs-attribute">k</span>=<span class="hljs-number">1</span>/<span class="hljs-number">3</span>;<br><span class="hljs-attribute">t</span>=<span class="hljs-number">6</span>;<br><span class="hljs-attribute">n</span>=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">y</span>=(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>*sin((pi/(k*t)).*((x-k*t/<span class="hljs-number">2</span>)-(n-<span class="hljs-number">1</span>)*t))+<span class="hljs-number">0</span>.<span class="hljs-number">5</span>).*(x&gt;=(n-<span class="hljs-number">1</span>)*t&amp;x&lt;(n-(<span class="hljs-number">1</span>-k))*t)+((<span class="hljs-number">0</span>.<span class="hljs-number">5</span>*sin((pi/((<span class="hljs-number">1</span>-k)*t)).*((x-(<span class="hljs-number">3</span>-k)*t/<span class="hljs-number">2</span>)-(n-<span class="hljs-number">1</span>)*t))+<span class="hljs-number">0</span>.<span class="hljs-number">5</span>).^<span class="hljs-number">2</span>).*(x&gt;=(n-(<span class="hljs-number">1</span>-k))*t&amp;x&lt;n*t);<br><span class="hljs-attribute">grid</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">axis</span> equal<br><span class="hljs-attribute">axis</span>([<span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure>


<p>得到图像如下：</p>
<p><img  src="../../images/9a5fb7af87b4f47b5cbf66848a4ef564tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p>由图像可见n=1时，即为函数第一个周期，由于这里要定义属性动画插值器，只需取函数的一个周期即可，所以就令n=1;定义插值器实现此函数如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> com.jaren.breatheanimationdemo;<br><br><span class="hljs-keyword">import</span> android.animation.TimeInterpolator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义拟合呼吸变化的插值器</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> BraetheInterpolator <span class="hljs-keyword">implements</span> TimeInterpolator &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> getInterpolation(<span class="hljs-keyword">float</span> input) &#123;<br><br>        <span class="hljs-keyword">float</span> x = <span class="hljs-number">6</span> * input;<br>        <span class="hljs-keyword">float</span> k = <span class="hljs-number">1.0</span>f / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-comment">//控制函数周期，这里取此函数的第一个周期</span><br>        <span class="hljs-keyword">float</span> PI = <span class="hljs-number">3.1416</span>f;<br>        <span class="hljs-keyword">float</span> output = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (x &gt;= ((n - <span class="hljs-number">1</span>) * t) &amp;&amp; x &lt; ((n - (<span class="hljs-number">1</span> - k)) * t)) &#123;<br>            output = (<span class="hljs-keyword">float</span>) (<span class="hljs-number">0.5</span> * Math.sin((PI <span class="hljs-regexp">/ (k * t)) * ((x - k * t /</span> <span class="hljs-number">2</span>) - (n - <span class="hljs-number">1</span>) * t)) + <span class="hljs-number">0.5</span>);<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt;= (n - (<span class="hljs-number">1</span> - k)) * t &amp;&amp; x &lt; n * t) &#123;<br>            output = (<span class="hljs-keyword">float</span>) Math.pow((<span class="hljs-number">0.5</span> * Math.sin((PI <span class="hljs-regexp">/ ((1 - k) * t)) * ((x - (3 - k) * t /</span> <span class="hljs-number">2</span>) - (n - <span class="hljs-number">1</span>) * t)) + <span class="hljs-number">0.5</span>), <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对插值器不太熟悉可以看一下<a href="https://link.juejin.cn/?target=http://blog.csdn.net/l_wwbs/article/details/53322609">这里</a>。定义好插值器我们就可以按照属性动画的操作方式来实现我们需要的效果了。</p>
<p>首先看一下这个改变透明度实现渐隐、渐现的效果。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 开启透明度渐变呼吸动画</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">AlphaBreathAnimation()</span> &#123;<br>      ObjectAnimator alphaAnimator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">tvShowBreathing</span>, <span class="hljs-string">&quot;alpha&quot;</span>, 0f, 1f)</span>;<br>      alphaAnimator.set<span class="hljs-constructor">Duration(4000)</span>;<br>      alphaAnimator.set<span class="hljs-constructor">Interpolator(<span class="hljs-params">new</span> BraetheInterpolator()</span>);<span class="hljs-comment">//使用自定义的插值器</span><br>      alphaAnimator.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;<br>      alphaAnimator.start<span class="hljs-literal">()</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>


<p> 效果：</p>
<p><img  src="../../images/48dc44f45a3460ac38b0372890c728a8tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p>用于缩放改变大小：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 开启缩放渐变呼吸动画</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">ScaleBreathAnimation()</span> &#123;<br>       ObjectAnimator scaleX = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">tvShowBreathing</span>, <span class="hljs-string">&quot;scaleX&quot;</span>, 0.4f, 1f)</span>;<br>       ObjectAnimator scaleY = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">tvShowBreathing</span>, <span class="hljs-string">&quot;scaleY&quot;</span>, 0.4f, 1f)</span>;<br>       scaleX.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;<br>       scaleY.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;<br>       AnimatorSet animatorSet=<span class="hljs-keyword">new</span> <span class="hljs-constructor">AnimatorSet()</span>;<br>       animatorSet.play<span class="hljs-constructor">Together(<span class="hljs-params">scaleX</span>,<span class="hljs-params">scaleY</span>)</span>;<br>       animatorSet.set<span class="hljs-constructor">Duration(4000 )</span>;<br>       animatorSet.set<span class="hljs-constructor">Interpolator(<span class="hljs-params">new</span> BraetheInterpolator()</span>);<br>       animatorSet.start<span class="hljs-literal">()</span>;<br><br>   &#125;复制代码<br></code></pre></td></tr></table></figure>


<p> 效果：</p>
<p><img  src="../../images/dc30b4a46993b9c96f3034054d7b4832tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">img</span></p>
<p>这里简单展示了一下两种使用效果，还有更多的场景适合使用，也可以给动画设置监听，用于自定义View等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">animator.addUpdateListener(<span class="hljs-keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span>(<span class="hljs-params">ValueAnimator animation</span>)</span> &#123;<br>             animation.getAnimatedValue();<br>             <span class="hljs-comment">//...</span><br>         &#125;<br>     &#125;);复制代码<br></code></pre></td></tr></table></figure>





<p><em>如有缪误，欢迎指正！</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>弹窗风格的 Activity</title>
    <url>/study/%E5%BC%B9%E7%AA%97%E9%A3%8E%E6%A0%BC%E7%9A%84Activity/</url>
    <content><![CDATA[<p>转发：</p>
<p><a href="https://blog.csdn.net/AlpinistWang/article/details/86773063?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://blog.csdn.net/AlpinistWang/article/details/86773063?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android App优化之性能分析工具</title>
    <url>/study/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/da2a4bfcba68">https://www.jianshu.com/p/da2a4bfcba68</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>截屏监听</title>
    <url>/study/%E6%88%AA%E5%B1%8F/</url>
    <content><![CDATA[<p><a href="https://www.pianshen.com/article/99181250364/">https://www.pianshen.com/article/99181250364/</a></p>
<p><a href="https://blog.csdn.net/sollian/article/details/51463851?utm_term=android%E6%88%AA%E5%B1%8F%E7%9A%84%E7%9B%91%E5%90%AC&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-51463851&amp;spm=3001.4430">https://blog.csdn.net/sollian/article/details/51463851?utm_term=android%E6%88%AA%E5%B1%8F%E7%9A%84%E7%9B%91%E5%90%AC&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-51463851&amp;spm=3001.4430</a></p>
<p><a href="https://blog.csdn.net/qq_41785058/article/details/102592237?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_41785058/article/details/102592237?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
<p><a href="https://www.jianshu.com/p/a7fab8faa73c">https://www.jianshu.com/p/a7fab8faa73c</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>查看文件MD5值</title>
    <url>/study/%E6%9F%A5%E7%9C%8BMD5%E5%80%BC/</url>
    <content><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>打开命令窗口(Win+R)，然后输入cmd</p>
<p><img  src="../../images/1267983-20200329212402431-595131712.png"  ><span class="image-caption">img</span></p>
<p>·输入命令certutil -hashfile 文件绝对路径 MD5</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>MD5算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。</p>
<p>md5sum命令采用MD5报文摘要算法（128位）计算和检查文件的校验和。一般来说，安装了Linux后，就会有md5sum这个工具，直接在命令行终端直接运行。</p>
<p><strong>语法</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># md5</span>sum<span class="hljs-comment">(选项)</span><span class="hljs-comment">(参数)</span><br></code></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">-b或<span class="hljs-comment">--binary:  把输入文件作为二进制文件看待。</span><br>-t或<span class="hljs-comment">--text:    把输入的文件作为文本文件看待（默认）。</span><br>-c或<span class="hljs-comment">--check:   用来从文件中读取md5信息检查文件的一致性。(不细说了参见info)</span><br><span class="hljs-comment">--status:      这个选项和check一起使用,在check的时候，不输出，而是根据返回值表示检查结果。</span><br>-w或<span class="hljs-comment">--warn:    在check的时候，检查输入的md5信息又没有非法的行，如果有则输出相应信息。</span><br></code></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">文件：指定保存着文件名和校验和的文本文件<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong><br><strong>1) 查看一个字符串的md5值</strong><br>在线查看字符串的md5值地址: <a href="https://md5jiami.51240.com/">https://md5jiami.51240.com/</a><br>linux终端里查看出来的md5值都是”32位小写”格式的值</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# echo</span> -n <span class="hljs-string">&quot;hello world&quot;</span>|md5sum<br><span class="hljs-number">5</span>eb63bbbe01eeed093cb22bb8f5acdc3  -<br> <br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# echo</span> -n <span class="hljs-string">&quot;hello world&quot;</span>|md5sum |cut -d<span class="hljs-string">&quot; &quot;</span> -f1<br><span class="hljs-number">5</span>eb63bbbe01eeed093cb22bb8f5acdc3<br></code></pre></td></tr></table></figure>

<p>命令解释：<br>md5sum: 显示或检查 MD5(128-bit) 校验和,若没有文件选项，或者文件处为”-“，则从标准输入读取。<br>echo <strong>-n</strong> : 不打印换行符。(注意: echo -n 后面的-n参数必须加上, 这样算出的字符串的md5值才正确)<br>cut: cut用来从标准输入或文本文件中剪切列或域。剪切文本可以将之粘贴到一个文本文件。 -d 指定与空格和tab键不同的域分隔符。-f1 表示第一个域。</p>
<p><strong>2) 查看一个文件的md5值</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# echo</span> <span class="hljs-string">&quot;test md5&quot;</span> &gt; kevin.sql<br> <br>查看并获取这个文件的md5值<br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# md5sum</span> kevin.sql<br><span class="hljs-number">170</span>ecb8475ca6e384dbd74c17e165c9e  kevin.sql<br> <br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# md5sum</span> kevin.sql|cut -d<span class="hljs-string">&quot; &quot;</span> -f1<br><span class="hljs-number">170</span>ecb8475ca6e384dbd74c17e165c9e<br> <br>生产这个个文件的md5值<br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# md5sum</span> kevin.sql &gt; kevin.sql.md5<br> <br>检查两个文件是否一样，可以通过比较两个文件的md5值 (后续可以用这个方法来检验kevin.sql文件是否被修改)。<br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# md5sum</span> kevin.sql<br><span class="hljs-number">170</span>ecb8475ca6e384dbd74c17e165c9e  kevin.sql<br> <br>[root@web-<span class="hljs-keyword">master</span> <span class="hljs-title">~]# cat</span> kevin.sql.md5<br><span class="hljs-number">170</span>ecb8475ca6e384dbd74c17e165c9e  kevin.sql<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android防止连续点击打开两个重复页面的小技巧</title>
    <url>/study/%E9%98%B2%E6%AD%A2%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB/</url>
    <content><![CDATA[<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">我们在开发<span class="hljs-keyword">APP</span>的过程中经常会遇到在某些低端机或者在机器响应比较慢的情况下手抖连续点击某个页面（当然不排除有些人故意这么做）重复弹出好几个相同的页面，不过我发现微信这样的应用都没有做处理……但还是要分享一下我是怎么解决的。<br></code></pre></td></tr></table></figure>

<h4 id="1、通过判断两次点击的时间间隔来防止重复点击"><a href="#1、通过判断两次点击的时间间隔来防止重复点击" class="headerlink" title="1、通过判断两次点击的时间间隔来防止重复点击"></a>1、通过判断两次点击的时间间隔来防止重复点击</h4><p>工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by mafei on 15/12/8.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoDoubleClickUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> lastClickTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SPACE_TIME = <span class="hljs-number">500</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLastClickTime</span><span class="hljs-params">()</span> </span>&#123;<br>        lastClickTime = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDoubleClick</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">boolean</span> isClick2;<br>        <span class="hljs-keyword">if</span> (currentTime - lastClickTime &gt;<br>                SPACE_TIME) &#123;<br>            isClick2 = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isClick2 = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        lastClickTime = currentTime;<br>        <span class="hljs-keyword">return</span> isClick2;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点击事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> View.OnClickListener logListener = <span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">View view</span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!NoDoubleClickUtils.isDoubleClick()) &#123;<br>                事件响应方法<br>            &#125;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2、通过修改manifest中页面的launchMode属性改为单例模式"><a href="#2、通过修改manifest中页面的launchMode属性改为单例模式" class="headerlink" title="2、通过修改manifest中页面的launchMode属性改为单例模式"></a>2、通过修改manifest中页面的launchMode属性改为单例模式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 市场网贷产品页 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.activity.market.CreditRecordActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleTask&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;portrait&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="3、利用RxBinding实现防重复点击"><a href="#3、利用RxBinding实现防重复点击" class="headerlink" title="3、利用RxBinding实现防重复点击"></a>3、利用RxBinding实现防重复点击</h4><p>RxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">RxView<span class="hljs-selector-class">.clickEvents</span>(<span class="hljs-selector-tag">button</span>)<br>    <span class="hljs-selector-class">.throttleFirst</span>(<span class="hljs-number">500</span>, TimeUnit<span class="hljs-selector-class">.MILLISECONDS</span>)<br>    <span class="hljs-selector-class">.subscribe</span>(clickAction);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Monkey 命令行工具</title>
    <url>/test/Monkey%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://wiki.jikexueyuan.com/project/android-test-course/monkey-commond-tools.html">https://wiki.jikexueyuan.com/project/android-test-course/monkey-commond-tools.html</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>bilibili测试学习视频</title>
    <url>/test/bilibili%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><a href="https://space.bilibili.com/448016348?spm_id_from=333.788.b_765f7570696e666f.1">https://space.bilibili.com/448016348?spm_id_from=333.788.b_765f7570696e666f.1</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>弱网测试工具QNET</title>
    <url>/tool/Android%20%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7QNET/</url>
    <content><![CDATA[<h3 id="工具下载地址："><a href="#工具下载地址：" class="headerlink" title="工具下载地址："></a>工具下载地址：</h3><p>链接: <a href="https://pan.baidu.com/s/1kU2rHDZNj4Eiqyy-R318hw">https://pan.baidu.com/s/1kU2rHDZNj4Eiqyy-R318hw</a>  密码: tckh</p>
<p>使用图解：</p>
<p><img  src="https://img-blog.csdnimg.cn/20210226183736683.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdsb25nMDMyOQ==,size_16,color_FFFFFF,t_70"  ><span class="image-caption">img</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidStudio如何轻松整理字符串到string.xml中</title>
    <url>/tool/AndroidStudio%E8%BD%BB%E6%9D%BE%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0strings/</url>
    <content><![CDATA[<h3 id="1、在布局文件中写的字符串，整理到string-xml中"><a href="#1、在布局文件中写的字符串，整理到string-xml中" class="headerlink" title="1、在布局文件中写的字符串，整理到string.xml中"></a>1、在布局文件中写的字符串，整理到string.xml中</h3><p>选中字符串后，同时按住Alt+Enter，即可看到弹出选择的对话款，选择其中的“Extract string resource”,如下图所示： </p>
<p><img  src="../../images/20160822213555450.png"  ><span class="image-caption">这里写图片描述</span></p>
<p>选择其中的“Extract string resource”，出现如下图所示的对话框 </p>
<p><img  src="../../images/20160822213623876.png"  ><span class="image-caption">这里写图片描述</span></p>
<p>然后可以修改该字符串在string.xml中的key值，如下图所示： </p>
<p><img  src="../../images/20160822213725736.png"  ><span class="image-caption">这里写图片描述</span></p>
<h3 id="2、在Java文件中写的字符串，整理到string-xml中"><a href="#2、在Java文件中写的字符串，整理到string-xml中" class="headerlink" title="2、在Java文件中写的字符串，整理到string.xml中"></a>2、在Java文件中写的字符串，整理到string.xml中</h3><p>和在布局文件中写的字符串，整理到string.xml中的方式是一样的，也是使用Alt + Enter快捷键进行处理，如下图所示：</p>
<p><img  src="../../images/20160822214326396.png"  ><span class="image-caption">这里写图片描述</span></p>
<p>使用Alt + Enter快捷键，然后弹出如下的对话框 ：</p>
<p><img  src="../../images/20160822214405086.png"  ><span class="image-caption">这里写图片描述</span></p>
<p>选择其中的“Extract string resource”, 然后弹出如下图所示的对话框,然后修改该字符串在string.xml中的key值 </p>
<p><img  src="../../images/20160822214610386.png"  ><span class="image-caption">这里写图片描述</span></p>
<p>点击“OK”按钮完成。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发者网站</title>
    <url>/tool/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/">https://developer.android.google.cn/</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>Beyond Compare 4密钥过期，解决办法，超实用</title>
    <url>/tool/BeyondCompare4%E5%AF%86%E9%92%A5%E8%BF%87%E6%9C%9F/</url>
    <content><![CDATA[<p>第一种办法（也是最有效的）</p>
<p><img  src="../../images/696983-20210722140441823-1691656198.png"  ><span class="image-caption">img</span></p>
<p>删除C:\Users\用户名\AppData\Roaming\Scooter Software\Beyond Compare 4下的所有文件，重启Beyond Compare 4即可（注意：用户名下的AppData文件夹有可能会被隐藏起来）</p>
<p>第二种办法<br>删除C:\Program Files\Beyond Compare 4\BCUnrar.dll（安装目录下的BCUnrar.dll文件），这个文件重命名或者直接删除。</p>
<p>第三种办法<br>修改注册表<br>1、在搜索栏中输入 regedit ，打开注册表<br>2、删除项目CacheId ：<br>HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_38345306/article/details/109175632">https://blog.csdn.net/weixin_38345306/article/details/109175632</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>关于SVN状态图标不显示的解决办法(史上最全)</title>
    <url>/tool/SVN%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>转自: <a href="https://www.jianshu.com/p/92e8e1f345c0">https://www.jianshu.com/p/92e8e1f345c0</a></p>
<p>以下非原创，如有侵权请联系告知。</p>
<p>关于图标的说明：<br>Windows Explorer Shell 支持 Overlay Icon 最多15个，Windows 自身已经使用了4个，所以就只剩下了11个 供我们使用。如果你之前安装了例如Groove这样的软件，那么可能我们可利用的就更少了，轮不到Tortoise了。像这样的情况，我们可以调整 Tortoise图标名称的字母顺序，来提高Tortoise的优先位置，因为Windows 内部就是安装名称的字母顺序来优先显示的。</p>
<p>对于有强迫症的开发人员来说，svn状态图标不显示是在是痛苦不堪啊，根据网上的办法加上自己亲测总结大概有以下几种情况：</p>
<h4 id="解决方法一（失败）："><a href="#解决方法一（失败）：" class="headerlink" title="解决方法一（失败）："></a>解决方法一（失败）：</h4><p>升级最新版本的svn</p>
<h4 id="解决方法二（失败）：（常用、便捷）"><a href="#解决方法二（失败）：（常用、便捷）" class="headerlink" title="解决方法二（失败）：（常用、便捷）"></a>解决方法二（失败）：（常用、便捷）</h4><p>右键-&gt;TortoiseSVN-&gt;setting-&gt;Icon Overlays-&gt;Status cache-&gt;default/Shell。<br>或者 右键-&gt;TortoiseSVN-&gt;setting-&gt;Icon Overlays-&gt;Drive Types&gt;fixed Drives</p>
<h4 id="解决方法三（失败）："><a href="#解决方法三（失败）：" class="headerlink" title="解决方法三（失败）："></a>解决方法三（失败）：</h4><p>修复或者卸载重装</p>
<h4 id="解决方法四（成功）："><a href="#解决方法四（成功）：" class="headerlink" title="解决方法四（成功）："></a>解决方法四（成功）：</h4><p>1.Win+R输入 regedit 进入注册表，</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;M<span class="hljs-function"><span class="hljs-title">icrosoft</span>-&gt;</span>W<span class="hljs-function"><span class="hljs-title">indows</span>-&gt;</span>C<span class="hljs-function"><span class="hljs-title">urrentVersion</span>-&gt;</span>E<span class="hljs-function"><span class="hljs-title">xplorer</span>-&gt;</span>ShellIconOverlayIdentifiers<br></code></pre></td></tr></table></figure>

<p>打开后发现Tortoise 系列（1TortoiseNormal，2TortoiseAdded等）前面有好多项的话，<strong>重命名Tortoise 系列以z开头即可</strong>，然后转到3。</p>
<p><img  src="../../images/1681638-136e20fa0cfc94b5.png"  ><span class="image-caption">img</span></p>
<p>Paste_Image.png</p>
<p>2.进入注册表若没有Tortoise 系列可能是被360等流氓软件删除了，需要新建注册表并导入了，具体操作<strong>复制粘贴如下内容到记事本并重命名为reg后缀文件，然后右键reg文件-&gt;注册表编辑器</strong>，即可导入注册表。导入后如上图所示。</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript"> Windows Registry Editor Version 5.00<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers]<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\1</span>TortoiseNormal]<br><br>@=&quot;&#123;C5994560-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\2</span>TortoiseModified]<br><br>@=&quot;&#123;C5994561-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\3</span>TortoiseConflict]<br><br>@=&quot;&#123;C5994562-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\4</span>TortoiseLocked]<br><br>@=&quot;&#123;C5994563-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\5</span>TortoiseReadOnly]<br><br>@=&quot;&#123;C5994564-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\6</span>TortoiseDeleted]<br><br>@=&quot;&#123;C5994565-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\7</span>TortoiseAdded]<br><br>@=&quot;&#123;C5994566-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\8</span>TortoiseIgnored]<br><br>@=&quot;&#123;C5994567-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\9</span>TortoiseUnversioned]<br><br>@=&quot;&#123;C5994568-53D9-4125-87C9-F193FC689CB2&#125;&quot;<br><br>[HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hellIconOverlayIdentifiers<span class="hljs-symbol">\O</span>ffline Files]<br><br>@=&quot;&#123;750fdf0e-2a26-11d1-a3ea-080036587f03&#125;&quot;<br></code></pre></td></tr></table></figure>



<p>3.打开任务管理器，<strong>在进程里找到explorer.exe右键结束进程，然后执行 文件-新建任务 输入 explorer.exe 回车</strong>即可</p>
<p>以上就是svn状态图标不显示的解决办法，如有错误请指正，谢谢</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>UI库QMUI</title>
    <url>/tool/UI%E5%BA%93QMUI/</url>
    <content><![CDATA[<p><a href="https://qmuiteam.com/">https://qmuiteam.com/</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>在线json解析网站</title>
    <url>/tool/json%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在线json解析网站：</p>
<p><a href="https://www.json.cn/">https://www.json.cn/</a></p>
<p><img  src="../../images/tool/json.png"  ><span class="image-caption">image-20210731154453704</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>在线图片压缩</title>
    <url>/tool/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>一款超级好用的在线图片压缩网站：</p>
<p><a href="https://tinypng.com/">https://tinypng.com/</a></p>
<p><img  src="../../images/tool/picture_compression.png"  ><span class="image-caption">image-20210731154453704</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>在线图片视频转gif</title>
    <url>/tool/%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91%E8%BD%ACgif/</url>
    <content><![CDATA[<p>在线图片视频转gif：</p>
<p><a href="https://ezgif.com/">https://ezgif.com/</a></p>
<p><img  src="../../images/tool/ezgif.png"  ><span class="image-caption">image-20210731154453704</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>时间戳转换网站</title>
    <url>/tool/%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>时间戳转换网站：</p>
<p><a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p>
<p><img  src="../../images/tool/time_stamp.png"  ><span class="image-caption">image-20210731154453704</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>阿里巴巴图标网站</title>
    <url>/tool/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%9B%BE%E6%A0%87%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>阿里巴巴图标网站：</p>
<p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p>
<p><img  src="../../images/tool/alibaba_icon.png"  ><span class="image-caption">image-20210731154453704</span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title>Android</title>
    <url>/topic/topic_Android/</url>
    <content><![CDATA[<h3 id="1-Android进阶"><a href="#1-Android进阶" class="headerlink" title="1.Android进阶"></a><strong>1.Android进阶</strong></h3><p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a6539b17d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">ss</span></p>
<h3 id="2-Android基础"><a href="#2-Android基础" class="headerlink" title="2.Android基础"></a><strong>2.Android基础</strong></h3><p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a64fa2d320?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">Android基础</span></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>App沙箱化</title>
    <url>/topic/topic_App%E6%B2%99%E7%AE%B1%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-App-是如何沙箱化，为什么要这么做？"><a href="#1-App-是如何沙箱化，为什么要这么做？" class="headerlink" title="1.App 是如何沙箱化，为什么要这么做？"></a>1.App 是如何沙箱化，为什么要这么做？</h3><p>在Android系统中，应用（通常）都在一个独立的沙箱中运行，即每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。</p>
<p>Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。</p>
<p>Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</p>
<p>Android扩展了Linux内核安全模型的用户与权限机制，将多用户操作系统的用户隔离机制巧妙地移植为应用程序隔离。将UID（一个用户标识）不同的应用程序自然形成资源隔离，如此便形成了一个操作系统级别的应用程序“沙箱”。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Binder通信原理</title>
    <url>/topic/topic_Binder%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>JNI/NDK</title>
    <url>/topic/topic_JNI%20%E4%B8%8E%20NDK/</url>
    <content><![CDATA[<h3 id="1-jni如何调用java层代码？"><a href="#1-jni如何调用java层代码？" class="headerlink" title="1.jni如何调用java层代码？"></a>1.jni如何调用java层代码？</h3><p>C代码回调Java方法步骤：<br>①获取字节码对象（jclass (FindClass)(JNIEnv, const char*);）<br>②通过字节码对象找到方法对象（jmethodID (GetMethodID)(JNIEnv, jclass, const char, const char);）<br>③通过字节码文件创建一个object对象（该方法可选，方法中已经传递一个object，如果需要调用的方法与本地方法不在同一个文件夹则需要新创建object（jobject (AllocObject)(JNIEnv, jclass);），如果需要反射调用的java方法与本地方法不在同一个类中，需要创建该方法，但是如果是这样，并且需要跟新UI操作，例如打印一个Toast 会报空指针异常，因为这时候调用的方法只是一个方法，没有actiivty的生命周期。）<br>④通过对象调用方法，可以调用空参数方法，也可以调用有参数方法，并且将参数通过调用的方法传入（void (CallVoidMethod)(JNIEnv, jobject, jmethodID, …);）</p>
<h3 id="2-NDK特点"><a href="#2-NDK特点" class="headerlink" title="2.NDK特点"></a>2.NDK特点</h3><p>1.性能方面：<br>（1）运行效率高：在开发要求高性能的需求中，采用C/C++更加有效率（如使用本地代码（C/C++）执行算法，能大大提高算大的执行效率）<br>（2）代码安全性高：java是半解释型语言，容易被反编译后得到源代码,而本地有些代码类型（如C/C++）则不会，能提高系统的安全性<br>2.功能方面：<br>功能扩展性好：可方便地使用其他开发语言的开源库，除了java的开源库，还可以使用开发语言（C/C++）的开源库<br>3.使用方面：<br>易于代码复用和移植：用本地代码（如C/C++）开发的代码不仅可在Android中使用，还可嵌入其他类型平台上使用</p>
<h3 id="3-JNI开发流程的步骤："><a href="#3-JNI开发流程的步骤：" class="headerlink" title="3.JNI开发流程的步骤："></a>3.JNI开发流程的步骤：</h3><p>传统的开发步骤：<br>第1步：在Java中先声明一个native方法<br>第2步：编译Java源文件，调用声明的本地native方法<br>第3步：通过javah -jni命令导出JNI的.h头文件，并在main下创建一个名为jni的文件夹，将这个.h文件copy进去。<br>第4步：在jni文件夹下创建.c文件，两部分内容：1)添加.h头文件 2)实现java中声明的native方法<br>第5步：在jni文件夹下创建.mk文件，android.mk主要用来告诉编译器，需要编译哪些c++文件，以及需要编译的外部库和一些系统库。<br>            如果不编写.mk文件会报错：<br>            错误：执行app:compileDebugNdk任务失败，不再支持android.useDeprecatedNdk标志，并且将会在未来的Android Studio版本中删除这个标志。<br>第6步：检查local.properties中是否配置了Android.useDeprecatedNdk=true ，在grandle文件是否配置了ndk信息<br>第7步：将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)<br>第8步：通过Java命令执行Java程序，最终实现Java调用本地代码。<br>PS：javah 是JDK自带的一个命令，-jni参数表示将class 中用到native 声明的函数生成JNI 规则的函数</p>
<p>使用Cmake步骤：<br>1.在创建项目的时候勾选Include C++ Suppert<br>2.项目创建完成后，会多出两个文件夹cpp和External Build Files ：<br>在 cpp 文件夹中：可以找到属于项目的所有原生源文件等构建库。对于新项目，Android Studio会创建一个示例C++源文件 native-lib.cpp，并将其置于应用模块src/main/cpp/目录中。这个示例代码提供了一个简单的C++函数stringFromJNI()，此函数可以返回字符串“Hello from C++”<br>在 External Build Files 文件夹中：可以找到CMake或 ndk-build 的构建脚本。与build.gradle文件指示Gradle构建应用一样，CMake和ndk-build需要一个构建脚本来了解如何构原生库。对于新项目，Android Studio 会创建一个CMake 构建脚本CMakeLists.txt，并将其置于模块根目录中。</p>
<p>Cmake工具原理：<br>它既然能够跑起来，就一定有一个入口，这个入口就是在build.grandle中，我们发现创建项目之后，grandle文件中自动多了一个叫externalNativeBuild的模块，<br>在grandle文件中，发现有两个地方用了externalNativeBuild，一个是在defaultConfig里面，一个是在defaultConfig外面。外面的指定了CMakeList.mk的路径，<br>在本项目的文件夹下，和build.grandle在同一目录下。里面的主要填写的Cmake的命令参数。即由arguments 中的参数最后转化成一个可执行的 CMake 的命令，<br>可以在 app/externalNativeBuild/cmake/debug/{abi}/cmake_build_command.txt中查到。</p>
<h3 id="4-JNI的优势："><a href="#4-JNI的优势：" class="headerlink" title="4.JNI的优势："></a>4.JNI的优势：</h3><p>与其它类似接口Microsoft的原始本地接口等相比，JNI的主要竞争优势在于：它在设计之初就确保了二进制的兼容性，<br>JNI编写的应用程序兼容性以及其再某些具体平台上的Java虚拟机兼容性(当谈及JNI时，这里并不特比针对Davik虚拟机，<br>JNI适用于所有JVM虚拟机)。这就是为什么C/C++编译后的代码无论在任何平台上都能执行。不过，一些早期版本并不支持二进制兼容。<br>二进制兼容性是一种程序兼容性类型，允许一个程序在不改变其可执行文件的条件下在不同的编译环境中工作。</p>
<h3 id="5-为什么要使用JNI"><a href="#5-为什么要使用JNI" class="headerlink" title="5.为什么要使用JNI?"></a>5.为什么要使用JNI?</h3><p>因为在实际需求中，需要Java代码与C/C++代码进行交互，通过JNI可以实现Java代码与C/C++代码的交互</p>
<h3 id="6-为什么要使用NDK"><a href="#6-为什么要使用NDK" class="headerlink" title="6.为什么要使用NDK?"></a>6.为什么要使用NDK?</h3><p>1.在平台之间移植其应用<br>2.重复使用现在库，或者提供其自己的库重复使用<br>3.在某些情况下提性能，特别是像游戏这种计算密集型应用<br>4.使用第三方库，现在许多第三方库都是由C/C++库编写的，比如Ffmpeg这样库。<br>5.不依赖于Dalvik Java虚拟机的设计<br>6.代码的保护。由于APK的Java层代码很容易被反编译，而C/C++库反编译难度大。</p>
<h3 id="7-JNI静态注册和动态注册"><a href="#7-JNI静态注册和动态注册" class="headerlink" title="7.JNI静态注册和动态注册"></a>7.JNI静态注册和动态注册</h3><p>静态注册：<br>通过 JNIEXPORT 和 JNICALL 两个宏定义声明，Java + 包名 + 类名 + 方法名 形式的函数名。不好的地方就是方法名太长了。</p>
<p>动态注册：<br>通常在 JNI_OnLoad 方法中通过 RegisterNatives 方法注册，可以不再遵从固定的命名写法（当然为了代码容易理解，名称还是尽量和 Java 中保持一致）。</p>
<h3 id="8-怎么定位-NDK-中的问题和错误"><a href="#8-怎么定位-NDK-中的问题和错误" class="headerlink" title="8.怎么定位 NDK 中的问题和错误"></a>8.怎么定位 NDK 中的问题和错误</h3><p>一般在开发阶段的话，我们可以通过 log 来定位和分析问题。</p>
<p>如果是上线状态（即关闭了基本的 log），我们可以借助 NDK 提供的 addr2line 工具和 objdump 工具来定位错误。详情：</p>
<p>so 动态库崩溃问题定位（addr2line与objdump）</p>
<p>其它还可以使用 C/C++ 的一些分析工具。</p>
<h3 id="9-JNI-线程间数据怎么互相访问"><a href="#9-JNI-线程间数据怎么互相访问" class="headerlink" title="9.JNI 线程间数据怎么互相访问"></a>9.JNI 线程间数据怎么互相访问</h3><p>线程本来就是共享内存区域的，因此我们需要使用 全局引用。</p>
<h3 id="10-解释一下-JNI-中全局引用和局部引用的区别和使用"><a href="#10-解释一下-JNI-中全局引用和局部引用的区别和使用" class="headerlink" title="10.解释一下 JNI 中全局引用和局部引用的区别和使用"></a>10.解释一下 JNI 中全局引用和局部引用的区别和使用</h3><p>全局引用<br>通过 NewGlobalRef 和 DeleteGlobalRef 方法创建和释放一个全局引用。<br>全局引用能在多个线程中被使用，且不会被 GC 回收，只能手动释放。</p>
<p>局部引用<br>通过 NewLocalRef 和 DeleteLocalRef 方法创建和释放一个局部引用。<br>局部引用只在创建它的 native 方法中有效，包括其调用的其它函数中有效。因此我们不能寄望于将一个局部引用直接保存在全局变量中下次使用（请使用全局引用实现该需求）。<br>我们可以不用删除局部引用，它们会在 native 方法返回时全部自动释放，但是建议对于不再使用的局部引用手动释放，避免内存过度使用。</p>
<p>扩展：弱全局引用<br>通过 NewWeakGlobalRef 和 DeleteWeakGlobalRef 创建和释放一个弱全局引用。<br>弱全局引用类似于全局引用，唯一的区别是它不会阻止被 GC 回收。</p>
<h3 id="11-谈谈你对-JNIEnv-和-JavaVM-理解"><a href="#11-谈谈你对-JNIEnv-和-JavaVM-理解" class="headerlink" title="11.谈谈你对 JNIEnv 和 JavaVM 理解"></a>11.谈谈你对 JNIEnv 和 JavaVM 理解</h3><p>JavaVM<br>JavaVM 是虚拟机在 JNI 层的代表。<br>一个进程只有一个 JavaVM。（重要！）<br>所有的线程共用一个 JavaVM。（重要！）</p>
<p>JNIEnv<br>JNIEnv 表示 Java 调用 native 语言的环境，封装了几乎全部 JNI 方法的指针。<br>JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。（重要！）</p>
<p>注意：<br>在 native 环境下创建的线程，要想和 java 通信，即需要获取一个 JNIEnv 对象。我们通过 AttachCurrentThread 和 DetachCurrentThread 方法将 native 的线程与 JavaVM 关联和解除关联。</p>
<h3 id="12-谈谈你对-JNI-和-NDK-的理解"><a href="#12-谈谈你对-JNI-和-NDK-的理解" class="headerlink" title="12.谈谈你对 JNI 和 NDK 的理解"></a>12.谈谈你对 JNI 和 NDK 的理解</h3><p>JNI：<br>JNI 是 Java Native Interface 的缩写，即 Java 的本地接口。<br>目的是使得 Java 与本地其他语言（如 C/C++）进行交互。<br>JNI 是属于 Java 的，与 Android 无直接关系。</p>
<p>NDK：<br>NDK 是 Native Development Kit 的缩写，是 Android 的工具开发包。<br>作用是更方便和快速开发 C/C++ 的动态库，并自动将动态库与应用一起打包到 apk。<br>NDK 是属于 Android 的，与 Java 无直接关系。</p>
<p>总结：<br>JNI 是实现的目的，NDK 是 Android 中实现 JNI 的手段</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>gradle</title>
    <url>/topic/topic_gradle/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>事件分发</title>
    <url>/topic/topic_%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<h3 id="1-布局加载的过程-？"><a href="#1-布局加载的过程-？" class="headerlink" title="1.布局加载的过程 ？"></a>1.布局加载的过程 ？</h3><ol>
<li><p>Activity的onCreate()方法中调用setContentView()方法，内部是PhoneWindow的setContentView()方法，在PhoneWindow中完成DocorView的创建；</p>
</li>
<li><p>DocorView是Activity的顶层布局，是PhoneWindow的内部实现类，继承自FrameLayout；</p>
</li>
<li><p>DocorView将View分成TitleView和ContentView，我们平时加载的布局就是加载到ContentView中。</p>
</li>
</ol>
<h3 id="2-事件分发的3个主要对象-？"><a href="#2-事件分发的3个主要对象-？" class="headerlink" title="2.事件分发的3个主要对象 ？"></a>2.事件分发的3个主要对象 ？</h3><ol>
<li><p>Activity：</p>
<p> 控制生命周期，处理事件；统筹view的添加、显示，通过其他回调方法与Window、View交互</p>
</li>
<li><p>View：</p>
<p> 所有UI组件的基类，一般Button、TextView都是继承View</p>
</li>
<li><p>ViewGroup：</p>
<p> 一组View的集合，其本身也是View的子类，是Android所有布局的父类，如LinearLayout。</p>
<p> 与View的区别：能包含子View，定义布局参数等功能。</p>
</li>
</ol>
<h3 id="3-Android-View的层级结构？"><a href="#3-Android-View的层级结构？" class="headerlink" title="3.Android View的层级结构？"></a>3.Android View的层级结构？</h3><p>View最顶层是Window，然后是PhoneWindow，是Window的唯一实现类，PhoneWindow中有一个内部类DocorView，PhoneWindow通过DocorView传递消息给view,view也通过DocorView返回消息给PhoneWindow。</p>
<h3 id="4-Android中为什么要有事件分发机制-？"><a href="#4-Android中为什么要有事件分发机制-？" class="headerlink" title="4.Android中为什么要有事件分发机制 ？"></a>4.Android中为什么要有事件分发机制 ？</h3><p>Android的view层级是树形结构的，多个view可能会重叠在一起，当我们点击或者滑动屏幕的时候这个时间该给谁呢？为了解决这个问题，就有了事件分发机制</p>
<h3 id="5-View的分发机制，滑动冲突"><a href="#5-View的分发机制，滑动冲突" class="headerlink" title="5.View的分发机制，滑动冲突"></a>5.View的分发机制，滑动冲突</h3><p>View的事件传递顺序有3个重要的方法，dispatchTouchEvent()是否消耗了本次事件，onInterceptTouchEvent()是否拦截了本次事件，onTouchEvent()是否处理本次事件，滑动冲突分为同方向滑动冲突，例如ScrollView和ListView，同方向滑动冲突，可以计算ListView高度而动态设置ListView的高度，ScrollView高度可变。例如ViewPager和ListView,不同方向滑动冲突，一个是横向滑动一个是竖直滑动，不同方向滑动可以判断滑动的x，y轴是横向还是竖直滑动，如果判断得到是横向滑动，就拦截ListView的事件，竖则反之。</p>
<h3 id="6-view的事件分发和view的工作原理"><a href="#6-view的事件分发和view的工作原理" class="headerlink" title="6.view的事件分发和view的工作原理"></a>6.view的事件分发和view的工作原理</h3><p>Android自定义view，我们都知道实现有三部曲，onMeasure(),onLayout(),onDraw()。View的绘制流程是从viewRoot的perfromTraversal方法开始的。它经过measure，layout，draw方法才能够将view绘制出来。其中measure是测量宽高的，layout是确定view在父容器上的摆布位置的，draw是将view绘制到屏幕上的。</p>
<p>Measure:<br>view的测量是需要MeasureSpc(测量规格)，它代表一个32位int值，高2位代表SpecMode(测量模式)，低（30）位的代表SpecSize(某种测量模式下的规格大小)。而一组SpecMode和SpeSize可以打包为一个MeasureSpec,反之，MeasureSpec可以解包得到SpecMode和SpeSize的值。SpecMode有三类：<br>unSpecified:父容器不对view有任何限制，要多大有多大。一般系统用这个多。<br>Exactly:父容器已经检测出view所需要的精确大小，这个时候，view的大小就是SpecSize所指定的值，它对应者layout布局中的math_parent或者是具体的数值<br>At_most:父容器指定了一个可用大小的SpecSize,view的大小不能够大于这个值，它对应这布局中的wrao_content.<br>对于普通的view，它的MeasureSpec是由父容器的MeasureSpec和自身的layoutParam共同决定的，一旦MeasureSpec确定后，onMeasure就可以确定view的宽高了。<br>View的measure过程：<br>onMeasure方法中有个setMeasureDimenSion方法来设置view的宽高测量值，而setMeasureDimenSion有个getDefaultSize()方法作为参数。一般情况下，我们只需要关注at_most和exactly两种情况，getDefaultSize的返回值就是measureSpec中的SpecSize,而这个值基本就是view测量后的大小。而UnSpecified这种情况，一般是系统内部的测量过程，它是需要考虑view的背景这些因素的。<br>前面说的是view的测量过程，而viewGroup的measure过程：<br>对于viewGroup来说，除了完成自己的measure过程以外，还要遍历去调用子类的measure方法，各个子元素在递归执行这个过程，viewGroup是一个抽象的类，没有提供有onMeasure方法，但是提供了一个measureChildren的方法。measureChild方法的思想就是取出子元素的layoutParams,然后通过getChildMeasureSpec来常见子元素的MeasureSpec,然后子元素在电泳measure方法进行测量。由于viewGroup子类有不同的布局方式，导致他们的测量细节不一样，所以viewGroup不能象view一样调用onMeasure方法进行测量。<br>注意：在activity的生命周期中是没有办法正确的获取view的宽高的，原因就是view没有测量完。<br>在onWindowFocuschanged方法中获取 —-改方法含义是view已经初始化完毕<br>View.post()方法，将润那边了投递到消息队列的尾部。<br>使用viewTreeObserver的回调来完成。<br>通过view.measure方式手动测量。</p>
<p>onLayout<br>普通的view的话，可以通过setFrame方法来的到view四个顶点的位置，也就确定了view在父容器的位置，接着就调用onLayout方法，该方法是父容器确定子元素的位置。</p>
<p>onDraw<br>该方法就是将view绘制到屏幕上。分以下几步<br>绘制背景，<br>绘制自己，<br>绘制child，<br>绘制装饰。</p>
<h3 id="7-事件分发中的onTouch-和onTouchEvent-有什么区别，又该如何使用？"><a href="#7-事件分发中的onTouch-和onTouchEvent-有什么区别，又该如何使用？" class="headerlink" title="7.事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？"></a>7.事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？</h3><p>OnTouch方法：<br>onTouch()是OnTouchListener接口的方法，它是获取某一个控件的触摸事件，因此使用时。通过getAction()方法可以获取当前触摸事件的状态：如：ACTION_DOWN：表示按下了屏幕的状态。</p>
<p>OnTouchEvent()方法：<br>onTouchEvent是手机屏幕事件的处理方法，是获取的对屏幕的各种操作，比如向左向右滑动，点击返回按钮等等。<br>通过查看安卓源码中View对dispatchTouchEvent的实现，可以知道onTouchListener(onTouch方法在其中)的接口的执行顺序是要先于onTouchEvent的，onTouch方法会先触发。</p>
<p>如果onTouchListener中的onTouch方法返回true，表示此次事件已经被消费了，那onTouchEvent是接收不到消息的。（内置诸如click事件的实现等等都基于onTouchEvent,这些事件将不会被触发），如果onTouch方法返回false会接着触发onTouchEvent。</p>
<h3 id="8-请描述一下View事件传递分发机制"><a href="#8-请描述一下View事件传递分发机制" class="headerlink" title="8.请描述一下View事件传递分发机制"></a>8.请描述一下View事件传递分发机制</h3><p>1.Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。<br>2.ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。<br>3.触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。<br>4.当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。<br>5.当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。<br>6.当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。<br>7.onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>内存泄漏/溢出</title>
    <url>/topic/topic_%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/topic/topic_%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-加密算法-？"><a href="#1-加密算法-？" class="headerlink" title="1.加密算法 ？"></a>1.加密算法 ？</h3><p>Base64算法：</p>
<p>Base64只是一种编码方式，将二进制数据转化为字符，不要使用Base64来进行加密数据。</p>
<p>Base64加密后果：</p>
<p>加密后的结果是字节数组，这些被加密后的字节在码表（例如 UTF-8 码表）上找不到对应字符，会出现乱码，当乱码字符串再次转换为字节数组时，长度会变化，导致解密失败，所以转换后的数据是不安全的。使用 Base64 对字节数组进行编码，任何字节都能映射成对应的 Base64 字符，之后能恢复到字节数组，利于加密后数据的保存于传输，所以转换是安全的。同样，字节数组转换成 16 进制字符串也是安全的</p>
<p>SHA - 安全散列算法：</p>
<p>能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法，且若输入的消息不同，它们对应到不同字符串的机率很高。</p>
<p>HMAC：</p>
<p>HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。即在SHA算法上增加了一个密钥作为数据认证，主要用于身份验证中。</p>
<p>XOR：</p>
<p>异或加密：<br>某个字符或者数值 x 与一个数值 m 进行异或运算得到 y ,则再用 y 与 m 进行异或运算就可还原为 x。</p>
<p>使用场景：</p>
<p>两个变量的互换（不借助第三个变量）；<br>数据的简单加密解密；</p>
<h3 id="2-非对称加密算法-？"><a href="#2-非对称加密算法-？" class="headerlink" title="2.非对称加密算法 ？"></a>2.非对称加密算法 ？</h3><p>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</p>
<p>非对称加密与对称加密相比，其安全性更好：对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p>RSA：</p>
<p>非对称加密算法</p>
<p>1999年512位密钥的RSA被成功破解，2009年1024位密钥的RSA也被成功破解，因此建议使用2048位的密钥长度。<br>RSA非对称加密内容长度有限制，无论是公钥加密还是私钥加密，1024位的key最多只能加密127位数据，否则会抛出异常：javax.crypto.IllegalBlockSizeException: input must be under 128 bytes。这是由于RSA算法规定：待加密的字节数不能超过密钥的长度值除以8再减去11，（即：KeySize / 8 - 11），<br>而加密后得到密文的字节数，是密钥的长度值除以 8（即：KeySize / 8），因此在加密和解密的时候需要分进行分块加密和解密。<br>建议使用RSA/ECB/OAEPWithSHA256AndMGF1Padding加密算法。<br>但是使用OAEPWithSHA256AndMGF1Padding作为填充方式的话，对输入即data的长度有限制,数据长度不能超过191，若超过时，会抛出too much data for RSA block异常。</p>
<h3 id="3-对称加密算法-？"><a href="#3-对称加密算法-？" class="headerlink" title="3.对称加密算法 ？"></a>3.对称加密算法 ？</h3><p>DES：</p>
<p>全称为 Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。</p>
<p>3DES：</p>
<p>也叫 Triple DES，是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<p>AES:<br>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。AES 算法加密强度大，执行效率高，使用简单，实际开发中建议选择 AES 算法。</p>
<h3 id="4-Android中常用的加密算法？"><a href="#4-Android中常用的加密算法？" class="headerlink" title="4.Android中常用的加密算法？"></a>4.Android中常用的加密算法？</h3><p>对称加密算法</p>
<p> 加密和解密密钥相同，例如，DES、3DES、AES</p>
<p>非对称加密算法 （公钥、私钥）</p>
<p>加密和解密密钥不同，但是是一对，例如RSA、ECC</p>
<p>摘要算法 </p>
<p>变长变定长，不能还原，MD5、SHA、CRC</p>
<h3 id="5-什么是aes加密？"><a href="#5-什么是aes加密？" class="headerlink" title="5.什么是aes加密？"></a>5.什么是aes加密？</h3><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p>
<h3 id="6-MD5加密有哪些特点？"><a href="#6-MD5加密有哪些特点？" class="headerlink" title="6.MD5加密有哪些特点？"></a>6.MD5加密有哪些特点？</h3><p>压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>容易计算：从原数据计算出MD5值很容易。<br>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p>
<p>MD5应用场景：一致性验证,数字签名,安全访问认证</p>
<h3 id="7-什么是MD5加密？"><a href="#7-什么是MD5加密？" class="headerlink" title="7.什么是MD5加密？"></a>7.什么是MD5加密？</h3><p>MD5英文全称“Message-Digest Algorithm 5”，翻译过来是“消息摘要算法5”，由MD2、MD3、MD4演变过来的，是一种单向加密算法，是不可逆的一种的加密方式。</p>
<h3 id="8-什么是Rsa加密？"><a href="#8-什么是Rsa加密？" class="headerlink" title="8.什么是Rsa加密？"></a>8.什么是Rsa加密？</h3><p>RSA算法是最流行的公钥密码算法，使用长度可以变化的密钥。RSA是第一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA算法原理如下：<br>1.随机选择两个大质数p和q，p不等于q，计算N=pq；<br>2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。<br>3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。<br>4.销毁p和q。</p>
<p>最终得到的N和e就是“公钥”，d就是“私钥”，发送方使用N去加密数据，接收方只有使用d才能解开数据内容。</p>
<p>RSA的安全性依赖于大数分解，小于1024位的N已经被证明是不安全的，而且由于RSA算法进行的都是大数计算，使得RSA最快的情况也比DES慢上倍，这是RSA最大的缺陷，因此通常只能用于加密少量数据或者加密密钥，但RSA仍然不失为一种高强度的算法。</p>
<p>使用场景：项目中除了登陆，支付等接口采用rsa非对称加密，之外的采用aes对称加密，今天我们来认识一下aes加密。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>动画</title>
    <url>/topic/topic_%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h3 id="1-Android动画原理"><a href="#1-Android动画原理" class="headerlink" title="1.Android动画原理"></a>1.Android动画原理</h3><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View<br>实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值<br>然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画<br>动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件</p>
<h3 id="2-Android属性动画特性"><a href="#2-Android属性动画特性" class="headerlink" title="2.Android属性动画特性"></a>2.Android属性动画特性</h3><p>(1) 对任意对象的属性执行动画操作：属性动画允许对任意对象的属性执行动画操作，因为属性动画的性质是通过反射实现的。<br>(2)可改变背景颜色。<br>(3)真正改变 View 本身：因为是通过反射改变其属性，并刷新，如改变width，他会搜索getWidth(),反射获取，再通过进行某种计算，将值通过setWidth()设置进去并更新。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>原生view</title>
    <url>/topic/topic_%E5%8E%9F%E7%94%9Fview/</url>
    <content><![CDATA[<h3 id="1-Bitmap的内存计算方式？"><a href="#1-Bitmap的内存计算方式？" class="headerlink" title="1.Bitmap的内存计算方式？"></a>1.Bitmap的内存计算方式？</h3><p>名词解释：<br>density ：表示每英寸有多少个显示点，与分辨率是两个不同的概念。<br>手机屏幕英寸：表示手机屏幕对角线的长度，1英寸 = 2.54cm<br>px ： 像素 分辨率的单位<br>dp ： 在每英寸160点的显示屏上，1dp = 1px，即px = dp(dpi / 160)<br>sp ： 通常用于指定字体的大小，当用户修改手机显示的字体时，字体大小会随之改变。<br>dpi ：每英寸的点数，也称像素密度，即屏幕对角线像素值÷英寸值。<br>ppi ： 每英寸上的像素数</p>
<p>不同资源文件夹对应的手机屏幕密度值：<br>m : 160<br>h : 240<br>xh : 320<br>xxh : 480<br>xxxh : 640</p>
<p>图片编码格式：<br>ARGB_8888 ： 4byte<br>ARGB_4444 ： 2byte<br>RGB_565 ： 2byte</p>
<p>Bitmap大小计算方式：</p>
<ol>
<li><p>直接创建一个Bitmap对象<br>Bitmap bitmap = Bitmap.createBitmap(100,100,Bitmap.Config.ARGB_8888);<br>计算公式：像素数据的内存=图片宽 x 图片高 x 单个像素内存大小，<br>100 * 100 * 4 = 40000byte</p>
</li>
<li><p>放在不同的资源文件夹中<br>文件&amp;网络&amp;assert文件夹&amp;res/drawable-nodpi文件夹<br>从这些位置加载图片会保持原尺寸，不缩放，bitmap宽高100x100，内存=100x100x4byte</p>
</li>
</ol>
<p>res/drawable-mdpi文件夹<br>因为该文件夹的目标设备是mdpi，显示到xhdpi的设备上，要做放大320/160=2倍，加载后的bitmap宽高200x200，内存200x200x4byte</p>
<p>res/drawable-hdpi文件夹<br>该文件夹目标设备是hdpi，显示到xhdpi设备上，要放大320/240倍，加载后的bitmap宽高133x133，内存133x133x4byte</p>
<p>res/drawable-xhdpi文件夹<br>因为文件夹和设备屏幕像素密度相同，不做缩放，加载后bitmap宽高100x100，内存100x100x4byte</p>
<p>res/drawable-xxhdpi文件夹<br>因为文件夹目标设备是xxhdpi，显示到xhdpi设备上，要缩小320/480倍，加载后bitmap宽高75x75，内存75x75x4byte</p>
<p>res/drawable-xxhdpi文件夹计算方式类似。</p>
<p>res/drawable文件夹<br>该文件夹为基准分辨率，与res/drawable-mdpi文件夹效果相同。</p>
<h3 id="2-Bitmap的高效加载？"><a href="#2-Bitmap的高效加载？" class="headerlink" title="2.Bitmap的高效加载？"></a>2.Bitmap的高效加载？</h3><p>Bitmap的高效加载在Glide中也用到了，思路：</p>
<p>获取需要的长和宽，一般获取控件的长和宽。<br>设置BitmapFactory.Options中的inJustDecodeBounds为true，可以帮助我们在不加载进内存的方式获得Bitmap的长和宽。<br>对需要的长和宽和Bitmap的长和宽进行对比，从而获得压缩比例，放入BitmapFactory.Options中的inSampleSize属性。<br>设置BitmapFactory.Options中的inJustDecodeBounds为false，将图片加载进内存，进而设置到控件中。</p>
<h3 id="3-recyclerView嵌套卡顿解决如何解决"><a href="#3-recyclerView嵌套卡顿解决如何解决" class="headerlink" title="3.recyclerView嵌套卡顿解决如何解决"></a>3.recyclerView嵌套卡顿解决如何解决</h3><p>设置预加载的数量LinearLayoutManager.setInitialPrefetchItemCount(4)，默认是预加载2个，<br>设置子项缓存，<br>设置自带滑动冲突解决属性rv.setHasFixedSize(true); rv.setNestedScrollingEnabled(false);<br>可以完美解决，不过Google不推荐RecyClerView嵌套使用,需要嵌套尽量找类似于ExpandableListView 第三方控件来解决</p>
<h3 id="4-RecyclerView和ListView的区别"><a href="#4-RecyclerView和ListView的区别" class="headerlink" title="4.RecyclerView和ListView的区别"></a>4.RecyclerView和ListView的区别</h3><p>缓存上:前者缓存的是View+ViewHolder+flag，不用每次调用findViewById,后者则只是缓存View<br>刷新数据方面，前者提供了局部刷新，后者则全部刷新</p>
<h3 id="5-View的绘制原理"><a href="#5-View的绘制原理" class="headerlink" title="5.View的绘制原理"></a>5.View的绘制原理</h3><p>View为所有图形控件的基类，View的绘制由3个函数完成<br>measure,计算视图的大小<br>layout,提供视图要显示的位置<br>draw,绘制</p>
<h3 id="6-View和SurfaceView的区别"><a href="#6-View和SurfaceView的区别" class="headerlink" title="6.View和SurfaceView的区别"></a>6.View和SurfaceView的区别</h3><p>View基于主线程刷新UI，SurfaceView子线程又可以刷新UI</p>
<h3 id="7-ListView卡顿的原因以及优化策略"><a href="#7-ListView卡顿的原因以及优化策略" class="headerlink" title="7.ListView卡顿的原因以及优化策略"></a>7.ListView卡顿的原因以及优化策略</h3><p>重用converView： 通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
<p>减少findViewById()操作： 将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</p>
<p>避免在 getView 方法中做耗时的操作: 例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</p>
<p>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</p>
<p>尽量能保证 Adapter 的 hasStableIds() 返回 true 这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</p>
<p>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。 由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</p>
<p>使用 RecycleView 代替listview： 每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</p>
<p>ListView 中元素避免半透明： 半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</p>
<p>尽量开启硬件加速： 硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
<h3 id="8-Bitmap-使用时候注意什么？"><a href="#8-Bitmap-使用时候注意什么？" class="headerlink" title="8.Bitmap 使用时候注意什么？"></a>8.Bitmap 使用时候注意什么？</h3><p>注意oom<br>1，要选择合适的图片规格（bitmap类型），即：<br>ALPHA_8 每个像素占用1byte内存<br>ARGB_4444 每个像素占用2byte内存<br>ARGB_8888 每个像素占用4byte内存 不设置的话默认这个。<br>RGB_565 每个像素占用2byte内存</p>
<p>2，降低采样率。BitmapFactory.Options 参数inSampleSize的使用，先把options.inJustDecodeBounds设为true，只是去读取图片的大小，在拿到图片的大小之后和要显示的大小做比较通过calculateInSampleSize()函数计算inSampleSize的具体值，得到值之后。options.inJustDecodeBounds设为false读图片资源。<br>3，复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不需要在重新给这个bitmap申请一块新的内存,避免了一次内存的分配和回收，从而改善了运行效率。<br>4，及时回收。即，recycle。<br>5，压缩图片。compress。<br>6，尽量不要使用setImageBitmap或setImageResource或BitmapFactory.decodeResource来设置一张大图，因为这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存，可以通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source。</p>
<h3 id="9-RecyclerView与ListView-缓存原理，区别联系，优缺点"><a href="#9-RecyclerView与ListView-缓存原理，区别联系，优缺点" class="headerlink" title="9.RecyclerView与ListView(缓存原理，区别联系，优缺点)"></a>9.RecyclerView与ListView(缓存原理，区别联系，优缺点)</h3><p>ListView有两级缓存，在屏幕与非屏幕内。<br>RecyclerView比ListView多两级缓存，支持多个离屏ItemView缓存（匹配pos获取目标位置的缓存，如果匹配则无需再次bindView），支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>缓存不同：<br>ListView缓存View。<br>RecyclerView缓存RecyclerView.ViewHolder，抽象可理解为：<br>View + ViewHolder(避免每次createView时调用findViewById) + flag(标识状态)；</p>
<p>优点<br>RecylerView提供了局部刷新的接口，通过局部刷新，就能避免调用许多无用的bindView。<br>RecyclerView的扩展性更强大（LayoutManager、ItemDecoration等）。</p>
<h3 id="10-Recycleview和ListView的区别"><a href="#10-Recycleview和ListView的区别" class="headerlink" title="10.Recycleview和ListView的区别"></a>10.Recycleview和ListView的区别</h3><p>RecyclerView可以完成ListView,GridView的效果，还可以完成瀑布流的效果。同时还可以设置列表的滚动方向（垂直或者水平）；<br>RecyclerView中view的复用不需要开发者自己写代码，系统已经帮封装完成了。<br>RecyclerView可以进行局部刷新。<br>RecyclerView提供了API来实现item的动画效果。<br>缓存机制：ListView(两级缓存)RecyclerView(四级缓存)<br>在性能上：<br>如果需要频繁的刷新数据，需要添加动画，则RecyclerView有较大的优势。<br>如果只是作为列表展示，则两者区别并不是很大。</p>
<h3 id="11-ListView-中图片错位的问题是如何产生的"><a href="#11-ListView-中图片错位的问题是如何产生的" class="headerlink" title="11.ListView 中图片错位的问题是如何产生的?"></a>11.ListView 中图片错位的问题是如何产生的?</h3><p>图片错位原理：<br>如果我们只是简单显示list中数据，而没用convertview的复用机制和异步操作，就不会产生图片错位；<br>重用convertview但没用异步，也不会有错位现象。但我们的项目中list一般都会用，不然会很卡。<br>在上图中，我们能看到listview中整屏刚好显示7个item，当向下滑动时，显示出item8，而item8是重用的item1，如果此时异步网络请求item8的图片，比item1的图片慢，那么item8就会显示item1的image。当item8下载完成，此时用户向上滑显示item1时，又复用了item8的image，这样就导致了图片错位现象(item1和item8是用的同一块内存哦)。</p>
<p>解决方法：<br>对imageview设置tag，并预设一张图片。<br>向下滑动后，item8显示，item1隐藏。但由于item1是第一次进来就显示，所以一般情况下，item1都会比item8先下载完，但由于此时可见的item8的tag，和隐藏了的item1的url不匹配，所以就算item1的图片下载完也不会显示到item8中，因为tag标识的永远是可见图片中的url。</p>
<h3 id="12-ListView重用的是什么？"><a href="#12-ListView重用的是什么？" class="headerlink" title="12.ListView重用的是什么？"></a>12.ListView重用的是什么？</h3><p>1.如果复用的View为null时，我们要创建一个新的item以及ViewHolder，<br>然后把item视图中的控件通过findViewById方法寻找到，<br>并添加到ViewHolder中，setTag方法，将viewholder传进去，完成viewholder与item之间的绑定</p>
<p>2.如果复用的View不是为null,那么通过getTag（）方法直接拿过来用,并且从里面拿出ViewHolder,因为每一个复用的ViewHolder肯定是经过处创建并且返回的</p>
<h3 id="13-计算一个view的嵌套层级"><a href="#13-计算一个view的嵌套层级" class="headerlink" title="13.计算一个view的嵌套层级"></a>13.计算一个view的嵌套层级</h3><p>循环追寻父类，看看有多少，便有多少嵌套层级：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">view</span>.getParents() != <span class="hljs-built_in">null</span>) &#123;<br>        <span class="hljs-built_in">count</span>++;<br>        <span class="hljs-built_in">view</span> = <span class="hljs-built_in">view</span>.getParents();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="14-Android中View，SurfaceView和GLSurfaceView"><a href="#14-Android中View，SurfaceView和GLSurfaceView" class="headerlink" title="14.Android中View，SurfaceView和GLSurfaceView"></a>14.Android中View，SurfaceView和GLSurfaceView</h3><p>View：显示视图，内置画布，提供图形绘制函数，触屏事件，按键事件函数；必须在UI线程中更新画面，速度较慢。<br>SurfaceView：基于View视图进行拓展的视图类，更适合2D游戏的开发；是View的子类，类似双缓机制，在新的线程中更新画面，所以刷新界面速度比View快。（双缓机制：即前台缓存和后台缓存，后台缓存计算场景、产生画面，前台缓存显示后台缓存已画好的画面。）<br>GLSurfaceView：基于SurfaceView视图再次进行扩展的视图类，专用于3D游戏开发的视图；是SurfaceView的子类，OpenGL专用。（OpenGL：是一个开放的三维图形软件包。）</p>
<h3 id="15-LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。"><a href="#15-LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。" class="headerlink" title="15.LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。"></a>15.LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。</h3><p>RelativeLayout的onMeasure过程<br>根据源码我们发现RelativeLayout会根据2次排列的结果对子View各做一次measure。<br>首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，在确定每个子View的位置的时候，需要先给所有的子View排序一下，所以需要横向纵向分别进行一次排序测量</p>
<p>LinearLayout的onMeasure过程<br>LinearLayout会先做一个简单横纵方向判断<br>需要注意的是在每次对child测量完毕后，都会调用child.getMeasuredHeight()/getMeasuredWidth()获取该子视图最终的高度，并将这个高度添加到mTotalLength中。<br>但是getMeasuredHeight暂时避开了lp.weight&gt;0且高度为0子View，因为后面会将把剩余高度按weight分配给相应的子View。因此可以得出以下结论：<br>（1）如果我们在LinearLayout中不使用weight属性，将只进行一次measure的过程。（如果使用weight属性，则遍历一次wiew测量后，再遍历一次view测量）<br>（2）如果使用了weight属性，LinearLayout在第一次测量时获取所有子View的高度，之后再将剩余高度根据weight加到weight&gt;0的子View上。由此可见，weight属性对性能是有影响的。<br>1）RelativeLayout慢于LinearLayout是因为它会让子View调用2次measure过程，而LinearLayout只需一次，但是有weight属性存在时，LinearLayout也需要两次measure。<br>2）在不响应层级深度的情况下，使用Linearlayout而不是RelativeLayout。</p>
<h3 id="16-AlertDialog-popupWindow区别"><a href="#16-AlertDialog-popupWindow区别" class="headerlink" title="16.AlertDialog,popupWindow区别"></a>16.AlertDialog,popupWindow区别</h3><p>（1）Popupwindow在显示之前一定要设置宽高，Dialog无此限制。<br>（2）Popupwindow默认不会响应物理键盘的back，除非显示设置了popup.setFocusable(true);而在点击back的时候，Dialog会消失。<br>（3）Popupwindow不会给页面其他的部分添加蒙层，而Dialog会。</p>
<p>（4）Popupwindow没有标题，Dialog默认有标题，可以通过dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题<br>（5）二者显示的时候都要设置Gravity。如果不设置，Dialog默认是Gravity.CENTER。<br>（6）二者都有默认的背景，都可以通过setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));去掉。<br>最本质的区别：AlertDialog是非阻塞式对话框：AlertDialog弹出时，后台还可以做事情；而PopupWindow是阻塞式对话框：PopupWindow弹出时，程序会等待，在PopupWindow退出前，程序一直等待，只有当我们调用了dismiss方法的后，PopupWindow退出，程序才会向下执行。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>反射</title>
    <url>/topic/topic_%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="1-动态代理和静态代理"><a href="#1-动态代理和静态代理" class="headerlink" title="1.动态代理和静态代理"></a>1.动态代理和静态代理</h3><p>静态代理很简单，运用的就是代理模式：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a6cfb98cfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">代理模式</span></p>
<p>代理模式</p>
<p>声明一个接口，再分别实现一个真实的主题类和代理主题类，通过让代理类持有真实主题类，从而控制用户对真实主题的访问。</p>
<p>动态代理指的是在运行时动态生成代理类，即代理类的字节码在运行时生成并载入当前的ClassLoader。</p>
<p>动态代理的原理是使用反射，思路和上面的一致。</p>
<p>使用动态代理的好处：</p>
<p>不需要为RealSubject写一个形式完全一样的代理类。<br>使用一些动态代理的方法可以在运行时制定代理类的逻辑，从而提升系统的灵活性。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>存储</title>
    <url>/topic/topic_%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h3 id="1-SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？"><a href="#1-SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？" class="headerlink" title="1.SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？"></a>1.SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？</h3><p>在两个应用的manifest配置中好相同的shartdUserId属性，A应用正常保存数据，B应用<br>createPackageContext(“com.netease.nim.demo”, CONTEXT_IGNORE_SECURITY)<br>获取context然后获取应用数据，为保证数据安全，使用加密存储</p>
<h3 id="2-Android为每个应用程序分配的内存大小是多少？"><a href="#2-Android为每个应用程序分配的内存大小是多少？" class="headerlink" title="2.Android为每个应用程序分配的内存大小是多少？"></a>2.Android为每个应用程序分配的内存大小是多少？</h3><p>准确的说话是 google原生OS的默认值是16M，但是各个厂家的系统会对这个值进行修改。不同厂商的值不同<br>（1）未设定属性android:largeheap = “true”时，可以申请到的最大内存空间。<br>（2）设定属性android:largeheap = “true”时， 可以申请的最大内存空间为原来的两倍多一些。</p>
<h3 id="3-数据库的优化"><a href="#3-数据库的优化" class="headerlink" title="3.数据库的优化"></a>3.数据库的优化</h3><p>1、索引<br>简单的说，索引就像书本的目录，目录可以快速找到所在页数，数据库中索引可以帮助快速找到数据，而不用全表扫描，合适的索引可以大大提高数据库查询的效率。<br>(1). 优点<br>大大加快了数据库检索的速度，包括对单表查询、连表查询、分组查询、排序查询。经常是一到两个数量级的性能提升，且随着数据数量级增长。</p>
<p>(2). 缺点<br>索引的创建和维护存在消耗，索引会占用物理空间，且随着数据量的增加而增加。<br>在对数据库进行增删改时需要维护索引，所以会对增删改的性能存在影响。</p>
<p>2、使用事务<br>使用事务的两大好处是原子提交和更优性能。<br>(1) 原子提交<br>原则提交意味着同一事务内的所有修改要么都完成要么都不做，如果某个修改失败，会自动回滚使得所有修改不生效。</p>
<p>(2) 更优性能<br>Sqlite默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。<br>这样如果连续插入100次数据实际是创建事务-&gt;执行语句-&gt;提交这个过程被重复执行了100次。如果我们显示的创建事务-&gt;执行100条语句-&gt;提交会使得这个创建事务和提交这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。尤其当数据库位于sd卡时，时间上能节省两个数量级左右。</p>
<h3 id="4-LruCache默认缓存大小"><a href="#4-LruCache默认缓存大小" class="headerlink" title="4.LruCache默认缓存大小"></a>4.LruCache默认缓存大小</h3><p>基本上设置为手机内存的1/8</p>
<h3 id="5-SP是进程同步的吗-有什么方法做到同步？"><a href="#5-SP是进程同步的吗-有什么方法做到同步？" class="headerlink" title="5.SP是进程同步的吗?有什么方法做到同步？"></a>5.SP是进程同步的吗?有什么方法做到同步？</h3><p>SharedPreferences不支持进程同步<br>一个进程的情况，经常采用SharePreference来做，但是SharePreference不支持多进程，它基于单个文件的，默认是没有考虑同步互斥，而且，APP对SP对象做了缓存，不好互斥同步。</p>
<p>考虑用ContentProvider来实现SharedPreferences的进程同步，ContentProvider基于Binder，不存在进程间互斥问题，对于同步，也做了很好的封装，不需要开发者额外实现。另外ContentProvider的每次操作都会重新getSP，保证了sp的一致性。</p>
<h3 id="6-Android中数据存储方式"><a href="#6-Android中数据存储方式" class="headerlink" title="6.Android中数据存储方式"></a>6.Android中数据存储方式</h3><p>1 使用SharedPreferences存储数据<br>适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。<br>比如应用程序的各种配置信息（如是否打开音效等），解锁口 令密码等<br>核心原理：保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。</p>
<p>2 文件存储数据<br>核心原理: Context提供了两个方法来打开数据文件里的文件IO流：<br>FileInputStream openFileInput(String name);<br>FileOutputStream openFileOutput(String name , int mode)<br>3 SQLite数据库存储数据<br>4 使用ContentProvider存储数据<br>5 网络存储数据</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>屏幕适配</title>
    <url>/topic/topic_%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h3 id="1-平时如何有使用屏幕适配吗？原理是什么呢？"><a href="#1-平时如何有使用屏幕适配吗？原理是什么呢？" class="headerlink" title="1.平时如何有使用屏幕适配吗？原理是什么呢？"></a>1.平时如何有使用屏幕适配吗？原理是什么呢？</h3><p>平时的屏幕适配一般采用的头条的屏幕适配方案。简单来说，以屏幕的一边作为适配，通常是宽。</p>
<p>原理：设备像素px和设备独立像素dp之间的关系是</p>
<p>px = dp * density<br>假设UI给的设计图屏幕宽度基于360dp，那么设备宽的像素点已知，即px，dp也已知，360dp，所以density = px / dp，之后根据这个修改系统中跟density相关的知识点即可。</p>
<h3 id="2-屏幕适配的处理技巧都有哪些"><a href="#2-屏幕适配的处理技巧都有哪些" class="headerlink" title="2.屏幕适配的处理技巧都有哪些?"></a>2.屏幕适配的处理技巧都有哪些?</h3><p>字体使用sp,使用dp，多使用match_parent，wrap_content，weight<br>图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。</p>
<h3 id="3-App启动崩溃异常捕捉"><a href="#3-App启动崩溃异常捕捉" class="headerlink" title="3.App启动崩溃异常捕捉"></a>3.App启动崩溃异常捕捉</h3><p>自定义一个应用异常捕获类AppUncaughtExceptionHandler，它必须得实现Thread.UncaughtExceptionHandler接口，另外还需要重写uncaughtException方法，去按我们自己的方式来处理异常</p>
<h3 id="4-平时如何有使用屏幕适配吗？原理是什么呢？"><a href="#4-平时如何有使用屏幕适配吗？原理是什么呢？" class="headerlink" title="4.平时如何有使用屏幕适配吗？原理是什么呢？"></a>4.平时如何有使用屏幕适配吗？原理是什么呢？</h3><p>平时的屏幕适配一般采用的头条的屏幕适配方案。简单来说，以屏幕的一边作为适配，通常是宽。</p>
<p>原理：设备像素px和设备独立像素dp之间的关系是</p>
<p>px = dp * density<br>假设UI给的设计图屏幕宽度基于360dp，那么设备宽的像素点已知，即px，dp也已知，360dp，所以density = px / dp，之后根据这个修改系统中跟density相关的知识点即可。</p>
<h3 id="5-屏幕适配的处理技巧都有哪些"><a href="#5-屏幕适配的处理技巧都有哪些" class="headerlink" title="5.屏幕适配的处理技巧都有哪些?"></a>5.屏幕适配的处理技巧都有哪些?</h3><p>字体使用sp,使用dp，多使用match_parent，wrap_content，weight<br>图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>工具使用</title>
    <url>/topic/topic_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-描述清点击-Android-Studio-的-build-按钮后发生了什么"><a href="#1-描述清点击-Android-Studio-的-build-按钮后发生了什么" class="headerlink" title="1.描述清点击 Android Studio 的 build 按钮后发生了什么"></a>1.描述清点击 Android Studio 的 build 按钮后发生了什么</h3><ol>
<li>通过aapt打包res资源文件，生成R.java、resources.arsc和res文件</li>
<li>处理.aidl文件，生成对应的Java接口文件</li>
<li>通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文</li>
<li>通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex</li>
<li>通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk</li>
<li>通过Jarsigner工具，对上面的apk进行debug或release签名</li>
<li>通过zipalign工具，将签名后的apk进行对齐处理。<br>这样就得到了一个可以安装运行的Android程序。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/topic/topic_%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-单例设计模式"><a href="#1-单例设计模式" class="headerlink" title="1.单例设计模式"></a>1.单例设计模式</h3><p>概念：</p>
<p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p>好处：</p>
<p>对于那些比较耗内存的类，只实例化一次可以大大的节约内存，尤其是在移动应用中。</p>
<p>代码（懒汉式）：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">private<span class="hljs-keyword"> static</span> RetrofitHelper instance;<br>   /**<br>   * 获取单例<br>        */<br>     <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> RetrofitHelper getInstance() &#123;<br>     <span class="hljs-built_in"> if </span>(null == instance) &#123;<br>          synchronized (RetrofitHelper.class) &#123;<br>             <span class="hljs-built_in"> if </span>(null == instance) &#123;<br>                 <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>RetrofitHelper();<br>              &#125;<br>          &#125;<br>      &#125;<br>     <span class="hljs-built_in"> return </span>instance;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>饿汉式：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>// 直接创建对象<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>// 私有化构造函数<span class="hljs-keyword"></span><br><span class="hljs-keyword">private</span> Singleton() &#123;<br>&#125;<br>// 返回对象实例<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> Singleton getInstance() &#123;<span class="hljs-built_in"></span><br><span class="hljs-built_in">return </span>instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现单例的步骤：</p>
<ol>
<li><p>防止外部通过构造方法对其实例化，所以构造方法必须私有化</p>
</li>
<li><p>定义一个静态函数获取该实例</p>
</li>
<li><p>单例使用volitle修饰，被volitle修改的变量是被禁止重排序的</p>
</li>
<li><p>使用syncnized进行同步处理，并且双重判断是否为null，第二次判空是为了防止多线程重复创建实例的（一个线程进入了该代码，如果另一个线程在等待，这时候前一个线程创建了一个实例出来完毕后，另一个线程获得锁进入该同步代码，实例已经存在，没必要再次创建，因此这个判断是否是null还是必须的）</p>
</li>
</ol>
<p>单例模式的应用：</p>
<p>初始化Android-Universal-Image-Loader，EventBus,Rxbus,ActivityManager 中</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/topic/topic_%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="1-App启动崩溃异常捕捉"><a href="#1-App启动崩溃异常捕捉" class="headerlink" title="1.App启动崩溃异常捕捉"></a>1.App启动崩溃异常捕捉</h3><p>自定义一个应用异常捕获类AppUncaughtExceptionHandler，它必须得实现Thread.UncaughtExceptionHandler接口，另外还需要重写uncaughtException方法，去按我们自己的方式来处理异常</p>
<h3 id="2-怎么预防程序奔溃"><a href="#2-怎么预防程序奔溃" class="headerlink" title="2.怎么预防程序奔溃"></a>2.怎么预防程序奔溃</h3><p>通常会想到try，catch</p>
<p>try，catch会增加内存开销，印象应用到性能，我们尽可能少用，当我们程序在正常运行当时候不会体现，一旦出现异常，会大大增加内存开销。那我们应该怎么做呢；</p>
<p>通常程序出现异常会有两个现象，1:程序闪退</p>
<p>1:UncaughtExceptionHandler自定义在Application中初始化，uncaughtException（）回调方法中捕捉异常信息进行上报保存</p>
<p>//将当前实例设为系统默认的异常处理器</p>
<p>Thread.setDefaultUncaughtExceptionHandler(<strong>this</strong>); </p>
<p>viewmodel</p>
<p>通过工厂模式创建出对应viewmodel的实例对象，并将对象保存到一个viewmodelStore中，viewmodelStore中有一个静态代码快，用来保存viewmodel，所以在横竖屏切换到时候数据不会丢失</p>
<p>lifecycle</p>
<p>lifecycle通过在activity中添加Fragment监听fragment到生命周期，在fragment到声明周期中调用一个dispatch()函数，在dispatch中会判断当前activity是否实现了LifecycleOwner接口，如果实现了该接口，就调用LifecycleRegister的handlerLifecycleEvent()，这样生命周期的状态就会借由LifecycleRegister通知给各个LifecycleObserver从而调用其中对应的Lifecycle.Event的方法，这种通过Fragment来感知Activity生命周期的方法其实在Glide的中也是有体现的。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>推送</title>
    <url>/topic/topic_%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h3 id="1-Android开发之MQTT的使用"><a href="#1-Android开发之MQTT的使用" class="headerlink" title="1.Android开发之MQTT的使用"></a>1.Android开发之MQTT的使用</h3><p><a href="https://blog.csdn.net/asjqkkkk/article/details/80714234">https://blog.csdn.net/asjqkkkk/article/details/80714234</a></p>
<h3 id="2-Android端实现消息推送的几种方式"><a href="#2-Android端实现消息推送的几种方式" class="headerlink" title="2.Android端实现消息推送的几种方式"></a>2.Android端实现消息推送的几种方式</h3><ol>
<li><p>轮询：客户端定时向服务器请求数据。伪推送。缺点：费电，费流量。</p>
</li>
<li><p>拦截短信消息。服务器需要向客户端发通知时，发送一条短信，客户端收到特定短信之后，先获取信息，然后拦截短信。伪推送。缺点：贵而且短信可能被安全软件拦截。</p>
</li>
<li><p>持久连接(Push)方式：客户端和服务器之间建立长久连接。真正的推送。</p>
</li>
</ol>
<p>Google的C2DM（Cloudto Device Messaging）。需要科学上网，国内大多数用户无法使用。</p>
<p>XMPP。XMPP(可扩展通讯和表示协议)是基于可扩展标记语言（XML）的协议。androidpn是一个基于XMPP协议的java开源Android push notification实现。它包含了完整的客户端和服务器端。</p>
<p>MQTT。MQTT是一个轻量级的消息发布/订阅协议，它是实现基于手机客户端的消息推送服务器的理想解决方案。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>服务保活</title>
    <url>/topic/topic_%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%B4%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>混合开发</title>
    <url>/topic/topic_%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="1-Flutter"><a href="#1-Flutter" class="headerlink" title="1.Flutter"></a>1.Flutter</h3><p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。<br>跨平台自绘引擎<br>Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。<br>Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。<br>目前Flutter默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。<br>高性能<br>Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销</p>
<h3 id="2-快应用"><a href="#2-快应用" class="headerlink" title="2.快应用"></a>2.快应用</h3><p>快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，目标直指微信小程序。它也是采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同：</p>
<p>快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。<br>React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。</p>
<h3 id="3-React-Native"><a href="#3-React-Native" class="headerlink" title="3.React Native"></a>3.React Native</h3><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。<br>由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：DOM树与响应式编程。<br>DOM树与控件树<br>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口，一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的标准接口。简单来说，DOM就是文档树，与用户界面控件树对应，在前端开发中通常指HTML对应的渲染树，但广义的DOM也可以指Android中的XML布局文件对应的控件树，而术语DOM操作就是指直接来操作渲染树（或控件树）， 因此，可以看到其实DOM树和控件树是等价的概念，只不过前者常用于Web开发中，而后者常用于原生开发中。<br>响应式编程<br>React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：<br>• 开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。<br>• React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。<br>值得注意的是，在第二步中，状态变化后React框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM中，而不是每次改变都去操作一下DOM。为什么不能每次改变都直接去操作DOM树？这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流：</p>
<p>如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。<br>如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。<br>而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。<br>上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。<br>JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：</p>
<p>为JavaScript提供运行环境。<br>是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。<br>而RN中将虚拟DOM映射为原生控件的过程中分两步：<br>布局消息传递； 将虚拟DOM布局信息传递给原生；<br>原生根据布局信息通过对应的原生控件渲染控件树；<br>至此，React Native 便实现了跨平台。 相对于混合应用，由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native使用了Web开发技术栈，也只需维护一份代码，同样是跨平台框架。<br>Weex<br>Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。</p>
<h3 id="4-Hybrid，weex，react-native，快应用，flutter了解吗？对比一下？"><a href="#4-Hybrid，weex，react-native，快应用，flutter了解吗？对比一下？" class="headerlink" title="4.Hybrid，weex，react native，快应用，flutter了解吗？对比一下？"></a>4.Hybrid，weex，react native，快应用，flutter了解吗？对比一下？</h3><p>H5+原生混合开发<br>这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（iOS）来加载（以后若无特殊说明，我们用WebView来统一指代android和iOS中的网页加载控件）。这样以来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，H5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发 ，采用混合模式开发的APP我们称之为混合应用或Hybrid APP ，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP 。<br>混合开发技术点<br>如之前所述，原生开发可以访问平台所有功能，而混合开发中，H5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。<br>混合应用的优点是动态内容是H5，web技术栈，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，WebView不堪重任</p>
<h3 id="5-Dart语言有研究过吗？"><a href="#5-Dart语言有研究过吗？" class="headerlink" title="5.Dart语言有研究过吗？"></a>5.Dart语言有研究过吗？</h3><p>Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）：</p>
<p>开发效率高 Dart运行时和编译器支持Flutter的两个关键特性的组合： 基于JIT的快速开发周期：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间； 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。<br>高性能 Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。<br>快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。<br>类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。<br>Dart团队就在你身边 看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。”</p>
<h3 id="6-Hybrid通信原理是什么，有做研究吗？"><a href="#6-Hybrid通信原理是什么，有做研究吗？" class="headerlink" title="6.Hybrid通信原理是什么，有做研究吗？"></a>6.Hybrid通信原理是什么，有做研究吗？</h3><p>Android与JS通过WebView互相调用方法，实际上是：<br>Android去调用JS的代码<br>通过WebView的loadUrl(),使用该方法比较简洁，方便。但是效率比较低，获取返回值比较困难。<br>通过WebView的evaluateJavascript(),该方法效率高，但是4.4以上的版本才支持，4.4以下版本不支持。所以建议两者混合使用。</p>
<p>JS去调用Android的代码<br>通过WebView的addJavascriptInterface（）进行对象映射 ，该方法使用简单，仅将Android对象和JS对象映射即可，但是存在比较大的漏洞。<br>漏洞产生原因是：当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。<br>解决方式：<br>(1)Google 在Android 4.2 版本中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击。<br>(2)在Android 4.2版本之前采用拦截prompt（）进行漏洞修复。<br>通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 。这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。(ios主要用的是这个方式)<br>(1)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url<br>(2)解析该 url 的协议<br>(3)如果检测到是预先约定好的协议，就调用相应方法<br>通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息<br>这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>源码分析</title>
    <url>/topic/topic_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1-Activity的启动流程源码分析"><a href="#1-Activity的启动流程源码分析" class="headerlink" title="1.Activity的启动流程源码分析"></a>1.Activity的启动流程源码分析</h3><p>第一阶段：当前Activity所在进程通知AMS启动Activity（当前Activity所在的进程）</p>
<ol>
<li>调用startActivity();，最终会调用startActivityForesult()，判断parentActivity是否为null，parentActivity指的是嵌套型的Activity，例如TabActivity、ActivityGroup等，在Android API13的时候已经废弃掉了，然后会调用Instrumentation.execStartActivity();主要是通过ActivityManagerNative.getDefault()获取到AMS的本地代理，然后通过这个本地代理通知AMS启动新的Activity。</li>
</ol>
<p>第二阶段：AMS收到启动Activit的通知，判断Activity是否正确，如果正确，暂存Activity信息，然后通过ApplicationThread通知launcher所在的进程pause调当前的activity。</p>
<p>第三阶段：launcher接收到这个通知后，还行pause操作，并通知AMS pause完成</p>
<p>第四阶段：AMS收到通知后，判断activity所在进程是否存在，如果不存在，则通过Socket通知Zygote进程创建进程。</p>
<p>第五阶段：创建ActivityThread，并做一些初始化的操作，然后绑定Application，如果Application还没有创建，则调用LoadedApk的makeApplication方法创建Application，之后进入Looper循环；并通知AMS启动新的Activity。</p>
<p>第六阶段：AMS收到通知后，调用ApplicationThread.scheduleLauncherActivity()接口，通知相应的进程执行启动Activity的操作。</p>
<p>第七阶段：ApplicationThread吧这个启动Activity的操作转发给ActivtiyThread，调用Instrumentation.newActivity()创建Activity实例，然后加载Activity类，并执行onCreate生命周期方法；</p>
<h3 id="2-App的启动流程源码分析"><a href="#2-App的启动流程源码分析" class="headerlink" title="2.App的启动流程源码分析"></a>2.App的启动流程源码分析</h3><p>一、从点击桌面的App图标开始：获取图标View的Tag值，并判断是否包含ShortCutInfo信息，如果包含的话，从tag中取到intent信息，并执行startActivitySafely();</p>
<p>二、最终会执行到Activity.startActivityForesult();</p>
<h3 id="3-apk的安装流程？"><a href="#3-apk的安装流程？" class="headerlink" title="3.apk的安装流程？"></a>3.apk的安装流程？</h3><p>四种安装方式：</p>
<ol>
<li>系统应用安装，没有安装界面，手机启动的时候自动安装</li>
<li>网络下载安装，没有安装界面，在应用商店安装</li>
<li>adb命令安装，没有安装界面，通过命令直接安装</li>
<li>外部设备安装，有安装界面，通过SD卡等外部设备来安装，通过PackageInstaller处理安装逻辑。</li>
</ol>
<p>安装流程：<br>（1）拷贝apk到指定的目录：默认情况下，用户安装的apk首先会拷贝到/data/app下，用户有访问/data/app目录的权限，但系统出厂的apk文件会被放到/system分区下，包括/system/app，/system/vendor/app，以及/system/priv-app等，该分区需要root权限的用户才能访问。<br>（2）加载apk、拷贝文件、创建应用的数据目录：为了加快APP的启动速度，apk在安装的时候，会首先将APP的可执行文件（dex）拷贝到/data/dalvik-cache目录下，缓存起来。再在/data/data/目录下创建应用程序的数据目录（以应用包名命令），用来存放应用的数据库、xml文件、cache、二进制的so动态库等。<br>（3）解析apk的AndroidManifest.xml文件：在安装apk的过程中，会解析apk的AndroidManifest.xml文件，将apk的权限、应用包名、apk的安装位置、版本、userID等重要信息保存在/data/system/packages.xml文件中。这些操作都是在PackageManagerService中完成<br>的。<br>（4）显示icon图标：应用程序经过PMS中的逻辑处理后，相当于已经注册好了，如果想要在Android桌面上看到icon图标，则需要Launcher将系统中已经安装的程序展现在桌面上。</p>
<h3 id="4-apk的打包流程？"><a href="#4-apk的打包流程？" class="headerlink" title="4.apk的打包流程？"></a>4.apk的打包流程？</h3><p>apk文件<br>apk文件其实就是一个压缩文件，把文件的后缀改成.zip就可以用windows解压软件解压了，解压之后的文件夹解释：<br>lib ：文件夹里面存放的是so动态链接库，so动态链接库是不需要在做apk打包时一系列压缩处理的。<br>META-INF ：签名文件夹，里面存放三个文件，有两个是对资源文件做的SHA1 hash处理，一个是签名和公钥证书。<br>res ：资源文件夹，里面还会分animator,anim,color,drawable,layout,menu和raw这几个文件夹。<br>AndroidManifest.xml AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。这个文件是很重要的，里面有我们的Android四大组件和申请的权限。<br>classes.dex Android平台上的可执行文件，Android虚拟机Dalvik支持的字节码文件格式Google在新发布的Android平台上使用了自己的Dalvik虚拟机来定义， 这种虚拟机执行的并非Java字节码， 而是另一种字节码： dex格式的字节码。在编译Java代码之后，通过Android平台上的工具可以将Java字节码转换成Dex字节码。虽然Google称Dalvik是为了移动设备定做的，但是业界很多人认为这是为了规避向sun申请Javalicense。这个DalvikVM针对手机程式/CPU做过最佳化，可以同时执行许多VM而不会占用太多Resource。classes.dex也是由java的class文件重新编排而来，我们也可以通过反编译工具把dex文件转换成class文件。如果做了拆包那么会有classes1.dex，classes2.dex …多个classes.dex文件。<br>resources.arsc 这个文件记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。我们可以将这个resources.arsc文件想象成是一个资源索引表，这个资源索引表在给定资源ID和设备配置信息的情况下，能够在应用程序的资源目录中快速地找到最匹配的资源。</p>
<p>打包工具：<br>aapt Android资源打包工具<br>aidl  Android接口描述语言转化为.java文件的工具<br>javac Java Compiler java代码转class文件<br>dex   转化.class文件为Davik VM能识别的.dex文件<br>apkbuilder 生成apk包<br>jarsigner   .jar文件的签名工具<br>zipalign   字节码对齐工具</p>
<p>打包流程：</p>
<ol>
<li>使用aapt来打包res资源文件，生成R.java、resources.arsc和res文件</li>
<li>处理aidl文件，生成相应的java文件</li>
<li>编译工程源代码，生成相应的class文件</li>
<li>转换所有的class文件，生成class.dex文件</li>
<li>打包生成apk文件</li>
<li>对apk文件进行签名</li>
<li>对签名后的apk文件进行对对齐处理<br>Zipalign是一个android平台上整理APK文件的工具，它对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。</li>
</ol>
<h3 id="5-OkHttp分析"><a href="#5-OkHttp分析" class="headerlink" title="5.OkHttp分析"></a>5.OkHttp分析</h3><p>Android API23(6.0)以后Google正式移除了 apache-HttpClient okhttp成为了它的替代品</p>
<p>okhttpClient功能特点：<br>1.支持SPDY 可以合并多个请求到同一个主机的请求、连接池、GZIP和HTTP缓存<br>2.支持HTTP/2协议，通过HTTP/2 可以让客户端中到服务器的所有请求共用同一个Socket连接<br>3.非HTTP/2 请求时， OkHttp内部会维护一个线程池，通过线程池可以对HTTP/1.x的连接进行复用，减少延迟<br>4.支持post,get请求，基于http的文件上传和下载<br>5.默认情况下，OkHttp会自动处理常见的网络问题，像二次连接、SSL的握手问题</p>
<p>使用流程：<br>1.创建一个OkHttpClient并实例化，可设置相关参数连接时长connectTimeout等<br>2.创建一个Request对象并实例化，可设置网络地址url，请求方式get,post，携带参数等；<br>3.创建一个Call对象，通过okhttpClient的newCall()方法将Request封装成Call对象<br>4.创建一个Response响应，用于接收服务器返回的相关信息；<br>   即OkHttpClient客户端通过newCall()方法接受你的Request请求并生成Response响应</p>
<p>请求流程：<br>同步<br>1.创建OkHttpClient和Request对象<br>2.将Request封装成Call对象<br>3.调用Call的excute()发起同步请求<br><em>特别注意</em>：当前线程发送同步请求后，就会进入阻塞状态，直到数据有响应才会停止(和异步最大的不同点)<br>异步<br>1.创建OkHttpClient和Request对象<br>2.将Request封装成Call对象<br>3.调用Call的enqueue发起异步请求<br><em>特别注意</em>： onFailure和onResponse都是执行在子线程中<br>区别：<br>1.发起请求方法调用<br>2.是否线程阻塞</p>
<p>底层实现：<br>同步请求：<br>在new okHttpClient时在内部通过构造器的方式初始化了一些配置参数，如连接/读写的超时时间，支持协议<br>定义了dispatcher：任务分发器（里面包含了一个线程池，用于执行异步请求操作），创建了三个双向任务队列，两个异步的，一个同步的。<br>一个是准备执行的异步请求队列，一个是正在执行的异步请求队列，另一个是正在执行的同步请求队列。由它决定异步请求在线程池中直接执行还是缓存等待。<br>创建了一个ConnectionPool连接池，里面包含了一个线程池，统一管理服务端与客户端建立的每一个Connection，作用就是：</p>
<p>1)当Connection的请求url相同时，可以选择是否复用。<br>2)控制Coonection保持打开状态</p>
<p>创建Builder<br>在Request.build模式下，指定默认请求方式为“Get”，创建了Headers内部类用于保存头部信息，<br>Request的构造方法其实就是指定了请求的方式，指定了请求的url，头部信息。</p>
<p>调用oKhttpclient.newCall方法封装Call对象，它的实现是RealCall，<br>从内部方法中可以看出Call对象就是之前封装好的OkHttpClient和Request对象，同时赋值给了RetryAndFollowUpInterCepter重定向拦截器，作用就是处理<br>请求错误和重定向。</p>
<p>调用exucte方法实现同步请求：<br>首先加入了synchronized同步锁，判断executed表示为是否为true，确保每个call只能被执行<br>一次不能重复执行，然后开启了evventListener监听，接收相应的事件回调，通过dispatcher<br>将call请求添加到同步队列中。<br>当请求执行完成后会执行finished方法将队列中的请求清除掉。</p>
<p>异步请求：<br>调用call.enqueue执行异步请求<br>这个方法内部的实现和同步的excute非常相似，都是先通过加synchronized同步锁防止请求重复执行，然后加入监听，最后执行相应的方法，但是唯一不同的是<br>同步请求之后会直接调用getResponseWithIntercepter方法回到结果，而异步请求是通过AnycCall进行回到请求结果的<br>这里的 AsyncCall 是 RealCall 的一个内部类，它继承于NamedRunnable抽象类，NamedRunnable抽象类又实现了 Runnable，<br>所以可以被提交到ExecutorService上执行，在execute方法里，我们看到了熟悉的流程,上文也说到getResponseWithInterceptorChain是一个拦截器链，<br>会依次执行相应的拦截器后返回数据，所以当返回数据后，通过retryAndFollowUpInterceptor重定向拦截器判断请求是否正常执行，<br>并且通过Callback接口返回相应数据信息，最后调用finished方法清除队列</p>
<h3 id="6-MediaCodec编解码："><a href="#6-MediaCodec编解码：" class="headerlink" title="6.MediaCodec编解码："></a>6.MediaCodec编解码：</h3><p># MediaCode编解码流程</p>
<p>王超:</p>
<p>mediecodec 编码，场景 ：我们从camera 获取原始数据，这里一般设置camera的输出数据格式是YUV数据，因为mediacodec在很多手机上只支持yuv数据的输入格式，google文档上的mediacodec也支持别的格式，但是由于手机厂商定制的原因吧，别的格式就不知道了，如raw，rgb等。</p>
<p>这里拿到camera的原始数据，我们就需要初始化mediacodec，配置mediecodec的编码方式，如h264、输入图像格式、帧率、码率，初始化成功后，可以从mediacodec中拿到他的输入队列和输出队列，这里的输入队列和输出队列是个队列，装载着一块一块的buffer缓存区。当要编码一帧数据时，从输入队列中取出一块buffer，把原始数据填充上去，在做一个入队操作也就是一个方法,好像是enqueue()。然后mediecodec内部就会去编码，编码完成的h264数据会放到输出队列中。然后取出来用就可以，但是这边 用完之后需要把这个输出的buffer调用一个releaseOutputBuffer方法，表示把取出的这块输出buffer继续放入输出队列中。如果不调用releaseOutputBuffer的话，会出现输出队列里的buffer全部被占用，那么有新的编码数据来了，发现输出队列中没有地方放了，就丢掉了。</p>
<p>王超:</p>
<p>对于音频编码aac，首先也是用mediaRecord去录音，拿到原始音频数据（也就是byte[]），配置mediacodec编码器，配置输出格式，如aac，码率、采样率44100、声道数等。配置完后也是拿到mediacodec的输入队列和输出队列，和视频的流程就是一样的了。</p>
<p>王超:</p>
<p>如果要合成mp4的话，就需要在面两个步骤都完成之后，拿到视频编码后的数据h264和音频编码后的数据aac。 首先需要创建一个mediaMuxer。指定输出格式为mp4，在传出输出的mp4文件的地址。mediamuxer的指责就是把一帧一帧的音频和视频进行混合，mediamuxer中，可以执行addTracker去添加音频轨道和视频轨道，之后视频帧就往视频轨道添加，音频帧就往音频轨道添加。那么怎么样去添加音频轨道和视频轨道呢？ 答案：addTracker需要一个MediaFormat参数，mediacodec输出队列的第一帧就是MediaFormat，即：音频mediacodec输出队列的第一帧获取到音频的mediaFormat，视频同理！addTracker（MediaFormat format）会返回一个int值，这个int值就是你的音频轨道audioIndex或者视频轨道videoIndex。在之后添加音频的时候，有了audioIndex和aac数据，直接添加就可以。视频同理！！结束的时候调用mediamuxer.stop（）本地就会生成完整的mp4视频文件。</p>
<h3 id="7-Binder机制"><a href="#7-Binder机制" class="headerlink" title="7.Binder机制"></a>7.Binder机制</h3><p>李岩：</p>
<p>直观的看，Binder是Android中的一个类，实现了IBinder接口</p>
<p>从IPC角度，Binder是跨进程通信方式</p>
<p>从应用层角度，Binder是客户端与服务端通信的媒介</p>
<p>Binder机制是采用C/S的通信模式。相比共享内存来说，Binder方便管理，相比管道来说，Binder少了一次内存拷贝，传输效率高，开销小。底层是利用进程间可共享的内核内存空间来完成底层通信工作的。</p>
<p>而一个进程分为用户空间和内核空间，用户空间进程间是不可以进行共享的，二内核空间是可以进行共享的。</p>
<p>Binder则是先通过进程间的内核空间进行数据交互，再通过进程内的用户空间&amp;内核空间进行数据交互，从而实现进程间的用户空间的数据共享。</p>
<p><img  src="https://docimg9.docs.qq.com/image/EQ--QhM-d-VO1GwHdwMoIg?w=650&h=378"  ><span class="image-caption">img</span></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>热修复/热更新</title>
    <url>/topic/topic_%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h3 id="1-热修复原理"><a href="#1-热修复原理" class="headerlink" title="1.热修复原理"></a>1.热修复原理</h3><p>我们知道Java虚拟机 —— JVM 是加载类的class文件的，而Android虚拟机——Dalvik/ART VM 是加载类的dex文件，<br>而他们加载类的时候都需要ClassLoader,ClassLoader有一个子类BaseDexClassLoader，而BaseDexClassLoader下有一个<br>数组——DexPathList，是用来存放dex文件，当BaseDexClassLoader通过调用findClass方法时，实际上就是遍历数组，<br>找到相应的dex文件，找到，则直接将它return。而热修复的解决方法就是将新的dex添加到该集合中，并且是在旧的dex的前面，<br>所以就会优先被取出来并且return返回。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>签名/打包</title>
    <url>/topic/topic_%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h3 id="1-请解释安卓为啥要加签名机制"><a href="#1-请解释安卓为啥要加签名机制" class="headerlink" title="1.请解释安卓为啥要加签名机制?"></a>1.请解释安卓为啥要加签名机制?</h3><p>发送者的身份认证：由于开发商可能通过使用相同的 Package Name 来混淆替换已经安装的程序，以此保证签名不同的包不被替换<br>保证信息传输的完整性：签名对于包中的每个文件进行处理，以此确保包中内容不被替换<br>防止交易中的抵赖发生：Market（应用市场）对软件的要求</p>
<h3 id="2-谈谈你对安卓签名的理解。"><a href="#2-谈谈你对安卓签名的理解。" class="headerlink" title="2.谈谈你对安卓签名的理解。"></a>2.谈谈你对安卓签名的理解。</h3><p>每个应用都必须签名<br>应用可以被不同的签名文件签名（如果有源代码或者反编译后重新编译）<br>同一个应用如果签名不同则不能覆盖安装</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>组件化/插件化</title>
    <url>/topic/topic_%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-组件化与模块化"><a href="#1-组件化与模块化" class="headerlink" title="1.组件化与模块化"></a>1.组件化与模块化</h3><p>组件化是指以重用化为目的，将一个系统拆分为一个个单独的组件避免重复造轮子，节省开发维护成本；<br>降低项目复杂性，提升开发效率；多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。<br>模块化业务分层：由下到上</p>
<p>基础组件层：<br>底层使用的库和封装的一些工具库（libs），比如okhttp,rxjava,rxandroid,glide等<br>业务组件层：<br>与业务相关，封装第三方sdk，比如封装后的支付，即时通行等<br>业务模块层：<br>按照业务划分模块，比如说IM模块，资讯模块等</p>
<h3 id="2-模块化实现（好处，原因）"><a href="#2-模块化实现（好处，原因）" class="headerlink" title="2.模块化实现（好处，原因）"></a>2.模块化实现（好处，原因）</h3><p>那么什么是模块化呢？</p>
<p>《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>为什么模块间解耦，复用？</p>
<p>原因：对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用。</p>
<p>为什么可单独编译某个模块，提升开发效率？</p>
<p>原因：每个模块实际上也是一个完整的项目，可以进行单独编译，调试</p>
<p>为什么可以多团队并行开发，测试？</p>
<p>原因：每个团队负责不同的模块，提升开发，测试效率</p>
<h3 id="3-插件化原理分析"><a href="#3-插件化原理分析" class="headerlink" title="3.插件化原理分析"></a>3.插件化原理分析</h3><p>插件化要解决的三个核心问题：类加载、资源加载、组件生命周期管理。<br>类加载：Android中常用的两种类加载器：PathClassLoader和DexClassLoader，它们都继承于BaseDexClassLoader。<br>DexClassLoader的构造函数比PathClassLoader多了一个，optimizedDirectory参数，这个是用来指定dex的优化产物odex的路径，在源码注释中，指出这个参数从API 26后就弃用了。<br>PathClassLoader主要用来加载系统类和应用程序的类，在ART虚拟机上可以加载未安装的apk的dex，在Dalvik则不行。<br>DexClassLoader用来加载未安装apk的dex。<br>资源加载：Android系统通过Resource对象加载资源，因此只需要添加资源（即apk文件）所在路径到AssetManager中，即可实现对插件资源的访问。由于AssetManager的构造方法时hide的，需要通过反射区创建。<br>组件生命周期管理：对于Android来说，并不是说类加载进来就可以使用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给他们注入活力，也就是所谓的组件生命周期管理。<br>在解决插件中组件的生命周期，通常的做法是通过Hook相应的系统对象，实现欺上瞒下，后面将通过Activity的插件化来进行讲解。</p>
<h3 id="4-组件化"><a href="#4-组件化" class="headerlink" title="4.组件化"></a>4.组件化</h3><p>模块化：根据不同的关注点，将一个项目的可以共享的部分抽出来，形成独立的Model，这就是模块化。模块化不只包含公共部分，当然也可以是业务模块。比如：图片加载模块</p>
<p>组件化：组件化是建立在模块化思想上的一次演进，一个变种，组件化本来就是模块化的概念。核心是模块角色的可转化性，在打包时候是library；调试时，是application。组件化的单位是组件，</p>
<p>注解：Annotation直白的解释为（想像代码具有生命，注解就是对于代码中某些鲜活个体贴上去的一张标签。简化来讲，注解如同一张标签）</p>
<p>自定义注解：用@interface声明，并需要使用元注解声明作用域和注解的生命周期；如下图:</p>
<p><img  src="https://docimg8.docs.qq.com/image/dl-p3VDshTURm8mmv3aJdQ?w=1670&h=968"  ><span class="image-caption">img</span></p>
<p>注解处理器：AbstracProcessor </p>
<p>Aroute框架原理：</p>
<p>1:通过在每个组件上添加注解@Aroute(path = “main/src/mainactivity”)</p>
<p>2:在编译时通过apt（注解处理器）对代码中对指定的注解进行解析，然后将对应的path和被注解标示的class类放入一个容器当中，并生成映射表，形成映射关系。</p>
<p>3:通过调用Aroute的build(path)方法，并传入path路径，Aroute就会去映射表中通过path寻找对应的映射文件，从而进行跳转，映射表类似与一张Map表，Map&lt;path,class&gt;</p>
<p>详细来讲Map映射表中会进行分组，详细如下图：</p>
<p><img  src="https://docimg7.docs.qq.com/image/Kdb24tOvpmN4YzbEA59U3w?w=1524&h=910"  ><span class="image-caption">img</span></p>
<p>Map&lt;path,Map&gt;:</p>
<p>path：路由地址，对于内部来讲，其实就是组名</p>
<p>Map&lt;path,class&gt;：路由表</p>
<p>path：详细路由地址</p>
<p>class：路由地址对应的class文件</p>
<p>为何会进行分组，在面对大型项目下，会有很多个路由地址，这样在存储起来比较混乱，查询比较耗时，从而进行分组，分组后，就可以理解为每个组件名称对应为组名，通过组名在映射表中查询对应的路由表，然后根据具体的路由地址寻找对应的class文件，从而进行跳转。</p>
<p>插件化：严格意义来讲，其实也是模块化的观念，将一个完整的工程，按业务划分为不同的插件，来化整为零，相互配合。插件化的单位是Apk（一个完成的应用）。可以实现apk的动态加加载，动态更新，比组件化更灵活。</p>
<p>gradle组件化配置：</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/topic/topic_%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-提到递归算法的三个定律是什么？"><a href="#1-提到递归算法的三个定律是什么？" class="headerlink" title="1.提到递归算法的三个定律是什么？"></a>1.提到递归算法的三个定律是什么？</h3><p>所有递归算法必须遵循三个规律</p>
<p>递归算法必须有一个基点<br>递归算法必须有一个趋向基点的状态变化过程<br>递归算法必须自我调用</p>
<h3 id="2-解释什么是递归算法？"><a href="#2-解释什么是递归算法？" class="headerlink" title="2.解释什么是递归算法？"></a>2.解释什么是递归算法？</h3><p>递归算法是一个解决复杂问题的方法，将问题分解成较小的子问题，直到分解的足够小，可以轻松解决问题为止。通常，它涉及一个调用自身的函数。</p>
<h3 id="3-解释什么是基数排序算法？"><a href="#3-解释什么是基数排序算法？" class="headerlink" title="3.解释什么是基数排序算法？"></a>3.解释什么是基数排序算法？</h3><p>基数排序又称“桶子法”，是通过比较数字将其分配到不同的“桶里”来排序元素的。它是线性排序算法之一。</p>
<h3 id="4-解释一个算法的最佳情况和最坏情况之间有什么区别？"><a href="#4-解释一个算法的最佳情况和最坏情况之间有什么区别？" class="headerlink" title="4.解释一个算法的最佳情况和最坏情况之间有什么区别？"></a>4.解释一个算法的最佳情况和最坏情况之间有什么区别？</h3><p>·最佳情况：算法的最佳情况解释为算法执行最佳的数据排列。例如，我们进行二分法检索，如果目标值位于正在搜索的数据中心，则这就是最佳情况，最佳情况时间复杂度为0。</p>
<p>·最差情况：给定算法的最差输入参考。例如快速排序，如果选择关键值的子列表的最大或最小元素，则会导致最差情况出现，这将导致时间复杂度快速退化到O（n2）。</p>
<h3 id="5-列出一些常用的加密算法？"><a href="#5-列出一些常用的加密算法？" class="headerlink" title="5.列出一些常用的加密算法？"></a>5.列出一些常用的加密算法？</h3><p>一些常用的加密算法是：</p>
<p>3-way<br>Blowfish<br>CAST<br>CMEA<br>GOST<br>DES 和Triple DES<br>IDEA<br>LOKI等等</p>
<h3 id="6-解释加密算法的工作原理？"><a href="#6-解释加密算法的工作原理？" class="headerlink" title="6.解释加密算法的工作原理？"></a>6.解释加密算法的工作原理？</h3><p>加密是将明文转换为称为“密文”的密码格式的过程。要转换文本，算法使用一系列被称为“键”的位来进行计算。密钥越大，创建密文的潜在模式数越多。大多数加密算法使用长度约为64到128位的固定输入块，而有些则使用流方法。</p>
<h3 id="7-解释如何查找链表是否有循环？"><a href="#7-解释如何查找链表是否有循环？" class="headerlink" title="7.解释如何查找链表是否有循环？"></a>7.解释如何查找链表是否有循环？</h3><p>要知道链表是否有循环，我们将采用两个指针的方法。如果保留两个指针，并且在处理两个节点之后增加一个指针，并且在处理每个节点之后，遇到指针指向同一个节点的情况，这只有在链表有循环时才会发生。</p>
<h3 id="8-解释什么是“哈希算法”，它们用于什么？"><a href="#8-解释什么是“哈希算法”，它们用于什么？" class="headerlink" title="8.解释什么是“哈希算法”，它们用于什么？"></a>8.解释什么是“哈希算法”，它们用于什么？</h3><p>“哈希算法”是一个哈希函数，它使用任意长度的字符串，并将其减少为唯一的固定长度字符串。它用于密码有效性、消息和数据完整性以及许多其他加密系统。</p>
<h3 id="9-解释插入排序算法的空间复杂度是多少？"><a href="#9-解释插入排序算法的空间复杂度是多少？" class="headerlink" title="9.解释插入排序算法的空间复杂度是多少？"></a>9.解释插入排序算法的空间复杂度是多少？</h3><p>插入排序是一种就地排序算法，这意味着它不需要额外的或仅需要少量的存储空间。对于插入排序，它只需要将单个列表元素存储在初始数据的外侧，从而使空间复杂度为O（1）。</p>
<h3 id="10-说明什么是Skip-list？"><a href="#10-说明什么是Skip-list？" class="headerlink" title="10.说明什么是Skip list？"></a>10.说明什么是Skip list？</h3><p>Skip list数据结构化的方法，它允许算法在符号表或字典中搜索、删除和插入元素。在Skip list中，每个元素由一个节点表示。搜索函数返回与key相关的值的内容。插入操作将指定的键与新值相关联，删除操作可删除指定的键。</p>
<h3 id="11-解释什么是堆排序？"><a href="#11-解释什么是堆排序？" class="headerlink" title="11.解释什么是堆排序？"></a>11.解释什么是堆排序？</h3><p>堆排序可以看成是选择排序的改进，它可以定义为基于比较的排序算法。它将其输入划分为未排序和排序的区域，通过不断消除最小元素并将其移动到排序区域来收缩未排序区域。</p>
<h3 id="12-解释是否可以使用二分法检索链表？"><a href="#12-解释是否可以使用二分法检索链表？" class="headerlink" title="12.解释是否可以使用二分法检索链表？"></a>12.解释是否可以使用二分法检索链表？</h3><p>由于随机访问在链表中是不可接受的，所以不可能到达O（1）时间的中间元素。因此，对于链表来说，二分法检索是不可以的（对顺序链表或排序后的链表是可以用的）。</p>
<h3 id="13-解释二分法检索如何工作？"><a href="#13-解释二分法检索如何工作？" class="headerlink" title="13.解释二分法检索如何工作？"></a>13.解释二分法检索如何工作？</h3><p>在二分法检索中，我们先确定数组的中间位置，然后将要查找的值与数组中间位置的值进行比较，若小于数组中间值，则要查找的值应位于该中间值之前，依此类推，不断缩小查找范围，直至得到最终结果。</p>
<h3 id="14-请问用于时间复杂度的符号类型是什么？"><a href="#14-请问用于时间复杂度的符号类型是什么？" class="headerlink" title="14.请问用于时间复杂度的符号类型是什么？"></a>14.请问用于时间复杂度的符号类型是什么？</h3><p>用于时间复杂度的符号类型包括：</p>
<p>Big Oh：它表示小于或等于目标多项式<br>Big Omega：它表示大于或等于目标多项式<br>Big Theta：它表示与目标多项式相等<br>Little Oh：它表示小于目标多项式<br>Little Omega：它表示大于目标多项式</p>
<h3 id="15-解释算法的时间复杂度？"><a href="#15-解释算法的时间复杂度？" class="headerlink" title="15.解释算法的时间复杂度？"></a>15.解释算法的时间复杂度？</h3><p>算法的时间复杂度表示程序运行完成所需的总时间，它通常用大O表示法来表示。</p>
<h3 id="16-解释什么是快速排序算法？"><a href="#16-解释什么是快速排序算法？" class="headerlink" title="16.解释什么是快速排序算法？"></a>16.解释什么是快速排序算法？</h3><p>快速排序算法能够快速排序列表或查询。它基于分割交换排序的原则，这种类型的算法占用空间较小，它将待排序列表分为三个主要部分：</p>
<p>小于Pivot的元素<br>枢轴元素Pivot（选定的比较值）<br>大于Pivot的元素</p>
<h3 id="17-请简单解释算法是什么？"><a href="#17-请简单解释算法是什么？" class="headerlink" title="17.请简单解释算法是什么？"></a>17.请简单解释算法是什么？</h3><p>算法是一个定义良好的计算过程，它将一些值作为输入并产生相应的输出值。简单来说，它是将输入转换为输出的一系列计算步骤。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>自定义view</title>
    <url>/topic/topic_%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    <content><![CDATA[<h3 id="1-getWidth-方法和getMeasureWidth-区别呢？"><a href="#1-getWidth-方法和getMeasureWidth-区别呢？" class="headerlink" title="1.getWidth()方法和getMeasureWidth()区别呢？"></a>1.getWidth()方法和getMeasureWidth()区别呢？</h3><p>首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p>
<h3 id="2-View的绘制原理"><a href="#2-View的绘制原理" class="headerlink" title="2.View的绘制原理"></a>2.View的绘制原理</h3><p>View的绘制从ActivityThread类中Handler的处理RESUME_ACTIVITY事件开始，在执行performResumeActivity之后，创建Window以及DecorView并调用WindowManager的addView方法添加到屏幕上，addView又调用ViewRootImpl的setView方法，最终执行performTraversals方法，依次执行performMeasure，performLayout，performDraw。也就是view绘制的三大过程。<br>measure过程测量view的视图大小，最终需要调用setMeasuredDimension方法设置测量的结果，如果是ViewGroup需要调用measureChildren或者measureChild方法进而计算自己的大小。<br>layout过程是摆放view的过程，View不需要实现，通常由ViewGroup实现，在实现onLayout时可以通过getMeasuredWidth等方法获取measure过程测量的结果进行摆放。<br>draw过程先是绘制背景，其次调用onDraw()方法绘制view的内容，再然后调用dispatchDraw()调用子view的draw方法，最后绘制滚动条。ViewGroup默认不会执行onDraw方法，如果复写了onDraw(Canvas)方法，需要调用 setWillNotDraw(false);清楚不需要绘制的标记。</p>
<h3 id="3-requestLayout，invalidate，postInvalidate区别与联系"><a href="#3-requestLayout，invalidate，postInvalidate区别与联系" class="headerlink" title="3.requestLayout，invalidate，postInvalidate区别与联系"></a>3.requestLayout，invalidate，postInvalidate区别与联系</h3><p>相同点：三个方法都有刷新界面的效果。<br>不同点：invalidate和postInvalidate只会调用onDraw()方法；requestLayout则会重新调用onMeasure、onLayout、onDraw。<br>调用了invalidate方法后，会为该View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递到ViewRootImpl中，最终触发performTraversals方法，进行开始View树重绘流程(只绘制需要重绘的视图)。<br>调用requestLayout方法，会标记当前View及父容器，同时逐层向上提交，直到ViewRootImpl处理该事件，ViewRootImpl会调用三大流程，从measure开始，对于每一个含有标记位的view及其子View都会进行测量onMeasure、布局onLayout、绘制onDraw。</p>
<h3 id="4-自定义View如何提供获取View属性的接口？"><a href="#4-自定义View如何提供获取View属性的接口？" class="headerlink" title="4.自定义View如何提供获取View属性的接口？"></a>4.自定义View如何提供获取View属性的接口？</h3><p>自定义属性的实现流程：<br>1.在values目录下定义一个attrs.xml ：在res/values/attr.xml中定义相关属性。<br>2.在对应的类文件里生成某些组件 ：在对应类的构造函数中通过 obtainStyledAttributes（）方法获得自定义属性的相关值<br>3.在layout布局文件里为这些属性赋值：在布局中添加为该自定义组件设置一个命名空间，并且相关属性赋值</p>
<h3 id="5-View绘制流程"><a href="#5-View绘制流程" class="headerlink" title="5.View绘制流程"></a>5.View绘制流程</h3><p>自定义控件：<br>1、组合控件。这种自定义控件不需要我们自己绘制，而是使用原生控件组合成的新控件。如标题栏。<br>2、继承原有的控件。这种自定义控件在原生控件提供的方法外，可以自己添加一些方法。如制作圆角，圆形图片。<br>3、完全自定义控件：这个View上所展现的内容全部都是我们自己绘制出来的。比如说制作水波纹进度条。<br>View的绘制流程：OnMeasure()——&gt;OnLayout()——&gt;OnDraw()<br>第一步：OnMeasure()：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。<br>第二步：OnLayout()：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。<br>第三步：OnDraw()：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；<br>⑤、还原图层（Layer）；⑥、绘制滚动条。</p>
<h3 id="6-View刷新机制"><a href="#6-View刷新机制" class="headerlink" title="6.View刷新机制"></a>6.View刷新机制</h3><p>通过ViewRootImpl的scheduleTraversals()进行界面的三大流程。<br>调用到scheduleTraversals()时不会立即执行，而是将该操作保存到待执行队列中。并给底层的刷新信号注册监听。当VSYNC信号到来时，会从待执行队列中取出对应的scheduleTraversals()操作，并将其加入到主线程的消息队列中。<br>主线程从消息队列中取出并执行三大流程: onMeasure()-onLayout()-onDraw()</p>
<h3 id="7-自定义View如何考虑机型适配"><a href="#7-自定义View如何考虑机型适配" class="headerlink" title="7.自定义View如何考虑机型适配"></a>7.自定义View如何考虑机型适配</h3><p>布局类建议：<br>合理使用warp_content，match_parent.<br>尽可能的是使用RelativeLayout<br>引入android的百分比布局。<br>针对不同的机型，使用不同的布局文<br>件放在对应的目录下，android会自动匹配。</p>
<p>Icon类建议：<br>尽量使用svg转换而成xml。<br>切图的时候切大分辨率的图，应用到布局当中。在小分辨率的手机上也会有很好的显示效果。<br>使用与密度无关的像素单位dp，sp</p>
<h3 id="8-invalidate和postInvalidate的区别及使用"><a href="#8-invalidate和postInvalidate的区别及使用" class="headerlink" title="8.invalidate和postInvalidate的区别及使用"></a>8.invalidate和postInvalidate的区别及使用</h3><p>1、postInvalidate() 方法在非 UI 线程中调用，通知 UI 线程重绘。<br>2、invalidate()方法在 UI 线程中调用，重绘当前 UI。Invalidate不能直接在线程中调用，因为他是违背了单线程模型：Android UI操作并不是线程安全的，并且这些操作必须在UI线程中调用。</p>
<h3 id="9-Requestlayout，onlayout，onDraw，DrawChild区别与联系"><a href="#9-Requestlayout，onlayout，onDraw，DrawChild区别与联系" class="headerlink" title="9.Requestlayout，onlayout，onDraw，DrawChild区别与联系"></a>9.Requestlayout，onlayout，onDraw，DrawChild区别与联系</h3><p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。 说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制 任何视图包括该调用者本身。<br>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)<br>调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法)<br>drawChild()去重新回调每个子视图的draw()方法</p>
<h3 id="10-View的绘制"><a href="#10-View的绘制" class="headerlink" title="10.View的绘制"></a>10.View的绘制</h3><ol>
<li>view的绘制流程 问到MeasureSpec</li>
</ol>
<p>a.View的绘制流程的从ViewRootImpl的performTraversals方法开始的，它经过measure,layout,draw三个过程才能将一个View绘制出来，其中mesaure是用来测量view的宽高，完成后可通过getMeasuredWidth/getMeasureHeight方法来获取View测量后的宽/高。layout用来确定view在父容器中的位置，完成后可通过getTop、getBotton、getLeft和getRight拿到View的四个定点坐标。而draw则负责将view绘制在屏幕上。 </p>
<p>b.performTraversals会依次调用performMeasure,performLayout,performDraw三个方法，这个三个方法会完成顶级View的mesuare,layout,draw这三大流程。其中，在performMeasure中会调用measure方法，在measure方法会调用onMeasure方法，在onmeasure方法中会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中，这样就完成了一次measure过程。紧接着子元素又重复刚才父容器的measure过程，这样就完成了整个view数的遍历。</p>
<p>c.performLayout和performDraw的传递流程是类似唯一一点不同的是，performdraw的传递过程是在draw方法通过diapatchDraw来实现的。</p>
<p>measure方法：</p>
<p>由于measure是final类型的，所以子类不能覆盖，但是onMeasure方法可以被重写，所以我们可以在onMeasure方法中重写测量设置View尺寸。onMeasure也是测量View的核心代码。在这个方法中测量流程是会判断如果父类传递过来的模式是否是MeasureSpec.UNSPECIFIED，如果是就会获取到最小建议值，如果不是有返回值AT_MOST或者EXACTLY模式，则设置父类传递 过来的大小。 然后调用setMeasuredDimension 方法进行存储大小。</p>
<p>layout方法：</p>
<p>a 判断当前是否正在执行动画，如果在执行动画，则等待动画执行完调用requestLayout，如果没有添加动画或者动画已经执行完了，则调用layout，也就是View的layout。</p>
<p>b. 在View的layout中设置view在父View中的位置，判断位置是都发生变化，是否需要重新进行排版布局，需要的话重新调用onLayout。</p>
<p>c. onLayout中，ViewGruop会遍历它里面的所有View然后调用每个view 的layout(l,t,r,b)方法进行位置设置</p>
<p>draw方法：</p>
<p>第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。</p>
<p>第三步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。</p>
<p>第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。</p>
<p>第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。</p>
<p>第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮</p>
<p>什么是MeasureSpec?</p>
<p>MeasureSpec是一个32位二进制的整数型，前面两位代表的是mode，后面30为代表的是size。View的MeasureSpec并不是父View独自决定，它是根据父View的MeasureSpec和子View的LayoutParems通过相应的规则转化决定的。</p>
<p>mode主要分为三类：</p>
<p>EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。</p>
<p>AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content</p>
<p>UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况）</p>
<p>3.postinvalidate和requestlayout区别</p>
<p>requestLayout方法是用来触发绘制流程，他会会一层层调用 parent 的requestLayout，一直到最上层也就是ViewRootImpl的requestLayout，这里也就是判断线程的地方了，最后会执行到performMeasure -&gt; performLayout -&gt; performDraw 三个绘制流程，也就是测量——布局——绘制。</p>
<p>invalidate：</p>
<p>view的invalidate不会导致ViewRootImpl的invalidate被调用，而是递归调用父view的invalidateChildInParent，直到ViewRootImpl的invalidateChildInParent，然后触发，会导致当前view被重绘,由于mLayoutRequested为false，不会导致onMeasure和onLayout被调用，而OnDraw会被调用</p>
<p>postInvalidate：</p>
<p>postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>网络请求</title>
    <url>/topic/topic_%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="1-TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？"><a href="#1-TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？" class="headerlink" title="1.TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？"></a>1.TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？</h3><p>TCP可靠：是因为可以做到数据包发送的有序、无差错和无重复。<br>流量控制：是通过滑动窗口实现的，因为发送发和接收方消息发送速度和接收速度不一定对等，所以需要一个滑动窗口来平衡处理效率，并且保证没有差错和有序的接收数据包。<br>拥塞控制：慢开始和拥塞避免、快重传和快恢复算法。这写算法主要是为了适应网络中的带宽而作出的调整。</p>
<h3 id="2-TCP和UDP有什么区别？"><a href="#2-TCP和UDP有什么区别？" class="headerlink" title="2.TCP和UDP有什么区别？"></a>2.TCP和UDP有什么区别？</h3><p>TCP：基于字节流、面向连接、可靠、能够进行全双工通信，除此以外，还能进行流量控制和拥塞控制，不过效率略低<br>UDP：基于报文、面向无连接、不可靠，但是传输效率高。<br>总的来说，TCP适用于传输效率要求低，准确性要求高或要求有连接。而UDP适用于对准确性要求较低，传输效率要求较高的场景，比如语音通话、直播等。</p>
<h3 id="3-TCP的四次挥手过程？"><a href="#3-TCP的四次挥手过程？" class="headerlink" title="3.TCP的四次挥手过程？"></a>3.TCP的四次挥手过程？</h3><p>大致意思就是：</p>
<p>Client：我要断开连接了<br>Server：我收到你的消息了<br>Server：我也要断开连接了<br>Client：收到你要断开连接的消息了<br>之后Client等待两个MSL(数据包在网络上生存的最长时间)，如果服务端没有回消息就彻底断开了。</p>
<h3 id="4-TCP的三次握手过程，为什么需要三次，而不是两次或者四次？"><a href="#4-TCP的三次握手过程，为什么需要三次，而不是两次或者四次？" class="headerlink" title="4.TCP的三次握手过程，为什么需要三次，而不是两次或者四次？"></a>4.TCP的三次握手过程，为什么需要三次，而不是两次或者四次？</h3><p>只发送两次，服务端是不知道自己发送的消息能不能被客户端接收到。 因为TCP握手是三次，所以此时双方都已经知道自己发送的消息能够被对方收到，所以，第四次的发送就显得多余了。</p>
<h3 id="5-HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？"><a href="#5-HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？" class="headerlink" title="5.HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？"></a>5.HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？</h3><p>过程和上图类似，依次获取证书，公钥，最后生成对称加密的钥匙进行对称加密。</p>
<p>对称加密可以保证加密效率，但是不能解决密钥传输问题；非对称加密可以解决传输问题，但是效率不高。</p>
<h3 id="6-SSL-TLS的握手过程？"><a href="#6-SSL-TLS的握手过程？" class="headerlink" title="6.SSL/TLS的握手过程？"></a>6.SSL/TLS的握手过程？</h3><p>这里借用《趣谈网络协议》的图片：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a751550e46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"   title="示例图片"><span class="image-caption">SSL/TLS</span></p>
<h3 id="7-HTTP和HTTPS有什么区别？"><a href="#7-HTTP和HTTPS有什么区别？" class="headerlink" title="7.HTTP和HTTPS有什么区别？"></a>7.HTTP和HTTPS有什么区别？</h3><p>简单来说，HTTP和HTTPS的关系是这样的</p>
<p>HTTPS = HTTP + SSL/TLS</p>
<p>区别如下： HTTP作用于应用层，使用80端口，起始地址是http://，明文传输，消息容易被拦截，串改。 HTTPS作用域传输层，使用443端口，起始地址是https://，需要下载CA证书，传输的过程需要加密，安全性高。</p>
<h3 id="8-HTTP-1-1-和HTTP-2有什么区别？"><a href="#8-HTTP-1-1-和HTTP-2有什么区别？" class="headerlink" title="8.HTTP 1.1 和HTTP 2有什么区别？"></a>8.HTTP 1.1 和HTTP 2有什么区别？</h3><p>HTTP 2.0基于HTTP 1.1，与HTTP 2.0增加了：</p>
<p>二进制格式：HTTP 1.1使用纯文本进行通信，HTTP 2.0使用二进制进行传输。<br>Head压缩：对已经发送的Header使用键值建立索引表，相同的Header使用索引表示。<br>服务器推送：服务器可以进行主动推送<br>多路复用：一个TCP连接可以划分成多个流，每个流都会分配Id，客户端可以借助流和服务端建立全双工进行通信，并且流具有优先级。</p>
<h3 id="9-HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？"><a href="#9-HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？" class="headerlink" title="9.HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？"></a>9.HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？</h3><p>HTTP协议是应用层的协议。</p>
<p>常见的HTTP状态码有：</p>
<p>类别    解释<br>1xx    请求已经接收，继续处理<br>2xx    服务器已经正确处理请求，比如200<br>3xx    重定向，需要做进一步的处理才能完成请求<br>4xx    服务器无法理解的请求，比如404，访问的资源不存在<br>5xx    服务器收到请求以后，处理错误</p>
<h3 id="10-断点续传"><a href="#10-断点续传" class="headerlink" title="10.断点续传"></a>10.断点续传</h3><p>基础知识：</p>
<p>Http基础：在Http请求中，可以加入请求头Range，下载指定区间的文件数。<br>RandomAccessFile：支持随机访问，可以从指定位置进行数据的读写。</p>
<p>有了这个基础以后，思路就清晰了：</p>
<p>通过HttpUrlConnection获取文件长度。<br>自己分配好线程进行制定区间的文件数据的下载。<br>获取到数据流以后，使用RandomAccessFile进行指定位置的读写。</p>
<h3 id="11-简述TCP，UDP，Socket"><a href="#11-简述TCP，UDP，Socket" class="headerlink" title="11.简述TCP，UDP，Socket"></a>11.简述TCP，UDP，Socket</h3><p>TCP是经过3次握手，4次挥手完成一串数据的传送<br>UDP是无连接的，知道IP地址和端口号，向其发送数据即可，不管数据是否发送成功<br>Socket是一种不同计算机，实时连接，比如说传送文件，即时通讯</p>
<h3 id="12-http通信方式"><a href="#12-http通信方式" class="headerlink" title="12.http通信方式"></a>12.http通信方式</h3><p>HttpURLConnection和HttpClient，HttpURLConnection多用于发送或接收流式数据，因此比较适合上传/下载文件，HttpClient相对来讲更大更全能，但是速度相对也要慢一点。在此只介绍HttpClient的通信流程：</p>
<p>HTTP的请求方式</p>
<p>1、OPTIONS</p>
<p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
<p>2、HEAD</p>
<p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>
<p>3、GET</p>
<p>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url</p>
<p>4、POST</p>
<p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p>
<p>5、PUT</p>
<p>向指定资源位置上传其最新内容</p>
<p>6、DELETE</p>
<p>请求服务器删除Request-URL所标识的资源</p>
<p>7、TRACE</p>
<p>回显服务器收到的请求，主要用于测试或诊断</p>
<p>8、CONNECT</p>
<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>Http是应用层协议，TCP是网络层协议，</p>
<p>我觉得区别从这两个连接的实现方式就可以看出来，HTTP连接需要指明资源的URL，发出请求的应用不知道服务器的IP，虽然域名服务器也是要把域名解析成IP地址，但不属于应用所关心的范畴，是网络层应该完成的工作。所以Http连接属于无状态的短连接，若再请求其他数据，需要再重新建立连接。客户端向服务器发送请求后，服务器才知道客户端的存在。</p>
<p>TCP连接实现时需要指明IP地址和端口号，就可以跟目的主机通过三次握手建立联系，该连接一直保持直到某一方提出取消连接，通过四次握手关闭连接。Socket支持TCP/UDP协议，如果使用TCP协议，那么socket连接就是TCP连接。论文提到的应用场景是手机与云端的服务器建立联系，因为要保持连接并指定连接的建立时间，所以在这种场景下使用TCP连接最合适。3G网络不支持端到端建立TCP连接，因为它是client-server模式，所以需要通过云端服务器的辅助来实现手机的端到端通信。</p>
<h3 id="13-Android-TCP通信"><a href="#13-Android-TCP通信" class="headerlink" title="13.Android TCP通信"></a>13.Android TCP通信</h3><p>TCP层是介于IP层和应用层的中间层</p>
<p>本质是通过Socket进行通信，服务端创建一个ServiceSocket，客户端创建一个Socket，两者通过Ip和端口进行连接，连接成功后，就酒交给IO流进行通信。</p>
<h3 id="14-谈谈对RxJava的理解"><a href="#14-谈谈对RxJava的理解" class="headerlink" title="14.谈谈对RxJava的理解"></a>14.谈谈对RxJava的理解</h3><p>RxJava：它是一个响应式的编程，区别于我们常用的应试编程，是一种观察者的设计模式，封装后是一个实现异步的操作库<br>响应式编程可以将数据和展示分层，很好的解耦，例如我们最常见的Buttom事件，设置监听事件，触发后回调<br>RxJava就是基于这种响应式的方式设计，在看看他是实现方式，有的人一开始会觉得它的代码好多，刚开始的时候我要注册，还要回调，主要你还是没有了解它的操作符的强大，操作符也是他的核心，你想用到的方法在里面都能找到，特别是当代码量多了之后，你会发现RxJava的代码看起来简洁，便于后期的维护<br>再说说它的操作符，常用的创建，交换，过滤这些就不说了，主要想说说它的错误操作符，它极大的简化了错误处理，便于我们后期维护排查<br>最后说说它的调度器，RxJava本身就是一个异步操作库，当我做一些耗时的操作时，往往会编写很多多线程，都知道多线程的编写和维护都是很烦的，RxJava很好的解决了这个鬼问题<br>好处：<br>Rx使代码简化<br>函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态<br>简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码<br>异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制<br>轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题</p>
<h3 id="15-Okhttp"><a href="#15-Okhttp" class="headerlink" title="15.Okhttp"></a>15.Okhttp</h3><p>OKHttp有哪些拦截器，分别起什么作用</p>
<p>Okhttp的拦截器是把所有的拦截器都放到一个list里，然后每次依次执行拦截器，并且在每个拦截器分为三部分：</p>
<p>①预处理拦截器内容</p>
<p>②通过proceed方法把请求交给下一个拦截器</p>
<p>③下一个拦截器处理完成并返回，后续处理工作。</p>
<p>addInterceptor(Interceptor)这是由开发者设置的，会按照开发者的要求，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加。</p>
<p>RetryAndFollowUpInterceptor，这里会对连接做一些初始化工作，以及请求失败的充实工作，重定向的后续请求工作。跟他的名字一样，就是做重试工作还有一些连接跟踪工作。</p>
<p>请求错误重试和从定向：</p>
<p>1、<em>HTTP_PROXY_AUTH</em> = 407 代理验证身份：client.proxyAuthenticator.authenticate 验证完成后，返回request</p>
<p>2、<em>HTTP_UNAUTHORIZED</em> = 401 client.authenticator.authenticate(route, userResponse)</p>
<p>3、<em>HTTP_CLIENT_TIMEOUT</em> = 408http超时： 返回原来的userResponse.request</p>
<p>4、<em>HTTP_UNAVAILABLE</em> = 503; 服务⽆效，如果http带有 Retry-After字段，没有延时处理执⾏， 字段取原来的</p>
<p>request</p>
<p>5、HTTP_MISDIRECTED_REQUEST= 421 ，连接被改变，重试</p>
<p>6、<em>HTTP_PERM_REDIRECT</em>, <em>HTTP_TEMP_REDIRECT</em>, <em>HTTP_MULT_CHOICE</em>, <em>HTTP_MOVED_PERM</em>, <em>HTTP_MOVED_TEMP</em>,</p>
<p><em>HTTP_SEE_OTHER</em> 这⼏个code，属于从定向的code，取response.header(localtion)从定向地址，从新构建request请求。</p>
<p>前五个是错误从试，第六个是重定向请求。 重试20次不成功，直接报错Too many follow-up requests ，回掉失败。</p>
<p>BridgeInterceptor，这里会为用户构建一个能够进行网络访问的请求，同时后续工作将网络请求回来的响应Response转化为用户可用的Response，比如添加文件类型，content-length计算添加，gzip解包。</p>
<p>CacheInterceptor，这里主要是处理cache相关处理，会根据OkHttpClient对象的配置以及缓存策略对请求值进行缓存，而且如果本地有了可⽤的Cache，就可以在没有网络交互的情况下就返回缓存结果。</p>
<p>ConnectInterceptor，这里主要就是负责建立连接了，会建立TCP连接或者TLS连接，以及负责编码解码的HttpCodec</p>
<p>networkInterceptors，这里也是开发者自己设置的，所以本质上和第一个拦截器差不多，但是由于位置不同，所以用处也不同。这个位置添加的拦截器可以看到请求和响应的数据了，所以可以做一些网络调试。</p>
<p>CallServerInterceptor，这里就是进行网络数据的请求和响应了，也就是实际的网络I/O操作，通过socket读写数据。</p>
<ol>
<li>OkHttp怎么实现连接池</li>
</ol>
<p>为什么需要连接池？</p>
<p>频繁的进行建立Socket连接和断开Socket是非常消耗网络资源和浪费时间的，所以HTTP中的keepAlive连接对于降低延迟和提升速度有非常重要的作用。keepAlive是什么呢？也就是可以在一次TCP连接中可以持续发送多份数据而不会断开连接。所以连接的多次使用，也就是复用就变得格外重要了，而复用连接就需要对连接进行管理，于是就有了连接池的概念。</p>
<p>OkHttp中使用ConectionPool实现连接池，默认支持5个并发KeepAlive，默认链路生命为5分钟。</p>
<p>1）首先，ConectionPool中维护了一个双端队列Deque，也就是两端都可以进出的队列，用来存储连接。</p>
<p>2）然后在ConnectInterceptor，也就是负责建立连接的拦截器中，首先会找可用连接，也就是从连接池中去获取连接，具体的就是会调用到ConectionPool的get方法。也就是遍历了双端队列，如果连接有效，就会调用acquire方法计数并返回这个连接。</p>
<p>3）如果没找到可用连接，就会创建新连接，并会把这个建立的连接加入到双端队列中，同时开始运行线程池中的线程，其实就是调用了ConectionPool的put方法。</p>
<p>4）这里有个问题，怎样属于空闲连接？</p>
<p>在RealConnection中，有一个StreamAllocation虚引用列表。每创建一个连接，就会把连接对应的StreamAllocationReference添加进该列表中，如果连接关闭以后就将该对象移除</p>
<p>5）连接池的工作就这么多，并不负责，主要就是管理双端队列Deque<RealConnection>。可以用的连接就直接用，然后定期清理连接，同时通过对StreamAllocation的引用计数实现自动回收</p>
<h3 id="16-简述-tcp-和-udp的区别？"><a href="#16-简述-tcp-和-udp的区别？" class="headerlink" title="16.简述 tcp 和 udp的区别？"></a>16.简述 tcp 和 udp的区别？</h3><ul>
<li><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</p>
</li>
<li><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</p>
</li>
<li><p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
</li>
<li><p>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
</li>
<li><p>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</p>
</li>
<li><p>TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/topic/topic_%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h3><p><a href="https://blog.csdn.net/qq_42758551/article/details/106265315">面试被问到 HashMap 有这一文就够了！</a></p>
<p><a href="https://blog.csdn.net/qq_42758551/article/details/106265370">面试一文搞定之ArrayList和LinkedList</a></p>
<h3 id="2-HashSet用过么？"><a href="#2-HashSet用过么？" class="headerlink" title="2.HashSet用过么？"></a>2.HashSet用过么？</h3><p>HashSet 的底层就是一个 HashMap ，HashSet 源码很少，大多直接调用调用了 HashMap 的实现。</p>
<p>和 HashMap 的区别：HashMap 实现了 Map 接口，存储键值对，其 hashcode 使用 Key进行计算；HashSet 实现了Set 接口，直接存储数据对象，使用成员对象计算 hashcode值。</p>
<p>HashSet 如何保证插入对象唯一：当元素插入时，先调用hash()方法计算插入对象的 hashcode值去得到对象加入的位置，同时会和集合中其他的对象的 hashcode 值进行比较，如果没有相同的 hashcode 值则说明对象没重复；如果 hashcode 值重复，这是会调用对象的equals()方法来检查 hashcode 相同的对象是否真的相同，最终相同则插入失败，否则成功。</p>
<h3 id="3-说HashTable、HashMap"><a href="#3-说HashTable、HashMap" class="headerlink" title="3.说HashTable、HashMap ?"></a>3.说HashTable、HashMap ?</h3><p>HashMap 是非线程安全的，而 HashTable 是线程安全的，HashTable 内的方法大多都经过synchronized修饰；因为线程安全的问题上的处理，导致 HashMap 效率要略高于 HashTable ；并且 HashTable 已经是基本被淘汰的方案了！<br>HashMap 中允许存在一个为 null 的 key (value 可以有多个 null)，但是如果向 HashTable 中 put 一个为 null 的 key，会直接抛出 NullPointerException 。<br>HashTable 的默认初始容量大小是 11，HashMap 的默认初始容量大小是 16；如果创建时指定初始容量，HashTable 会直接使用指定的容量，HashMap 会将指定容量扩充为一个 2 的幂大小。(具体原因，在正文会进行分析)<br>JDK1.8 之后 HashMap 当链表长度大于阈值(默认 8 )时，先检查当前数组数组的长度，数组长度小于 64 则先进行数组扩容，否则转换为红黑树，以减少 Hash 冲突从而减少搜索时间。HashTable 没有这个机制。</p>
<h3 id="4-ConcurrentHashMap的原理"><a href="#4-ConcurrentHashMap的原理" class="headerlink" title="4.ConcurrentHashMap的原理"></a>4.ConcurrentHashMap的原理</h3><p>数据结构的实现跟HashMap一样，不做介绍。</p>
<p>JDK 1.8之前采用的是分段锁，核心类是一个Segment，Segment继承了ReentrantLock，每个Segment对象管理若干个桶，多个线程访问同一个元素的时候只能去竞争获取锁。</p>
<p>JDK 1.8采用了CAS + synchronized，插入键值对的时候如果当前桶中没有Node节点，使用CAS方式进行更新，如果有Node节点，则使用synchronized的方式进行更新。</p>
<h3 id="5-HashMap机制"><a href="#5-HashMap机制" class="headerlink" title="5.HashMap机制"></a>5.HashMap机制</h3><p>HashMap是无序且不安全的数据结构，HashMap是以key–value键值对的形式存储的，key值是唯一的（可以为null），一个key只能对应着一个value，但是value是可以重复的。HashMap如果再次添加相同的key值，它会覆盖key值所对应的内容，</p>
<p>JDK7与JDK8的HashMap区别:</p>
<p>jdk8中添加了红黑树，当链表长度大于等于8的时候链表会变成红黑树,链表新节点插入链表的顺序不同（jdk7是插入头结点，jdk8因为要把链表变为红黑树所以采用插入尾节点）,hash算法简化 ( jdk8 ),resize的逻辑修改（jdk7会出现死循环，jdk8不会）</p>
<p>为什么HashMap的默认负载因子是0.75，而不是0.5或者是整数1呢？</p>
<p>阈值(threshold) = 负载因子(loadFactor) x 容量(capacity) 根据HashMap的扩容机制，他会保证容量(capacity)的值永远都是2的幂 为了保证负载因子x容量的结果是一个整数，这个值是0.75(4/3)比较合理，因为这个数和任何2的次幂乘积结果都是整数。</p>
<p>理论上来讲，负载因子越大，导致哈希冲突的概率也就越大，负载因子越小，费的空间也就越大,这是一个无法避免的利弊关系，所以通过一个简单的数学推理，可以测算出这个数值在0.75左右是比较合理的</p>
<p>HashMap扩容:</p>
<p>1、首先会判断table数组长度，如果大于0说明已被初始化过，那么按当前table数组长度的2倍进行扩容，阈值也变为原来的2倍</p>
<p>2、若table数组未被初始化过，且threshold(阈值)大于0说明调用了 HashMap(initialCapacity, loadFactor)构造方法，那么就把数组大小设为threshold</p>
<p>3、若table数组未被初始化，且threshold为0说明调用HashMap()构造方法，那么就把数组大小设为16,threshold设为16*0.75</p>
<p>4、接着需要判断如果不是第一次初始化，那么扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去，如果节点是红黑树类型的话则需要进行红黑树的拆分。</p>
<p>链表树化:</p>
<p>链表长度大于等于8</p>
<p>table数字长度大于等于64（因为当table数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。）</p>
<p>Map插入:</p>
<ol>
<li>当table数组为空时，通过扩容的方式初始化table</li>
<li>通过计算键的hash值求出下标后，若该位置上没有元素（没有发生hash冲突），则新建Node节点插入</li>
<li>若发生了hash冲突，遍历链表查找要插入的key是否已经存在，存在的话根据条件判断是否新值替换旧值</li>
<li>如果不存在，则将元素插入链表尾部，并根据链表长度决定是否将链表转为红黑树</li>
<li>判断键值对数量是否大于等于阈值，如果是的话进行扩容。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>面试经历</title>
    <url>/topic/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h3 id="山东百盟："><a href="#山东百盟：" class="headerlink" title="山东百盟："></a>山东百盟：</h3><p>1:ArrayList如何实现线程安全</p>
<p>2:主线程的Looper在哪创建，在哪开启loop循环的</p>
<p>3:synchronized 和volatile区别</p>
<p>4:sleep和wait区别</p>
<p>5:GreenDao中主键ID在JavaBean中数据类型</p>
<p>6:synchronized（Object和Class）的区别</p>
<p>7:一个apk中可以有几个进程，怎么操作？</p>
<p>8:跨进程如何访问sp文件</p>
<h3 id="安居客"><a href="#安居客" class="headerlink" title="安居客"></a>安居客</h3><p>1:组件化如何实现的</p>
<p>2:Arouter原理；Arouter的拦截器</p>
<p>3:Retrofit的注解和Arouter注解的区别</p>
<p>4:Activity启动流程</p>
<p>5:Rxjava的线程切换原理</p>
<p>6:kotlin用过吗；协程的原理以及使用方式</p>
<p>7:kotlin中的////函数了解过吗</p>
<p>8:kotlin中的协程原理</p>
<p>9:Handler机制；Handler中的同步消息和异步消息</p>
<p>10:Jetpack用过吗；LiveData实现原理</p>
<p>11:单向链表中有环吗？</p>
<p>12:如何实现单向链表反转，要求空间复杂度为o1</p>
<h3 id="尚德（1面）"><a href="#尚德（1面）" class="headerlink" title="尚德（1面）"></a>尚德（1面）</h3><p>1:项目的组件化是如何实现的；怎么搭建的；都有什么模块或者组件</p>
<p>2:Arouter中A模块需要向B模块传递JavaBean如何操作</p>
<p>3:AsyanTask实现原理，在自线程中可以直接使用AsynkTask吗，为什么</p>
<p>4:Handler的实现原理；在自线程中能否使用Handler</p>
<p>5:View的事件分发机制；</p>
<p>6:在子View中如何实现滑动的时候不消费该事件</p>
<p>7:Volite是什么</p>
<p>8:单例的创建有几种方式；平时都用的哪种方式；口述双重锁的实现代码；双重判空的作用</p>
<p>9:HashMap的实现原理；在JDK1.8中为什么加入红黑树；加入红黑树的优缺点</p>
<p>10:算法；给定一个数组，在给定一个数n；怎么找到数组中的这两个数（要求时间复杂度为0）</p>
<p>11:Jetpack的使用；livedata，viewmodel，lifecycle的原理（ViewModel为什么在横竖屏切换的时候不会数据丢失）</p>
<h3 id="（2面）"><a href="#（2面）" class="headerlink" title="（2面）"></a>（2面）</h3><p>1:A；B；C；D四个Activity；A启动B；B启动C；C启动D。如何实现AB在一个栈，CD在一个栈</p>
<p>2:了解多进程吗，如何实现多进程</p>
<p>3:VIew的分发机制，在一个LinearLayout中，有一个TextView在左上角，右下角有一个Button；使用属性动画将Textview移动到右下角；这时候Textview会显示在Button之上，问这时候点击Textview会响应吗；为什么？这个事件是如何分发到，子view位置改变后，父VIew是如何感知的？</p>
<p>4:View的onLayout方法是干嘛的，特别是单一view的onLayout；是空实现吗？</p>
<p>5:数据库什么什么什么一个SQL语句，忘记了。。。</p>
<p>6:在组件化中；随着项目越来越大，公共模块中引用的sdk和三方库也越来越多，那么公共模块也会越来越大，这样随之我们的业务模块编译也会变慢，这么解决</p>
<p>好像就这么多，其他的忘记了</p>
<h3 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a>猎豹移动</h3><p>1:Activity-Window-View的层级关系，这么嵌套的</p>
<p>2:PhoneWindow在哪；他是继承还是实现Window；在哪创建的</p>
<p>3:知道WindowManager吗</p>
<p>4:Handler中的Message如何创建，用完后就直接回收了吗；Handler中的消息队列中没有消息的时候；looper一直循环，为什么不会造成卡死，在调用了nativepollonce后做了什么</p>
<p>5:知道消息屏障吗</p>
<p>6:锁；volite，sync（锁的生命周期）</p>
<p>7:多线程操作list会出现什么情况，如何解决</p>
<p>8:hashmap原理，什么是红黑树，</p>
<p>9:jvm内存模型；虚拟机栈干什么的</p>
<p>10:GC机制；GC算法</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>音视频</title>
    <url>/topic/topic_%E9%9F%B3%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h3 id="1-播放音频有哪几种方式-？"><a href="#1-播放音频有哪几种方式-？" class="headerlink" title="1.播放音频有哪几种方式 ？"></a>1.播放音频有哪几种方式 ？</h3><p>一、MediaPlayer播放音频</p>
<p>支持的格式有：AAC、AMR、FLAC、MP3、MIDI、OGG、PCM等格式</p>
<p>不足：资源占用量较高、延迟时间较长、不支持多个音频同时播放等</p>
<p>二、SoundPool播放音频</p>
<p>SoundPool支持多个音频文件同时播放(组合音频也是有上限的)，延时短，比较适合短促、密集的场景，是游戏开发中音效播放的福音。</p>
<p>三、AudioTrack播放音频</p>
<p>特点：</p>
<p>\1. 更偏向底层的播放方式。</p>
<p>\2. 不支持多个音频同时播放，与MediaPlayer相比具有精炼、高效的特点。</p>
<p>\3. 用于播放PCM无压缩音频格式的音乐流。如果需要播放其它格式的音频，需要响应解码器。这也是AudioTrack用的比较少的原因，主要自己解码音频。</p>
<p>两种播放方式：</p>
<p><strong>静态模式—static</strong></p>
<p>静态的言下之意就是数据一次性交付给接收方。好处是简单高效，只需要进行一次操作就完成了数据的传递;缺点当然也很明显，对于数据量较大的音频回放，显然它是无法胜任的，因而通常只用于播放铃声、系统提醒等对内存小的操作</p>
<p><strong>流模式streaming</strong></p>
<p>流模式和网络上播放视频是类似的，即数据是按照一定规律不断地传递给接收方的。理论上它可用于任何音频播放的场景，不过我们一般在以下情况下采用：</p>
<ol>
<li>音频</li>
</ol>
<p>文件过大</p>
<ol start="2">
<li><p>音频属性要求高，比如采样率高、深度大的数据</p>
</li>
<li><p>音频数据是实时产生的，这种情况就只能用流模式了</p>
</li>
</ol>
<p>下面是三者的使用场景：</p>
<p>MediaPlayer 更加适合在后台长时间播放本地音乐文件或者在线的流式资源; </p>
<p>SoundPool 则适合播放比较短的音频片段，比如游戏声音、按键声、铃声片段等等，它可以同时播放多个音频; </p>
<p>AudioTrack 则更接近底层，提供了非常强大的控制能力，支持低延迟播放，适合流媒体和VoIP语音电话等场景。</p>
<h3 id="2-录制音频有哪几种方式-？"><a href="#2-录制音频有哪几种方式-？" class="headerlink" title="2.录制音频有哪几种方式 ？"></a>2.录制音频有哪几种方式 ？</h3><p>一、使用AudioRecord 或者 MediaRecord </p>
<p>区别：</p>
<p>AudioRecord 更加偏向底层，录制的音频文件是pcm格式的，不能直接使用系统自带的播放器播放，需要配合使用AudioTrack来播放。</p>
<p>MediaRecord 更加偏向上层，录制的音频是MP3/wav格式的，可以直接使用系统自带的播放器播放。在用MediaRecorder进行录制音视频时，最终还是会创建AudioRecord用来与AudioFlinger进行交互。</p>
<h3 id="3-绘制图片的三种方式-？"><a href="#3-绘制图片的三种方式-？" class="headerlink" title="3.绘制图片的三种方式 ？"></a>3.绘制图片的三种方式 ？</h3><ol>
<li><p>通过ImageView直接加载</p>
</li>
<li><p>通过SurfaceView绘制</p>
</li>
<li><p>自定义View绘制</p>
</li>
</ol>
<h3 id="4-视频加密传输"><a href="#4-视频加密传输" class="headerlink" title="4.视频加密传输"></a>4.视频加密传输</h3><p>DES加密。用java中提供的加密包。<br>将视频文件的数据流前100个字节中的每个字节与其下标进行异或运算。解密时只需将加密过的文件再进行一次异或运算即可。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Android11适配</title>
    <url>/study/Android11%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<p>安卓更新换代非常快，5.0之前版本更新的时间线有点看不懂，但5.0之后更新还是比较稳定的，大概一年更新一次，谷歌工程师对安卓每个版本的命名也有点意思，比如棒棒糖、棉花糖、奥利奥、馅饼啊啥的（命名的应该也是个吃货），还有，从1.5开始，之后的版本都按照英文字母顺序排列，从C开始，到现在的11排到了R。</p>
<p>2019年5月8日，谷歌在Google I/O 2019开发者大会上，正式公布了安卓10系统。经过数月的Beta版测试，谷歌又于2019年9月4日，推送了安卓10正式版。</p>
<p>从谷歌推出安卓10到现在也快一年的时间了，好多应用还没有适配，但现在安卓11的开发者预览版已经出来了，本来应该在今年的I/O大会上发布正式版安卓11的，但是由于疫情影响，3月21日发布消息，受新冠肺炎疫情影响，谷歌周五宣布彻底取消一年一度的I/O开发者大会，此前该公司在3月3日宣布，由于受到新冠病毒疫情的影响，将把I/O大会改为仅在线上举行，但现在线上大会也被取消了。</p>
<p>虽然今年I/O大会不开了，但是安卓11肯定要发布的，所以开发人员也别想跑，也需要适配啊！</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>“大哥，你这说了半天安卓11的适配在哪呢？”</p>
<p>“别着急啊，下面不是就要说了嘛！”</p>
<p>“快说，再白活会就取关了！”</p>
<p>“这就来这就来，哎！如果你有Pixel，那么恭喜你可以直接通过刷OTA的方式来体验和提前适配安卓11。“</p>
<p>”没有？跟我一样来使用模拟器吧！“</p>
<p>“什么？不知道怎么配置？真的是，给你说下吧，记好了。”</p>
<ol>
<li><p>在 Android Studio 中，依次点击 <strong>Tools &gt; SDK Manager</strong>。</p>
</li>
<li><p>在 <strong>SDK Platforms</strong> 标签页下，选择窗口底部的 <strong>Show Package Details</strong>。</p>
</li>
<li><p>在 <strong>Android 11 Developer Preview</strong> 下，选择系统映像（例如 <strong>Google APIs Intel x86 Atom System Image</strong>）。</p>
</li>
<li><p>在 <strong>SDK Tools</strong> 标签页中，选择最新版 <strong>Android 模拟器</strong>，点击 <strong>OK</strong> 开始安装。</p>
</li>
<li><p>安装完成后，依次选择 <strong>Tools &gt; AVD Manager</strong>，然后按照说明创建新的 AVD。</p>
<p>请务必选择 Pixel 设备，并对系统映像选择 <strong>R</strong>。</p>
</li>
<li><p>返回 AVD 管理器的虚拟设备列表，双击新虚拟设备即可启动该设备。</p>
</li>
</ol>
<p>“万事俱备，只欠适配了！”</p>
<p>这里就不写刷OTA的具体步骤了，需要的可以自行下载和刷写。</p>
<p><a href="https://developer.android.google.cn/preview/download#flash">https://developer.android.google.cn/preview/download#flash</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>“来了来了，开始了，别说话了，安静！！！”</p>
<h3 id="分区存储"><a href="#分区存储" class="headerlink" title="分区存储"></a><strong>分区存储</strong></h3><p>还记得在适配安卓10的时候设置requestLegacyExternalStorage为true来修改外部存储空间视图模型（true为 Legacy View，false 为 Filtered View）吗？这是重点：<strong>当您将应用更新为以 Android 11 为目标平台后，将无法使用</strong> <strong><code>requestLegacyExternalStorage</code> 来停用分区存储。</strong></p>
<p>“大哥，这都停用了那我该怎么适配呢？”</p>
<p>“这孩子，猴急猴急的，这不就要说了嘛！”</p>
<h4 id="数据迁移到使用分区存储时可见的目录："><a href="#数据迁移到使用分区存储时可见的目录：" class="headerlink" title="数据迁移到使用分区存储时可见的目录："></a>数据迁移到使用分区存储时可见的目录：</h4><p>在以 Android 11 为目标平台之前，应将数据迁移到与分区存储兼容的目录。在大多数情况下，可以将数据迁移到应用的应用专用目录。</p>
<p>如果有要迁移的数据，当用户升级到以 Android 11 为目标平台的新版应用时，可以保留旧版存储模型。这样，用户就可以保留对应用之前用来保存数据的目录中存储的应用数据的访问权限。要启用旧版存储模型以进行升级，请在应用的清单中将 <code>requestLegacyExternalStorage</code> 属性设为 <code>true</code>。</p>
<p>这里需要注意以下两点：</p>
<ul>
<li>大多数应用都不需要使用 <code>preserveLegacyExternalStorage</code>。此标记仅适用于这样一种情况：你将应用数据迁移到了与分区存储兼容的位置，并且希望用户在更新你应用时保留对数据的访问权限。使用此标记会导致更难以测试分区存储对应用的用户有何影响，因为当用户更新应用时，它会继续使用旧版存储模型。</li>
<li>如果使用 <code>preserveLegacyExternalStorage </code>，则旧版存储模型只在用户卸载应用之前保持有效。如果用户在搭载 Android 11 的设备上安装或重新安装应用，则无论 <code>preserveLegacyExternalStorage</code>的值是什么，应用都无法停用分区存储模型。</li>
</ul>
<h4 id="测试分区存储"><a href="#测试分区存储" class="headerlink" title="测试分区存储"></a>测试分区存储</h4><p>如果要在应用中启用分区存储，而不考虑应用的目标 SDK 版本和清单标记值，请启用以下应用兼容性标记：</p>
<ul>
<li><code>DEFAULT_SCOPED_STORAGE</code>（默认情况下，对所有应用处于启用状态）</li>
<li><code>FORCE_ENABLE_SCOPED_STORAGE</code>（默认情况下，对所有应用处于停用状态）</li>
</ul>
<p>要<strong>停用</strong>分区存储而改用旧版存储模型，请<strong>取消设置</strong>这两个标记。</p>
<h3 id="管理设备存储空间"><a href="#管理设备存储空间" class="headerlink" title="管理设备存储空间"></a><strong>管理设备存储空间</strong></h3><p>如果你的应用是文件管理器应用并且在 Android 11 上运行，它就不能再删除其他应用的缓存文件，即使您的应用具有所有文件访问权限也是如此（清理文件的应用尤其需要注意，比如某某<strong>管家、卫士</strong>啥的）。相反，你应执行以下操作：</p>
<ol>
<li>通过调用 <code>ACTION_MANAGE_STORAGE</code> intent 操作来检查可用空间。</li>
<li>如果设备上的可用空间不足，请提示用户同意让您的应用清除所有缓存。为此，请调用 <code>ACTION_CLEAR_APP_CACHE</code> intent 操作。</li>
</ol>
<p>这里需要注意：<code>ACTION_CLEAR_APP_CACHE</code> intent 操作会<strong>严重影响设备的电池续航时间</strong>，并且可能会从设备上<strong>移除大量的文件</strong>。</p>
<h3 id="媒体文件访问权限"><a href="#媒体文件访问权限" class="headerlink" title="媒体文件访问权限"></a><strong>媒体文件访问权限</strong></h3><p>这个很赞，Android 11 增加了以下访问媒体功能。</p>
<h4 id="执行批量操作"><a href="#执行批量操作" class="headerlink" title="执行批量操作"></a>执行批量操作</h4><p>为实现各种设备之间的一致性并增加用户便利性，Android 11 向 <code>MediaStore</code> API 中添加了多种方法。对于希望简化特定媒体文件更改流程（例如在原位置编辑照片）的应用而言，这些方法尤为有用。</p>
<ul>
<li><p>[<code>createWriteRequest()</code>]<br><a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createDeleteRequest">https://developer.android.google.cn/reference/android/provider/MediaStore#createDeleteRequest</a><br>(android.content.ContentResolver, java.util.Collection))</p>
<p>用户向应用授予对指定媒体文件组的写入访问权限的请求。</p>
</li>
<li><p>[<code>createFavoriteRequest()</code>]<br><a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createFavoriteRequest">https://developer.android.google.cn/reference/android/provider/MediaStore#createFavoriteRequest</a><br>(android.content.ContentResolver, java.util.Collection, boolean))</p>
<p>用户将设备上指定的媒体文件标记为“收藏”的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为“收藏”。</p>
</li>
<li><p>[<code>createTrashRequest()</code>]<br><a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createTrashRequest">https://developer.android.google.cn/reference/android/provider/MediaStore#createTrashRequest</a><br>(android.content.ContentResolver, java.util.Collection, boolean))</p>
<p>用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。</p>
</li>
<li><p>[<code>createDeleteRequest()</code>]<br><a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createWriteRequest">https://developer.android.google.cn/reference/android/provider/MediaStore#createWriteRequest</a><br>(android.content.ContentResolver, java.util.Collection))<br>用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</p>
</li>
</ul>
<p>系统在调用以上任何一个方法后，会构建一个 <code>PendingIntent</code> 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。</p>
<h4 id="使用原始路径访问文件"><a href="#使用原始路径访问文件" class="headerlink" title="使用原始路径访问文件"></a>使用原始路径访问文件</h4><p>从 Android 11 开始，具有 <code>READ_EXTERNAL_STORAGE</code> 权限的应用可以使用直接文件路径和原生库来读取设备的媒体文件。通过这项新功能，应用可以更顺畅地使用第三方媒体库。</p>
<h3 id="文件和目录访问限制"><a href="#文件和目录访问限制" class="headerlink" title="文件和目录访问限制"></a><strong>文件和目录访问限制</strong></h3><p>以下与存储访问框架 (SAF) 相关的变更只有在应用以 Android 11 为目标平台时才会生效。</p>
<h4 id="访问目录"><a href="#访问目录" class="headerlink" title="访问目录"></a>访问目录</h4><p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE</code> intent 操作来请求访问以下目录：</p>
<ul>
<li><code>Downloads</code> 根目录。</li>
<li>设备制造商认为可靠的各个 SD 卡卷的根目录，无论该卡是模拟卡还是可移除的卡。</li>
</ul>
<h4 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h4><p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE</code> 或 <code>ACTION_OPEN_DOCUMENT</code> intent 操作来请求用户从以下目录中选择单独的文件：</p>
<ul>
<li><p>Android/data/目录及其所有子目录。</p>
</li>
<li><p><code>Android/obb/</code> 目录及其所有子目录。</p>
</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h3><p>不管应用的目标 SDK 版本是什么，以下变更均会在 Android 11 中生效：</p>
<ul>
<li><strong>存储</strong>运行时权限已重命名为<strong>文件和媒体</strong>。</li>
<li>如果应用未停用分区存储并且请求 <code>READ_EXTERNAL_STORAGE</code> 权限，则用户会看到不同于 Android 10 的对话框。该对话框会指示应用正在请求访问照片、视频、音频剪辑和文件。</li>
<li>用户可以在系统设置中查看哪些应用具有 <code>READ_EXTERNAL_STORAGE</code> 权限。在<strong>设置 &gt; 隐私 &gt; 权限管理器 &gt; 文件和媒体</strong>页面上，具有该权限的每个应用都列在<strong>允许存储所有文件</strong>下。</li>
</ul>
<p>这里要注意：如果应用以 Android 11 为目标平台，切记，对“所有文件”的这种访问权限是只读访问权限。要使用此应用读取<strong>和写入</strong>共享的存储空间中的所有文件，需要具有所有文件访问权限。</p>
<h3 id="所有文件访问权限"><a href="#所有文件访问权限" class="headerlink" title="所有文件访问权限"></a><strong>所有文件访问权限</strong></h3><p>某些应用的核心用例需要访问大量的文件，如文件管理操作或备份和恢复操作。这些应用可通过执行以下操作来获取“所有文件访问权限”：</p>
<ol>
<li>声明 <code>MANAGE_EXTERNAL_STORAGE</code> 权限。</li>
<li>使用 <code>ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION</code> intent 操作将用户引导至一个系统设置页面，在该页面上，用户可以为应用启用以下选项：<strong>授予所有文件的管理权限</strong>。</li>
</ol>
<p>“所有文件访问权限”可授予以下权限：</p>
<ul>
<li>对共享的存储空间内所有文件的读写访问权限。</li>
<li>对 <code>MediaStore.Files</code> 表的内容的访问权限。</li>
</ul>
<p>应用可以使用 <code>MediaStore</code> API 或原始文件路径来访问这些文件。如果应用使用存储访问框架，不能使用它来访问“所有文件访问权限”提供的其他文件和目录。获得此权限的应用仍然无法访问属于其他应用的应用专用目录。这些目录在存储卷上显示为 <code>Android/data/</code> 的子目录。</p>
<h3 id="自定义消息框视图被屏蔽"><a href="#自定义消息框视图被屏蔽" class="headerlink" title="自定义消息框视图被屏蔽"></a><strong>自定义消息框视图被屏蔽</strong></h3><p>出于安全方面的考虑，同时也为了保持良好的用户体验，如果包含自定义视图的消息框是以 Android 11 为目标平台的应用从后台发送的，则系统会屏蔽这些消息框。请注意，仍允许使用文本消息框；此类消息框是使用 <code>Toast.makeText()</code> 创建的，并不调用 <code>setView()</code>。</p>
<p>如果您的应用仍尝试从后台发布包含自定义视图的消息框，则系统不会向用户显示相应的消息，而会执行以下操作：</p>
<ol>
<li><p>显示以下消息框消息：</p>
<p><code>Background custom toast blocked for package package-name. See g.co/dev/toast.</code></p>
</li>
<li><p>在 logcat 中记录以下消息：</p>
<p><code>W/NotificationService: Blocking custom toast from package due to package not in the foreground</code></p>
</li>
</ol>
<p>如果希望在消息框（文本消息框或自定义消息框）出现或消失时收到通知，请使用新的 <code>addCallback()</code> 方法。</p>
<p>这里需要注意，由于平台行为发生了变更，以 Android 11 为目标平台的应用会发现文本消息框受到以下负面影响：</p>
<ul>
<li><code>getView()</code> 方法返回 <code>null</code>。</li>
<li>以下方法的返回值并不反映实际值，因此尽量别使用：</li>
<li><ul>
<li><code>getHorizontalMargin()</code></li>
<li><code>getVerticalMargin()</code></li>
<li><code>getGravity()</code></li>
<li><code>getXOffset()</code></li>
<li><code>getYOffset()</code></li>
</ul>
</li>
<li>以下方法是空操作，因此应用不应使用：</li>
<li><ul>
<li>[<code>setMargin()</code>](developer.android.google.cn/reference/a…(float, float))</li>
<li>[<code>setGravity()</code>](developer.android.google.cn/reference/a…(int, int, int))</li>
</ul>
</li>
</ul>
<h3 id="前台服务类型"><a href="#前台服务类型" class="headerlink" title="** 前台服务类型**"></a>** 前台服务类型**</h3><p>从 Android 9 开始，应用仅限于在前台访问摄像头和麦克风。为了进一步保护用户，Android 11 更改了前台服务访问摄像头和麦克风相关数据的方式。如果应用以 Android 11 为目标平台并且在某项前台服务中访问这些类型的数据，则需要在该前台服务的声明的 <code>foregroundServiceType</code> 属性中添加新的 <code>camera</code> 和 <code>microphone</code> 类型。</p>
<p>来举个例子吧，如果应用中的某项前台服务需要访问与设备的位置信息和摄像头相关的数据，请按以下代码段所示声明该服务：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">&lt;manifest&gt;<br>        ...<br>        &lt;service ... android:foregroundServiceType=<span class="hljs-string">&quot;location|camera&quot;</span> /&gt;<br>&lt;/manifest&gt;<br></code></pre></td></tr></table></figure>

<h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a><strong>MAC 地址</strong></h3><p>在以 Android 10（API 级别 29）及更低版本为目标平台的应用中，MAC 地址的随机分配是基于每个 SSID 进行的，因为 Passpoint 可以连接到同一资料的不同 SSID。而在以 Android 11（API 级别“R”）及更高版本为目标平台的应用中，Passpoint 网络的 MAC 地址随机分配将更改为针对每个完全限定域名 (FQDN) 进行分配。</p>
<p>对于以 API 级别“R”及更高级别为目标平台的应用，非特权应用将无法访问设备的 MAC 地址；只有具有 IPv4 地址的网络接口可见。会影响 <code>getifaddrs()</code> 和 <code>NetworkInterface.getHardwareAddress()</code> 方法，以及 <code>RTM_GETLINK</code> netlink 消息的发送。</p>
<p>下面列出了此变更会以哪些方式来影响应用：</p>
<ul>
<li><code>NetworkInterface.getHardwareAddress()</code> 会针对每个接口返回 null。</li>
<li>应用无法对 <code>NETLINK_ROUTE</code> 套接字使用 <code>bind()</code> 函数。</li>
<li><code>IP</code> 命令不会返回有关接口的信息。</li>
</ul>
<p>这些变更强制执行不要使用 MAC 地址中提供的指导。</p>
<p>请注意，大多数开发者应使用级别较高的 <code>ConnectivityManager</code> API 而不是级别较低的 <code>NetworkInterface</code>/<code>getifaddrs()</code> API。</p>
<h3 id="每个进程的网络访问控制"><a href="#每个进程的网络访问控制" class="headerlink" title="每个进程的网络访问控制"></a><strong>每个进程的网络访问控制</strong></h3><p>从 Android 11 开始，处理敏感用户数据的应用可以向每个进程授予网络访问权限。通过明确指定允许哪些进程访问网络，您可以隔离不需要上传数据的所有代码。</p>
<p>虽然不能保证防止应用意外上传数据，但该功能可让降低应用中的错误导致数据泄露的几率。</p>
<p>下面显示了使用这项新功能的清单文件的示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">&lt;processes&gt;<br>        &lt;process /&gt;<br>        &lt;deny-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br>        &lt;process android:process=<span class="hljs-string">&quot;:withoutnet1&quot;</span> /&gt;<br>        &lt;process android:process=<span class="hljs-string">&quot;com.android.cts.useprocess.withnet1&quot;</span>&gt;<br>            &lt;allow-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br>        &lt;/process&gt;<br>        &lt;allow-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br>        &lt;process android:process=<span class="hljs-string">&quot;:withoutnet2&quot;</span>&gt;<br>            &lt;deny-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br>        &lt;/process&gt;<br>        &lt;process android:process=<span class="hljs-string">&quot;com.android.cts.useprocess.withnet2&quot;</span> /&gt;<br>    &lt;/processes&gt;<br></code></pre></td></tr></table></figure>

<h3 id="一次性权限"><a href="#一次性权限" class="headerlink" title="一次性权限"></a><strong>一次性权限</strong></h3><p>在 Android 11 中，每当应用请求与位置信息、麦克风或摄像头相关的权限时，应用都会获得临时的一次性权限。这个其实在苹果中也有类似的权限申请。</p>
<p>Android 11 不建议重复请求特定权限组中的权限。在您的应用安装到设备上后，如果用户在使用过程中两次针对某项特定的权限点按<strong>拒绝</strong>，此操作表示其希望以后请求相应权限组中的该权限时“不再询问”。</p>
<p>系统还对与点按<strong>拒绝</strong>选项相仿的操作的响应行为做出了定义：</p>
<ul>
<li>如果用户按返回按钮关闭权限对话框，此操作不算“拒绝”操作。</li>
<li>如果用户使用 [<code>requestPermissions()</code>](developer.android.google.cn/reference/a…(android.app.Activity, java.lang.String[], int)) 从您的应用转到系统设置，然后按返回按钮，此操作就算是“拒绝”操作。</li>
</ul>
<h3 id="悬浮窗口-intent-始终会将用户转至系统权限屏幕"><a href="#悬浮窗口-intent-始终会将用户转至系统权限屏幕" class="headerlink" title="悬浮窗口 intent 始终会将用户转至系统权限屏幕"></a>悬浮窗口 intent 始终会将用户转至系统权限屏幕</h3><p>从 Android 11 开始，<code>ACTION_MANAGE_OVERLAY_PERMISSION</code> intent 始终会将用户转至顶级<strong>设置</strong>屏幕，用户可在其中授予或撤消应用的 <code>SYSTEM_ALERT_WINDOW</code> 权限。intent 中的任何 <code>package:</code> 数据都会被忽略。</p>
<p>在更低版本的 Android 中，<code>ACTION_MANAGE_OVERLAY_PERMISSION</code> intent 可以指定一个文件包，它会将用户转至应用专用屏幕来管理权限。Android 11 不再支持此功能，而是必须由用户先选择要对其授予或撤消权限的应用。此变更可以让权限的授予更有目的性，从而达到保护用户的目的。</p>
<h3 id="限制非-SDK-接口"><a href="#限制非-SDK-接口" class="headerlink" title="限制非 SDK 接口"></a>限制非 SDK 接口</h3><p>如果应用并非以 Android 11 为目标平台，那么其中一些变更可能不会立即产生影响。虽然目前仍然可以使用灰名单中的一些非 SDK 接口（取决于应用的目标 API 级别），但如果使用任何非 SDK 方法或字段，则应用无法运行的风险终归较高。</p>
<p>如果不确定自己的应用是否使用了非 SDK 接口，则可以测试该应用，进行确认。如果应用依赖于非 SDK 接口，则应该开始计划迁移到 SDK 替代方案。如果无法为应用中的某项功能找到使用非 SDK 接口的替代方案，则应该请求新的公共 API。</p>
<h3 id="Open-Mobile-API-变更"><a href="#Open-Mobile-API-变更" class="headerlink" title="Open Mobile API 变更"></a>Open Mobile API 变更</h3><p>从 Android 11 开始，Open Mobile API (OMAPI) 有了额外的功能：</p>
<ul>
<li>解析运营商权限的规则。</li>
<li>使用以下一项或多项来自定义嵌入式安全元件 (eSE) 访问权限或配置 eSE：</li>
<li><ul>
<li>系统特许权限</li>
<li>可配置的访问规则应用主数据 (ARA-M) 应用标识符 (AID)</li>
<li>用于重置 OMAPI 读取器的系统 API</li>
</ul>
</li>
<li>为读取器提供清晰的指示符，以便应用过滤设备功能。</li>
</ul>
<h3 id="支持并发使用多个摄像头"><a href="#支持并发使用多个摄像头" class="headerlink" title="支持并发使用多个摄像头"></a>支持并发使用多个摄像头</h3><p>Android 11 添加了 API 来查询对同时使用多个摄像头（包括前置摄像头和后置摄像头）的支持。</p>
<p>要在运行应用的设备上检查支持情况，请使用以下方法：</p>
<ul>
<li><code>getConcurrentStreamingCameraIds()</code>可返回摄像头 ID 组合 <code>Set</code>，这些组合可与有保证的数据流组合并发进行流式传输（如果它们是由同一应用进程配置的）。</li>
<li><code>isConcurrentSessionConfigurationSupported() </code>可查询摄像头设备是否可以并发支持相应的会话配置。</li>
</ul>
<p>到这里本篇文章也到了尾声了，本文基本写完了安卓11更新的主要内容，大家可以根据应用实际情况进行准备，现在还不着急适配，真正需要适配的话应该还得好几个月。最后再放一下官网地址：<a href="https://developer.android.google.cn/preview%E3%80%82%E5%A6%82%E6%9E%9C%E6%9C%AC%E6%96%87%E5%AF%B9%E4%BD%A0%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E8%AF%9D%E8%AE%B0%E5%BE%97%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8%E5%95%8A%EF%BC%8C%E6%84%9F%E6%BF%80%E4%B8%8D%E5%B0%BD%EF%BC%81%EF%BC%81%EF%BC%81">https://developer.android.google.cn/preview。如果本文对你有帮助的话记得点赞关注啊，感激不尽！！！</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Android架构</title>
    <url>/topic/topic_Android%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h3 id="1-ViewModel如何知道View层的生命周期？"><a href="#1-ViewModel如何知道View层的生命周期？" class="headerlink" title="1.ViewModel如何知道View层的生命周期？"></a>1.ViewModel如何知道View层的生命周期？</h3><p>事实上，如果你仅仅使用ViewModel，它是感知不了生命周期，它需要结合LiveData去感知生命周期，如果仅仅使用DataBinding去实现MVVM，它对数据源使用了弱引用，所以一定程度上可以避免内存泄漏的发生。</p>
<h3 id="2-MVVM和MVP的最大区别在哪？"><a href="#2-MVVM和MVP的最大区别在哪？" class="headerlink" title="2.MVVM和MVP的最大区别在哪？"></a>2.MVVM和MVP的最大区别在哪？</h3><p>MVP中的每个方法都需要你去主动调用，它其实是被动的，而MVVM中有数据驱动这个概念，当你的持有的数据状态发生变更的时候，你的View你可以监听到这个变化，从而主动去更新，这其实是主动的。</p>
<h3 id="3-MVC和MVP的区别是什么？"><a href="#3-MVC和MVP的区别是什么？" class="headerlink" title="3.MVC和MVP的区别是什么？"></a>3.MVC和MVP的区别是什么？</h3><p>MVP是MVC的进一步解耦，简单来讲，在MVC中，View层既可以和Controller层交互，又可以和Model层交互；而在MVP中，View层只能和Presenter层交互，Model层也只能和Presenter层交互，减少了View层和Model层的耦合，更容易定位错误的来源。</p>
<h3 id="4-MVC、MVP和MVVM是什么？"><a href="#4-MVC、MVP和MVVM是什么？" class="headerlink" title="4.MVC、MVP和MVVM是什么？"></a>4.MVC、MVP和MVVM是什么？</h3><p>MVC：Model-View-Controller，是一种分层解偶的框架，Model层提供本地数据和网络请求，View层处理视图，Controller处理逻辑，存在问题是Controller层和View层的划分不明显，Model层和View层的存在耦合。<br>MVP：Model-View-Presenter，是对MVC的升级，Model层和View层与MVC的意思一致，但Model层和View层不再存在耦合，而是通过Presenter层这个桥梁进行交流。<br>MVVM：Model-View-ViewModel，不同于上面的两个框架，ViewModel持有数据状态，当数据状态改变的时候，会自动通知View层进行更新。</p>
<h3 id="5-谈MVC-，MVP，MVVM"><a href="#5-谈MVC-，MVP，MVVM" class="headerlink" title="5.谈MVC ，MVP，MVVM"></a>5.谈MVC ，MVP，MVVM</h3><p>MVC:View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些 业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，及View。所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVP：MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负 责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。<br>MVVM：数据双向绑定，通过数据驱动UI，M提供数据，V视图，VM即数据驱动层</p>
<h3 id="6-简述Activity启动全部过程"><a href="#6-简述Activity启动全部过程" class="headerlink" title="6.简述Activity启动全部过程"></a>6.简述Activity启动全部过程</h3><p>app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。<br>我们创建一个新的项目，默认的根activity都是MainActivity，而所有的activity都是保存在堆栈中的，我们启动一个新的activity就会放在上一个activity上面，而我们从桌面点击应用图标的时候，由于launcher本身也是一个应用，当我们点击图标的时候，系统就会调用startActivitySately(),一般情况下，我们所启动的activity的相关信息都会保存在intent中，比如action，category等等。我们在安装这个应用的时候，系统也会启动一个PackaManagerService的管理服务，这个管理服务会对AndroidManifest.xml文件进行解析，从而得到应用程序中的相关信息，比如service，activity，Broadcast等等，然后获得相关组件的信息。当我们点击应用图标的时候，就会调用startActivitySately()方法，而这个方法内部则是调用startActivty(),而startActivity()方法最终还是会调用startActivityForResult()这个方法。而在startActivityForResult()这个方法。因为startActivityForResult()方法是有返回结果的，所以系统就直接给一个-1，就表示不需要结果返回了。而startActivityForResult()这个方法实际是通过Instrumentation类中的execStartActivity()方法来启动activity，Instrumentation这个类主要作用就是监控程序和系统之间的交互。而在这个execStartActivity()方法中会获取ActivityManagerService的代理对象，通过这个代理对象进行启动activity。启动会就会调用一个checkStartActivityResult()方法，如果说没有在配置清单中配置有这个组件，就会在这个方法中抛出异常了。当然最后是调用的是Application.scheduleLaunchActivity()进行启动activity，而这个方法中通过获取得到一个ActivityClientRecord对象，而这个ActivityClientRecord通过handler来进行消息的发送，系统内部会将每一个activity组件使用ActivityClientRecord对象来进行描述，而ActivityClientRecord对象中保存有一个LoaderApk对象，通过这个对象调用handleLaunchActivity来启动activity组件，而页面的生命周期方法也就是在这个方法中进行调用。</p>
<h3 id="7-大体说清一个应用程序安装到手机上时发生了什么"><a href="#7-大体说清一个应用程序安装到手机上时发生了什么" class="headerlink" title="7.大体说清一个应用程序安装到手机上时发生了什么"></a>7.大体说清一个应用程序安装到手机上时发生了什么</h3><p>(1）拷贝apk文件到指定目录：<br>用户安装的apk首先会被拷贝到/data/app目录下<br>/data/app目录是用户有权限访问的目录，在安装apk的时候会自动选择该目录存放用户安装的文件<br>系统出厂的apk文件则被放到了/system分区下,包括 /system/app，/system/vendor/app，以及 /system/priv-app 等等，该分区只有Root权限的用户才能<br>2）解压apk，拷贝文件，创建应用的数据目录：<br>为了加快app的启动速度，apk在安装的时候，会首先将app的可执行文件（dex）拷贝到 /data/dalvik-cache 目录，缓存起来。<br>然后，在/data/data/目录下创建应用程序的数据目录（以应用的包名命名），存放应用的相关数据，如数据库、xml文件、cache、二进制的so动态库等等。<br>3）解析apk的AndroidManifinest.xml文件：解析的内容会被存储到/data/system/packages.xml和/data/system/packages.list中。<br>packages.list：中指名了该应用默认存储的位置/data/data/cn.hadcn.example。<br>packages.xml：中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。</p>
<p>做完以上操作，就相当于应用在系统注册了，可以被系统识别。<br>注：目录是由 包名-1 组成，有时候此处是 -2。这是为了升级使用，升级时会新创建一个-1 或 -2的目录，如果升级成功，则删除原目录并更改packages.xml中codePath到新目录<br>在Dalvik模式下，会使用dexopt把base.apk中的dex文件优化为odex，存储在/data/dalvik-cache中，<br>如果是ART模式，则会使用dex2oat优化成oat文件也存储在该目录下，并且文件名一样，但文件大小会大很多，因为ART模式会在安装时把dex优化为机器码，所以在ART模式下的应用运行更快，但apk安装速度相对Dalvik模式下变慢，并且会占用更多的ROM。</p>
<h3 id="8-系统启动流程是什么？"><a href="#8-系统启动流程是什么？" class="headerlink" title="8.系统启动流程是什么？"></a>8.系统启动流程是什么？</h3><p>提示：Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程</p>
<p>第一步：启动电源以及系统启动<br>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。<br>第二步：引导程序<br>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。<br>引导程序是OEM厂商或者运营商加锁和限制的地方。引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。<br>Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。<br>传统的加载器包含的个文件，需要在这里说明：<br>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；<br>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签。<br>更多关于Android引导程序的可以在这里了解。<br>第三步：内核<br>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。<br>第四步：init进程<br>init是第一个进程，我们可以说它是root进程或者所有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。<br>init进程可以在/system/core/init找到。<br>init.rc文件可以在/system/core/rootdir/init.rc找到。<br>readme.txt可以在/system/core/init/readme.txt找到。<br>对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。<br>Action（动作）：动作是以命令流程命名的，有一个触发器决定动作是否发生。<br>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。<br>Options（选项）：选项是对服务的描述。它们影响init进程如何以及何时启动服务。<br>在这个阶段你可以在设备的屏幕上看到“Android”logo了。<br>第五步<br>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。假如Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。<br>Zygote加载进程<br>加载ZygoteInit类，源代码：/frameworks/base/core/java/com/android /internal/os/ZygoteInit.java<br>registerZygoteSocket()为zygote命令连接注册一个服务器套接字。preloadClassed “preloaded-classes”是一个简单的包含一系列需要预加载类的文本文件，你可以在/frameworks/base找到“preloaded-classes”文件。preloadResources() preloadResources也意味着本地主题、布局以及android.R文件中包含的所有东西都会用这个方法加载。在这个阶段，你可以看到启动动画。<br>第六步：系统服务或服务<br>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。<br>Zygote创建新的进程去启动系统服务。你可以在ZygoteInit类的”startSystemServer”方法中找到源代码。<br>核心服务：<br>启动电源管理器；创建Activity管理器；启动电话注册；启动包管理器；设置Activity管理服务为系统进程；启动上下文管理器；启动系统Context Providers；启动电池服务；启动定时管理器；启动传感服务；启动窗口管理器；启动蓝牙服务；启动挂载服务。<br>其他服务：<br>启动状态栏服务；启动硬件服务；启动网络状态服务；启动网络连接服务；启动通知管理器；启动设备存储监视服务；启动定位管理器；启动搜索服务；启动剪切板服务；启动登记服务；启动壁纸服务；启动音频服务；启动耳机监听；启动AdbSettingsObserver（处理adb命令）。<br>第七步：引导完成<br>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
<h3 id="9-Ubuntu编译安卓系统"><a href="#9-Ubuntu编译安卓系统" class="headerlink" title="9.Ubuntu编译安卓系统"></a>9.Ubuntu编译安卓系统</h3><p>1.初始化编译环境<br>. build/envsetup.sh<br>2.选择编译目标<br>lunch aosp_arm64-eng<br>3.开始编译<br>make -j8</p>
<h3 id="10-AIDL理解（此处延伸：简述Binder）"><a href="#10-AIDL理解（此处延伸：简述Binder）" class="headerlink" title="10.AIDL理解（此处延伸：简述Binder）"></a>10.AIDL理解（此处延伸：简述Binder）</h3><p>AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。</p>
<p>Binde机制简单理解:<br>在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，<br>Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。</p>
<h3 id="11-从0设计一款App整体架构，如何去做？"><a href="#11-从0设计一款App整体架构，如何去做？" class="headerlink" title="11.从0设计一款App整体架构，如何去做？"></a>11.从0设计一款App整体架构，如何去做？</h3><p>无非就是技术选择（使用哪些第三方框架），使用那种设计模式（MVP，MVC，MVVM为什么选这个？），包的结构，分类等等</p>
<h3 id="12-MVC-MVP-MVVM原理和区别"><a href="#12-MVC-MVP-MVVM原理和区别" class="headerlink" title="12.MVC MVP MVVM原理和区别"></a>12.MVC MVP MVVM原理和区别</h3><p>MVP模式，对应着Model—业务逻辑和实体模型,view–对应着activity，负责View的绘制以及与用户交互,Presenter–负责View和Model之间的交互,MVP模式是在MVC模式的基础上，将Model与View彻底分离使得项目的耦合性更低，在Mvc中项目中的activity对应着mvc中的C–Controllor,而项目中的逻辑处理都是在这个C中处理，同时View与Model之间的交互，也是也就是说，mvc中所有的逻辑交互和用户交互，都是放在Controllor中，也就是activity中。View和model是可以直接通信的。<br>MVP模式：则是分离的更加彻底，分工更加明确Model—业务逻辑和实体模型，view–负责与用户交互，Presenter 负责完成View于Model间的交互，MVP和MVC最大的区别是MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的<br>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。可以说是MVP的升级版<br>唯一的区别是，它采用双向绑定(data-binding)：View 的变动，自动反映在 ViewModel，反之亦然。</p>
<h3 id="13-Android-的大体架构图"><a href="#13-Android-的大体架构图" class="headerlink" title="13.Android 的大体架构图"></a>13.Android 的大体架构图</h3><p>Android的系统架构采用了分层架构的思想，如图1所示。从上层到底层共包括四层，分别是应用层、应用框架层、系统库和Android运行时和Linux内核。</p>
<h3 id="14-目前Android系统支持以下七种不用的CPU架构"><a href="#14-目前Android系统支持以下七种不用的CPU架构" class="headerlink" title="14.目前Android系统支持以下七种不用的CPU架构"></a>14.目前Android系统支持以下七种不用的CPU架构</h3><p>ARMv5——armeabi<br>ARMv7 ——armeabi-v7a<br>ARMv8——arm64- v8a<br>x86——x86<br>MIPS ——mips<br>MIPS64——mips64<br>x86_64——x86_64</p>
<h3 id="15-Android各个版本间的差异"><a href="#15-Android各个版本间的差异" class="headerlink" title="15.Android各个版本间的差异"></a>15.Android各个版本间的差异</h3><h4 id="android版本间兼容问题"><a href="#android版本间兼容问题" class="headerlink" title="# android版本间兼容问题"></a># android版本间兼容问题</h4><p>Android 6.0：运行时权限，对几个比较危险的权限进行判断，除了在清单文件定义之外，还要程序运行时动态的申请，只有用户同意了，才可以使用相关功能</p>
<p>Android 7.0：应用间共享文件限制，就是禁止向外公开 file://URI，解决办法就是通过 fileProvider，发送 content://URI 类型的 uri，授予它临时访问权限，需要在清单文件进行注册，并指定共享目录</p>
<p>Android 8.0：通知栏要设置通知渠道，否则无法正常显示，这个根据 Android 新的 api 设置一下对应的渠道就好了；另外还有未知应用安装权限，在做 app 内部更新下载的时候，需要先判断有没有打开这个权限，否则会崩溃，无法安装；</p>
<p>Android 9.0：限制 Http 请求，希望所有的请求都是 https 的，解决办法是在清单文件里加上一个网络完全配置；</p>
<p>Android 10.0：禁止访问 imei 等手机唯一标示信息，需要做唯一标识的备用方案；</p>
<p>这里如果是代码逻辑上的，可以在代码里进行 api 版本的判断</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>java进阶</title>
    <url>/topic/topic_java%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="1-需要关注的设计模式"><a href="#1-需要关注的设计模式" class="headerlink" title="1.需要关注的设计模式"></a>1.需要关注的设计模式</h3><p>重点了解以下的几种常用的设计模式：</p>
<p>工厂模式和抽象工厂模式：注意他们的区别。<br>责任链模式：View的事件分发和OkHttp的调用过程都使用到了责任链模式。<br>观察者模式：重要性不言而喻。<br>代理模式：建议了解一下动态代理。</p>
<h3 id="2-设计模式的六大原则是："><a href="#2-设计模式的六大原则是：" class="headerlink" title="2.设计模式的六大原则是："></a>2.设计模式的六大原则是：</h3><p>单一职责：合理分配类和函数的职责<br>开闭原则：开放扩展，关闭修改<br>里式替换：继承<br>依赖倒置：面向接口<br>接口隔离：控制接口的粒度<br>迪米特：一个类应该对其他的类了解最少</p>
<h3 id="3-通常的阻塞队列有哪几种，特点是什么？"><a href="#3-通常的阻塞队列有哪几种，特点是什么？" class="headerlink" title="3.通常的阻塞队列有哪几种，特点是什么？"></a>3.通常的阻塞队列有哪几种，特点是什么？</h3><p>ArrayBlockQueue：基于数组实现的有界的FIFO(先进先出)阻塞队列。<br>LinkedBlockQueue：基于链表实现的无界的FIFO(先进先出)阻塞队列。<br>SynchronousQueue：内部没有任何缓存的阻塞队列。<br>PriorityBlockingQueue：具有优先级的无限阻塞队列。</p>
<h3 id="4-volatile的原理？"><a href="#4-volatile的原理？" class="headerlink" title="4.volatile的原理？"></a>4.volatile的原理？</h3><p>可见性 如果对声明了volatile的变量进行写操作的时候，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写入到系统内存。</p>
<p>多处理器的环境下，其他处理器的缓存还是旧的，为了保证各个处理器一致，会通过嗅探在总线上传播的数据来检测自己的数据是否过期，如果过期，会强制重新将系统内存的数据读取到处理器缓存。</p>
<p>有序性 Lock前缀的指令相当于一个内存栅栏，它确保指令排序的时候，不会把后面的指令拍到内存栅栏的前面，也不会把前面的指令排到内存栅栏的后面。</p>
<h3 id="5-死锁触发的四大条件？"><a href="#5-死锁触发的四大条件？" class="headerlink" title="5.死锁触发的四大条件？"></a>5.死锁触发的四大条件？</h3><p>互斥锁<br>请求与保持<br>不可剥夺<br>循环的请求与等待</p>
<h3 id="6-线程池的工作流程？"><a href="#6-线程池的工作流程？" class="headerlink" title="6.线程池的工作流程？"></a>6.线程池的工作流程？</h3><p>线程池工作流程:</p>
<p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a7092b526a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"   title="示例图片"><span class="image-caption">线程池工作流程</span></p>
<p>简而言之：</p>
<p>任务来了，优先考虑核心线程。<br>核心线程满了，进入阻塞队列。<br>阻塞队列满了，考虑非核心线程（图上好像少了这个过程）。<br>非核心线程满了，再触发拒绝任务。</p>
<h3 id="7-线程池中的几个参数是什么意思，线程池的种类有哪些？"><a href="#7-线程池中的几个参数是什么意思，线程池的种类有哪些？" class="headerlink" title="7.线程池中的几个参数是什么意思，线程池的种类有哪些？"></a>7.线程池中的几个参数是什么意思，线程池的种类有哪些？</h3><p>线程池的构造函数如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">ThreadPoolExecutor(<span class="hljs-params">int</span> <span class="hljs-params">corePoolSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">maximumPoolSize</span>, <span class="hljs-params">long</span> <span class="hljs-params">keepAliveTime</span>, TimeUnit <span class="hljs-params">unit</span>, BlockingQueue&lt;Runnable&gt; <span class="hljs-params">workQueue</span>)</span> &#123; <br><br>        this(corePoolSize, maximumPoolSize, keepAliveTime, <span class="hljs-built_in">unit</span>, workQueue, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span>default<span class="hljs-constructor">ThreadFactory()</span>, defaultHandler); <br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>参数解释如下：</p>
<p>corePoolSize：核心线程数量，不会释放。<br>maximumPoolSize：允许使用的最大线程池数量，非核心线程数量，闲置时会释放。<br>keepAliveTime：闲置线程允许的最大闲置时间。<br>unit：闲置时间的单位。<br>workQueue：阻塞队列，不同的阻塞队列有不同的特性。</p>
<p>线程池分为四个类型：</p>
<p>CachedThreadPool：闲置线程超时会释放，没有闲置线程的情况下，每次都会创建新的线程。<br>FixedThreadPool：线程池只能存放指定数量的线程池，线程不会释放，可重复利用。<br>SingleThreadExecutor：单线程的线程池。<br>ScheduledThreadPool：可定时和重复执行的线程池。</p>
<h3 id="8-与新建一个线程相比，线程池的特点？"><a href="#8-与新建一个线程相比，线程池的特点？" class="headerlink" title="8.与新建一个线程相比，线程池的特点？"></a>8.与新建一个线程相比，线程池的特点？</h3><p>节省开销： 线程池中的线程可以重复利用。<br>速度快：任务来了就能开始，省去创建线程的时间。<br>线程可控：线程数量可空和任务可控。<br>功能强大：可以定时和重复执行任务。</p>
<h3 id="9-线程的状态有哪些？"><a href="#9-线程的状态有哪些？" class="headerlink" title="9.线程的状态有哪些？"></a>9.线程的状态有哪些？</h3><p>线程的状态有：</p>
<p>new：新创建的线程<br>Ready：准备就绪的线程，由于CPU分配的时间片的关系，此时的任务不在执行过程中。<br>Running：正在执行的任务<br>Block：被阻塞的任务<br>Time Waiting：计时等待的任务<br>Terminated：终止的任务<br>附上一张状态转换的图：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2020/4/24/171ab7a6f77cf96c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">线程状态转换</span></p>
<h3 id="10-逻辑地址与物理地址，为什么使用逻辑地址？"><a href="#10-逻辑地址与物理地址，为什么使用逻辑地址？" class="headerlink" title="10.逻辑地址与物理地址，为什么使用逻辑地址？"></a>10.逻辑地址与物理地址，为什么使用逻辑地址？</h3><p>逻辑地址：存储单元的地址可以用段基值和段内偏移量来表示,段基值确定它所在的段居于整个存储空间的位置,偏移量确定它在段内的位置,这种地址表示方式称为逻辑地址。8086体系的CPU一开始是20根地址线, 寻址寄存器是16位, 16位的寄存器可以访问64K的地址空间, 如果程序要想访问大于64K的内存, 就要把内存分段, 每段64K, 用段地址+偏移量的方法来访问 。386CPU出来之后, 采用了32条地址线, 地址寄存器也扩为32位, 这样就可以不用分段了, 直接用一个地址寄存器来线性访问4G的内存了. 这就叫平面模式.</p>
<p>线性地址：又叫虚拟地址，是一个32位无符号整数，可以用来表示高达4GB的地址，跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。</p>
<p>物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>注意：<br>1.CPU将一个虚拟内存空间中的地址转换为物理地址，需要进行两步：首先将给定一个逻辑地址（其实是段内偏移量，这个一定要理解！！！），CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线性地址，再利用其页式内存管理单元，转换为最终物理地址。<br>逻辑地址—-段式内存管理单元—-线性地址—-页式内存管理单元—-物理地址<br>这样做两次转换，的确是非常麻烦而且没有必要的，因为直接可以把线性地址抽像给进程。之所以这样冗余，Intel完全是为了兼容而已。</p>
<h3 id="11-gc-进行回收的准则是什么？也就是说什么样的对象可以被回收？"><a href="#11-gc-进行回收的准则是什么？也就是说什么样的对象可以被回收？" class="headerlink" title="11.gc()进行回收的准则是什么？也就是说什么样的对象可以被回收？"></a>11.gc()进行回收的准则是什么？也就是说什么样的对象可以被回收？</h3><p>简单来说就是：没有被任何可达变量指向的对象。这里的可达是意思就是能够找到的（没有任何可达变量指向你，你还有活下去的理由吗？你就算活下去谁能找得到你呢？）<br>所以说，C++中将释放了的指针置为null的习惯要保留到Java中，因为这有可能是你释放内存的唯一途径。<br>不要频繁使用gc函数。<br>保持代码健壮（记得将不用的变量置为null），让虚拟机去管理内存</p>
<h3 id="12-System-gc-使用介绍："><a href="#12-System-gc-使用介绍：" class="headerlink" title="12.System.gc()使用介绍："></a>12.System.gc()使用介绍：</h3><p>Java中的内存分配是随着new一个新的对象来实现的，这个很简单，而且也还是有一些可以“改进”内存回收的机制的，其中最显眼的就是这个System.gc()函数。<br>其实这个gc()函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。</p>
<h3 id="13-垃圾回收机制与调用System-gc-区别"><a href="#13-垃圾回收机制与调用System-gc-区别" class="headerlink" title="13.垃圾回收机制与调用System.gc()区别"></a>13.垃圾回收机制与调用System.gc()区别</h3><p>垃圾回收机制：<br>1.垃圾收集算法的核心思想<br>Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。<br>该机制可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。</p>
<p>垃圾收集算法的核心思想是：<br>对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。</p>
<p>2.触发主GC(Garbage Collector)的条件<br>JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:</p>
<p>①当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</p>
<p>②Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</p>
<p>由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。</p>
<p>3.减少GC开销的措施<br>根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。（若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。）<br>为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:<br>(1)不要显式调用System.gc()<br>  此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。<br>(2)尽量减少临时对象的使用<br>  临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。<br>(3)对象不用时最好显式置为Null</p>
<p>  一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。<br>(4)尽量使用StringBuffer,而不用String来累加字符串<br>  由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象（如 Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾）。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<p>(5)能用基本类型如Int,Long,就不用Integer,Long对象<br>  基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。<br>(6)尽量少用静态对象变量<br>  静态变量属于全局变量,不会被GC回收,它们会一直占用内存。<br>(7)分散对象创建或删除的时间<br>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片, 从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC 的机会。</p>
<h3 id="14-Art和Dalvik对比"><a href="#14-Art和Dalvik对比" class="headerlink" title="14.Art和Dalvik对比"></a>14.Art和Dalvik对比</h3><p>（1）在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行，这虽然会使安装过程比较快，但是会拖慢应用的运行效率。而在ART 环境中，应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高。<br>（2）ART占用空间比Dalvik大（原生代码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%），这也是著名的“空间换时间大法”。<br>（3）预编译也可以明显改善电池续航，因为应用程序每次运行时不用重复编译了，从而减少了 CPU 的使用频率，降低了能耗。</p>
<h3 id="15-java虚拟机和Dalvik虚拟机的区别"><a href="#15-java虚拟机和Dalvik虚拟机的区别" class="headerlink" title="15.java虚拟机和Dalvik虚拟机的区别"></a>15.java虚拟机和Dalvik虚拟机的区别</h3><p>Java虚拟机：<br>1、java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。<br>2、java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件）<br>Dalvik虚拟机：<br>1、dalvik虚拟机是基于寄存器的<br>2、Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据<br>3、常量池已被修改为只使用32位的索引，以 简化解释器。<br>4、一个应用，一个虚拟机实例，一个进程（所有android应用的线程都是对应一个linux线程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个android dalvik应用程序都被赋予了一个独立的linux PID(app_*)）</p>
<h3 id="16-JAVA-GC原理"><a href="#16-JAVA-GC原理" class="headerlink" title="16.JAVA GC原理"></a>16.JAVA GC原理</h3><p>垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象<br>，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能。</p>
<h3 id="17-强引用置为null，会不会被回收？"><a href="#17-强引用置为null，会不会被回收？" class="headerlink" title="17.强引用置为null，会不会被回收？"></a>17.强引用置为null，会不会被回收？</h3><p>会，GC执行时，就被回收掉，前提是没有被引用的对象</p>
<h3 id="18-java中的四种引用的区别以及使用场景"><a href="#18-java中的四种引用的区别以及使用场景" class="headerlink" title="18.java中的四种引用的区别以及使用场景"></a>18.java中的四种引用的区别以及使用场景</h3><p>（1）强引用(StrongReference)<br>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>（2）软引用(SoftReference)<br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>（3）弱引用(WeakReference)<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>（4）虚引用(PhantomReference)<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>
<h3 id="19-你所知道的设计模式有哪些？（说自己熟悉的）"><a href="#19-你所知道的设计模式有哪些？（说自己熟悉的）" class="headerlink" title="19.你所知道的设计模式有哪些？（说自己熟悉的）"></a>19.你所知道的设计模式有哪些？（说自己熟悉的）</h3><p>单例模式，观察者模式，工厂模式，builder模式，生产者/消费者模式，适配器模式，装饰者模式。。。。。（23种，随你挑）</p>
<h3 id="20-JVM虚拟机"><a href="#20-JVM虚拟机" class="headerlink" title="20.JVM虚拟机"></a>20.JVM虚拟机</h3><p><img  src="https://docimg2.docs.qq.com/image/ygaQGYeXQgF30sldxSs7Ow?w=1086&h=696"  ><span class="image-caption">img</span></p>
<h5 id="分为：线程私有区-和-共享数据去"><a href="#分为：线程私有区-和-共享数据去" class="headerlink" title="分为：线程私有区 和 共享数据去"></a>分为：线程私有区 和 共享数据去</h5><h5 id="线程私有区分为："><a href="#线程私有区分为：" class="headerlink" title="线程私有区分为："></a>线程私有区分为：</h5><p>​    程序计数器（标记代码执行的顺序，告知程序下一行代码执行什么）</p>
<p>​    局部变量区 （定义的变量和方法的返回地址会存放在该区域中）</p>
<p>​    本地方法栈 （native方法区）</p>
<h5 id="共享数据区："><a href="#共享数据区：" class="headerlink" title="共享数据区："></a>共享数据区：</h5><p>​    常量池</p>
<p>​    堆 （对象的实例，数组的内容 ； GC的主战场）</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>性能优化</title>
    <url>/topic/topic_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-Android性能优化"><a href="#1-Android性能优化" class="headerlink" title="1.Android性能优化"></a>1.Android性能优化</h3><p>布局优化: 减少布局层级，使用ViewStub提高显示速度，布局服用，尽可能少使用warp_content，删除空间中无用的属性,避免过度绘制移除window默认背景，按需显示展位图，自定义View优化，使用canvas.clipRect()识别可见区域<br>启动速度:采用分布加载，异步加载，延期加载提高应用初始化速度，采用线程初始化数据等，合理的刷新机制<br>内存方面:防止内存泄露,使用一些第三方工具检测解决<br>代码优化:遵循Java生命周期<br>安装包优化:删除无用资源，优化图片，代码混淆，避免重复库存在，插件化</p>
<h3 id="2-内存优化"><a href="#2-内存优化" class="headerlink" title="2.内存优化"></a>2.内存优化</h3><p>1.使用性能高的数据结构</p>
<p>2.避免在Android里面使用Enum</p>
<p>3.减小Bitmap对象的内存占用</p>
<p>Bitmap极容易消耗内存，减小创建出来的Bitmap的内存占用可谓是重中之重，通常来说有以下两个措施：</p>
<p>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。<br>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8<br>4.某些场景下，用shape替代图片</p>
<p>有时候会有一些渐变或者描边的UI效果，如果可以用<shape/>画的就尽量不要直接引用图片资源了，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk /res/android&quot;</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">gradient</span> <span class="hljs-attr">android:startColor</span>=<span class="hljs-string">&quot;#000000&quot;</span></span><br><span class="hljs-tag">							<span class="hljs-attr">android:angle</span>=<span class="hljs-string">&quot;0&quot;</span> </span><br><span class="hljs-tag">							<span class="hljs-attr">android:endColor</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>5.代码混淆&amp;减少不必要的类、类库</p>
<p>6.使用Parcelable进行内存间数据传输</p>
<p>7.内存对象的复用</p>
<p>复用系统自带的资源</p>
<p>Android系统本身内置了很多的资源，比如string、color、drawable、anim、style以及简单layout等，这些资源都可以在应用程序中直接引用。这样做不仅能减小APK的大小，还可以在一定程度上减少内存的开销</p>
<p>8.使用handler.obtainMessage()创建Message对象</p>
<p>不要再用new Message()的方式创建Message对象啦！handler.obtainMessage()内部使用了对象池技术，可以有效帮助我们减少创建Message对象的内存消耗</p>
<p>9.避免对象的内存泄露</p>
<p>WebView造成的内存泄漏</p>
<p>属性动画造成内存泄漏</p>
<p>内存泄漏的检测工具</p>
<p>Android Profiler<br>LeakCanary<br>MAT<br>线程造成内存泄漏</p>
<p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，</p>
<p>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<p>资源未关闭造成内存泄漏</p>
<p>集合类造成内存泄漏</p>
<h3 id="3-Android中性能优化"><a href="#3-Android中性能优化" class="headerlink" title="3.Android中性能优化"></a>3.Android中性能优化</h3><p>由于手机硬件的限制，内存和CPU都无法像pc一样具有超大的内存，Android手机上，过多的使用内存，会容易导致oom，过多的使用CPU资源，会导致手机卡顿，甚至导致anr。我主要是从一下几部分进行优化：<br>布局优化，绘制优化，内存泄漏优化，响应速度优化，listview优化，bitmap优化，线程优化<br>布局优化：工具 hierarchyviewer，解决方式：<br>1、删除无用的空间和层级。<br>2、选择性能较低的viewgroup，如Relativelayout，如果可以选择Relativelayout也可以使用LinearLayout,就优先使用LinearLayout，因为相对来说Relativelayout功能较为复杂，会占用更多的CPU资源。<br>3、使用标签重用布局，减少层级，进行预加载，使用的时候才加载。<br>绘制优化<br>绘制优化指view在ondraw方法中避免大量的耗时操作，由于ondraw方法可能会被频繁的调用。<br>1、ondraw方法中不要创建新的局部变量，ondraw方法被频繁的调用，很容易引起GC。<br>2、ondraw方法不要做耗时操作。<br>内存优化：参考内存泄漏。<br>响应优化<br>主线程不能做耗时操作，触摸事件5s,广播10s，service20s。<br>listview优化：<br>1、getview方法中避免耗时操作。<br>2、view的复用和viewholder的使用。<br>3、滑动不适合开启异步加载。<br>4、分页处理数据。<br>5、图片使用三级缓存。<br>Bitmap优化：<br>1、等比例压缩图片。<br>2、不用的图片，及时recycler掉<br>线程优化<br>线程优化的思想是使用线程池来管理和复用线程，避免程序中有大量的Thread，同时可以控制线程的并发数，避免相互抢占资源而导致线程阻塞。<br>其他优化<br>1、少用枚举，枚举占用空间大。<br>2、使用Android特有的数据结构，如SparseArray来代替hashMap。<br>3、适当的使用软引用和弱引用。</p>
<h3 id="4-app优化"><a href="#4-app优化" class="headerlink" title="4.app优化"></a>4.app优化</h3><p>app优化:(工具：Hierarchy Viewer 分析布局 工具：TraceView 测试分析耗时的)</p>
<p>App启动优化，布局优化，响应优化，内存优化，电池使用优化，网络优化</p>
<p><strong>App启动优化(针对冷启动)</strong><br>App启动的方式有三种：<br>冷启动：App没有启动过或App进程被killed, 系统中不存在该App进程, 此时启动App即为冷启动。<br>热启动：热启动意味着你的App进程只是处于后台, 系统只是将其从后台带到前台, 展示给用户。<br>介于冷启动和热启动之间, 一般来说在以下两种情况下发生:<br>(1)用户back退出了App, 然后又启动. App进程可能还在运行, 但是activity需要重建。<br>(2)用户退出App后, 系统可能由于内存原因将App杀死, 进程和activity都需要重启, 但是可以在onCreate中将被动杀死锁保存的状态(saved instance state)恢复。<br>Application的onCreate（特别是第三方SDK初始化），首屏Activity的渲染都不要进行耗时操作，如果有，就可以放到子线程或者IntentService中</p>
<p><strong>布局优化</strong><br>尽量不要过于复杂的嵌套。可以使用，，</p>
<p><strong>响应优化</strong><br>Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity)。<br>页面卡顿的原因：<br>(1)过于复杂的布局.（使用merge，viewstub,include 进行处理）<br>(2)UI线程的复杂运算<br>(3)频繁的GC,导致频繁GC有两个原因:1、内存抖动, 即大量的对象被创建又在短时间内马上被释放.2、瞬间产生大量的对象会严重占用内存区域。</p>
<p><strong>内存优化：</strong></p>
<p>参考内存泄露和内存溢出部分</p>
<p>**<br>**<strong>电池使用优化(使用工具：Batterystats &amp; bugreport)</strong><br>(1)优化网络请求<br>(2)定位中使用GPS, 请记得及时关闭<br>网络优化(网络连接对用户的影响:流量,电量,用户等待)可在Android studio下方logcat旁边那个工具Network Monitor检测<br>API设计：App与Server之间的API设计要考虑网络请求的频次, 资源的状态等. 以便App可以以较少的请求来完成业务需求和界面的展示.<br>Gzip压缩：使用Gzip来压缩request和response, 减少传输数据量, 从而减少流量消耗.<br>图片的Size：可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费.<br>网络缓存：适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗.</p>
<p><strong>图片优化</strong><br>(1)对图片本身进行操作。尽量不要使用setImageBitmap、setImageResource、BitmapFactory.decodeResource来设置一张大图，因为这些方法在完成decode后，<br>最终都是通过java层的createBitmap来完成的，需要消耗更多内存.<br>(2)图片进行缩放的比例，SDK中建议其值是2的指数值,值越大会导致图片不清晰。<br>(3)不用的图片记得调用图片的recycle()方法</p>
<h3 id="5-什么是ANR？"><a href="#5-什么是ANR？" class="headerlink" title="5.什么是ANR？"></a>5.什么是ANR？</h3><p>应用程序无响应，主线程做了耗时操作导致的，根本原因是：主线程被卡了，导致应用在5秒时间未响应用户的输入事件。</p>
<p>ANR有三种类型：</p>
<p>1，keyDispatchTimeOut（5秒），按键或者触摸事件在特定事件内无响应</p>
<p>2，BroadcastTimeOut（10秒），BroadcastReceiver 在特定事件内无法处理完成</p>
<p>3，ServiceTimeOut（20秒） ，超时的原因一般有2种：当前事件没有机会得到处理，当前正在处理却没有及时完成。</p>
<p>如何解决ANR？</p>
<p>使用AsyncTask处理耗时的IO操作</p>
<p>使用Thread或者HandlerThread提高优先级</p>
<p>使用Handler来处理工作现场的耗时任务</p>
<h3 id="6-什么情况导致OOM？"><a href="#6-什么情况导致OOM？" class="headerlink" title="6.什么情况导致OOM？"></a>6.什么情况导致OOM？</h3><p>当前占用的内存加上我们申请的内存资源超过Dalvik虚拟机的最大内存限制就会抛出Out of memory异常。</p>
<ol>
<li>内存泄漏多了就容易导致OOM</li>
<li>大图的处理。压缩图片。平时开发就要注意对象的频繁创建和回收。</li>
</ol>
<p>如何解决OOM？</p>
<p>1、减少对象的内存占用</p>
<p>使用轻量级的数据结构，替代hashmap，用sparseArray。Hashmap会导致一些没必要的自动装箱和拆箱。</p>
<p>适当的在android中用枚举，替代使用普通的static常量</p>
<p>关于bitmap:图片的显示，滑动不加载，停止加载，即时释放内存。</p>
<p>谨慎使用多线程</p>
<h3 id="7-Bitmap"><a href="#7-Bitmap" class="headerlink" title="7.Bitmap"></a>7.Bitmap</h3><p>recycle：对bitmap的内存的回收，方法不可逆；官网不建议调用，说系统会走垃圾回收机制，不过可以自己根据需求来调用</p>
<p>LruCache，内部用一个LinkedHashMap，</p>
<p>提供get，put 方法来完成缓存的添加和获取操作，</p>
<p>当缓存满了之后，Lru内部一个trimToSize方法会移除较早缓存对象，</p>
<p>然后把新的缓存对象添加到缓存中；</p>
<p>缩略图:通过inJustDecodeBounds = true来设置加载缩略图进内存</p>
<p>三级缓存，网络，本地，内存: 首次从网络获取，保存到sd卡和内存相应的各一份，如果再次获取，那就从内存，sd卡，网络以此找缓存</p>
<h3 id="8-UI卡顿"><a href="#8-UI卡顿" class="headerlink" title="8.UI卡顿"></a>8.UI卡顿</h3><p>原因：</p>
<p>1，人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</p>
<p>2，布局Layout过于复杂，无法在16ms内完成渲染</p>
<p>3，同一时间动画执行的次数过多，导致CPU或GPU负载过重</p>
<p>4，View过渡绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重</p>
<p>5，View频繁的触发measure，layout，导致measure，layout累积耗时过多及整个View频繁的重新渲染</p>
<p>6，内存频繁触发GC过多，导致暂时阻塞渲染操作</p>
<p>7，冗余资源以及逻辑等导致加载和执行缓慢</p>
<p>8，ANR</p>
<p>优化总结：</p>
<p>1，布局优化，不要冗余嵌套，include导入，merge标签，如果足够复杂就用自定义view来处理</p>
<p>2，列表滑动的时候不要加载图片，滑动的时候显示缩略图或者默认图</p>
<p>3，图片和背景内存分配，减少背景压缩图片大小</p>
<p>4，避免ANR。</p>
<h3 id="9-内存泄漏是什么情况导致的？"><a href="#9-内存泄漏是什么情况导致的？" class="headerlink" title="9.内存泄漏是什么情况导致的？"></a>9.内存泄漏是什么情况导致的？</h3><p>内存泄露就是指该被GC垃圾回收的，但被一个生命周期比它长的对象仍然在引用它，导致无法回收，造成内存泄露，过多的内存泄露会导致OOM。</p>
<p>1、非静态内部类、匿名内部类：非静态内部类、匿名内部类 都会持有外部类的一个引用，如果有一个静态变量引用了非静态内部类或者匿名内部类，导致非静态内部类或者匿名内部类的生命周期比外部类（Activity）长，就会导致外部类在该被回收的时候，无法被回收掉，引起内存泄露, 除非外部类被卸载。</p>
<p>解决办法：将非静态内部类、匿名内部类 改成静态内部类，或者直接抽离成一个外部类。 如果在静态内部类中，需要引用外部类对象，那么可以将这个引用封装在一个WeakReference中。</p>
<p>2、静态的View:当一个Activity经常启动，但是对应的View读取非常耗时，我们可以通过静态View变量来保持对该Activity的rootView引用。这样就可以不用每次启动Activity都去读取并渲染View了。但View attach到我们的Window上，就会持有一个（Context）Activity的引用，而我们的View有是一个静态的变量，所以导致Activity</p>
<p>在Activity中定义Handler对象，那么Handler持有Activty的引用。而每个Message对象是持有Handler的引用的（Message对象的target属性持有Handler引用），从而导致Message间接引用到了Activity。如果在Activty destroy之后，消息队列中还有Message对象，Activty是不会被回收的。</p>
<p>解决办法： 将Handler放入单独的类或者将Handler放入到静态内部类中（静态内部类不会持有外部类的引用）。如果想要在handler内部去调用所在的外部类Activity，可以在handler内部使用弱引用的方式指向所在Activity，在onDestory时，调用相应的方法移除回调和删除消息。</p>
<p>4、资源对象没关闭造成内存泄漏：当我们打开资源时，一般都会使用缓存。比如读写文件资源、打开数据库资源、使用Bitmap资源等等。当我们不再使用时，应该关闭它们，使得缓存内存区域及时回收。</p>
<p>解决办法：使用try finally结合，在try块中打开资源，在finally中关闭资源</p>
<h3 id="10-Android内存泄露"><a href="#10-Android内存泄露" class="headerlink" title="10.Android内存泄露"></a>10.Android内存泄露</h3><p>单例（如果使用context容易泄露，应该使用getApplicationContext）</p>
<p>匿名内部类</p>
<p>避免使用static变量</p>
<p>资源未关闭造成的内存泄露</p>
<p>AsyncTask造成的内存泄露</p>
<h3 id="11-内存泄露和内存溢出的区别？"><a href="#11-内存泄露和内存溢出的区别？" class="headerlink" title="11.内存泄露和内存溢出的区别？"></a>11.内存泄露和内存溢出的区别？</h3><p>内存泄漏：</p>
<p>1、内存泄漏：指程序中已动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等严重后果。</p>
<p>2、一次内存泄漏似乎不会有大的影响，但内存泄漏后堆积的结果就是内存溢出。</p>
<p>3、内存泄漏具有隐蔽性，积累性的特征，比其他内存非法访问错误更难检测。这是因为内存泄漏产生的原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏不会直接产生可观察的错误，而是逐渐积累，降低系统的整体性性能。</p>
<p>4、如何有效的进行内存分配和释放，防止内存泄漏，是软件开发人员的关键问题，比如一个服务器应用软件要长时间服务多个客户端，若存在内存泄漏，则会逐渐堆积，导致一系列严重后果。</p>
<p>内存溢出：</p>
<p>指程序在申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，就会导致内存不够用，报错OOM，即出现内存溢出的错误。</p>
<h3 id="12-内存管理"><a href="#12-内存管理" class="headerlink" title="12.内存管理"></a>12.内存管理</h3><p>1，内存管理机制</p>
<p>分配机制</p>
<p>内存回收机制</p>
<p>2，Android的内存管理机制</p>
<p>系统会给每个app都分配一定数量的内存</p>
<p>3，内存优化方法</p>
<p>当Service完成任务后，尽量停止它。</p>
<h3 id="13-冷启动优化"><a href="#13-冷启动优化" class="headerlink" title="13.冷启动优化"></a>13.冷启动优化</h3><p>1、冷启动就是在启动应用前，系统中没有该应用的任何进程信息</p>
<p>减少onCreate 方法的工作量</p>
<p>不要让Application参与业务的操作</p>
<p>不要在Application进行耗时操作</p>
<p>不要以静态变量的方式在Application中保存数据</p>
<p>减少布局深度，viewstub</p>
<h3 id="14-缩小APK包的大小"><a href="#14-缩小APK包的大小" class="headerlink" title="14.缩小APK包的大小"></a>14.缩小APK包的大小</h3><p>使用Proguard混淆代码，不使用重复或不用的代码，谨慎添加libs、大多数情况下只需要支持 armabi和x86的架构就可以了</p>
<p>使用Lint工具查找没有使用的自然，然后去除不使用的所有资源文件，图片等</p>
<p>使用tinypng对图片压缩预处理，多使用9.png，拉伸区域切小</p>
<p>图片使用xhdpi，更具需要提供差异其他部分即可</p>
<p>重用已有的图片资源，对称的图片只需要一张，用代码来控制旋转</p>
<p>能用代码实现绘制的功能，就不要用图片，比如button的背景</p>
<h3 id="15-大图加载，优化大图"><a href="#15-大图加载，优化大图" class="headerlink" title="15.大图加载，优化大图"></a>15.大图加载，优化大图</h3><h5 id="优化思路和方向"><a href="#优化思路和方向" class="headerlink" title="优化思路和方向"></a>优化思路和方向</h5><ol>
<li>根据分辨率适配，压缩图片</li>
<li>使用合适的解码方式</li>
<li>图片缓存</li>
<li>使用完及时释放图片资源</li>
</ol>
<h5 id="一）根据分辨率适配-amp-压缩图片"><a href="#一）根据分辨率适配-amp-压缩图片" class="headerlink" title="一）根据分辨率适配 &amp; 压缩图片"></a><strong>一）根据分辨率适配 &amp; 压缩图片</strong></h5><ol>
<li>采样率–inSimpleSize</li>
</ol>
<p>根据View的大小利用BitmapFactory.Options计算合适的inSimpleSize（采样率）来对Bitmap进行相对应的裁剪，以减少Bitmap对内存对使用。压缩图片的像素，一张图片的大小=图片类型<em>宽</em>高，通过改变三个值减小图片所占用的内存，防止OOM，这样会使图片失帧。</p>
<ol>
<li>质量压缩</li>
</ol>
<p>Bitmap.compress()确实可以压缩图片，但压缩的是存储大小，即放到disk上的大小。尝试过把品质设置为不同值，decode出来的Bitmap大小没变，但显示照片的质量非常差。 BitmapFactory.decodeByteArray方法对压缩后的Bitmap大小依然和未压缩过一样，如果 你想要显示的Bitmap占用的内存少一点，还是需要去设置加载的像素长度和宽度（变成 缩略图），即尺寸压缩。</p>
<h5 id="二）使用合适的解码方式"><a href="#二）使用合适的解码方式" class="headerlink" title="二）使用合适的解码方式"></a><strong>二）使用合适的解码方式</strong></h5><p>图片占用内存大小的计算公式 = 图片高度 * 图片宽度 * 一个像素占用的内存大小 = 800 * 600 * 4byte = 1875KB = 1.83M （4byte是一种解码方式ARGB_8888）</p>
<p><img  src="https://docimg1.docs.qq.com/image/G5fZMSjSUB_Dhk8JPkGk2Q?w=648&h=445"  ><span class="image-caption">img</span></p>
<h5 id="三）图片缓存"><a href="#三）图片缓存" class="headerlink" title="三）图片缓存"></a><strong>三）图片缓存</strong></h5><p>三级缓存：内存缓存–&gt;本地缓存（硬盘、文件、数据库）–&gt;网络缓存</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>第三方框架</title>
    <url>/topic/topic_%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="1-dagger2"><a href="#1-dagger2" class="headerlink" title="1.dagger2"></a>1.dagger2</h3><p>Dagger2是一个主要用于依赖注入的框架，减少初始化对象操作，降低耦合度</p>
<h3 id="2-Xutils-OKhttp-Volley-Retrofit对比（源码需要自己去看）"><a href="#2-Xutils-OKhttp-Volley-Retrofit对比（源码需要自己去看）" class="headerlink" title="2.Xutils, OKhttp, Volley, Retrofit对比（源码需要自己去看）"></a>2.Xutils, OKhttp, Volley, Retrofit对比（源码需要自己去看）</h3><p>Xutils这个框架非常全面，可以进行网络请求，可以进行图片加载处理，可以数据储存，还可以对view进行注解，使用这个框架非常方便，但是缺点也是非常明显的，使用这个项目，会导致项目对这个框架依赖非常的严重，一旦这个框架出现问题，那么对项目来说影响非常大的。</p>
<p>OKhttp：Android开发中是可以直接使用现成的api进行网络请求的。就是使用HttpClient,HttpUrlConnection进行操作。okhttp针对Java和Android程序，封装的一个高性能的http请求库，支持同步，异步，而且okhttp又封装了线程池，封装了数据转换，封装了参数的使用，错误处理等。API使用起来更加的方便。但是我们在项目中使用的时候仍然需要自己在做一层封装，这样才能使用的更加的顺手。</p>
<p>Volley：Volley是Google官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持HttpClient、HttpUrlConnection， 甚至支持OkHttp，而且Volley里面也封装了ImageLoader，所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框架强大，对于简单的需求可以使用，稍复杂点的需求还是需要用到专门的图片加载框架。Volley也有缺陷，比如不支持post大数据，所以不适合上传文件。不过Volley设计的初衷本身也就是为频繁的、数据量小的网络请求而生。</p>
<p>Retrofit：Retrofit是Square公司出品的默认基于OkHttp封装的一套RESTful网络请求框架，RESTful是目前流行的一套api设计的风格， 并不是标准。Retrofit的封装可以说是很强大，里面涉及到一堆的设计模式,可以通过注解直接配置请求，可以使用不同的http客户端，虽然默认是用http ，可以使用不同Json Converter 来序列化数据，同时提供对RxJava的支持，使用Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较高的门槛。</p>
<p>Volley VS OkHttp<br>Volley的优势在于封装的更好，而使用OkHttp你需要有足够的能力再进行一次封装。而OkHttp的优势在于性能更高，因为 OkHttp基于NIO和Okio ，所以性能上要比 Volley更快。IO 和 NIO这两个都是Java中的概念，如果我从硬盘读取数据，第一种方式就是程序一直等，数据读完后才能继续操作这种是最简单的也叫阻塞式IO,还有一种是你读你的,程序接着往下执行，等数据处理完你再来通知我，然后再处理回调。而第二种就是 NIO 的方式，非阻塞式， 所以NIO当然要比IO的性能要好了,而 Okio是 Square 公司基于IO和NIO基础上做的一个更简单、高效处理数据流的一个库。理论上如果Volley和OkHttp对比的话，更倾向于使用 Volley，因为Volley内部同样支持使用OkHttp,这点OkHttp的性能优势就没了， 而且 Volley 本身封装的也更易用，扩展性更好些。</p>
<p>OkHttp VS Retrofit<br>毫无疑问，Retrofit 默认是基于 OkHttp 而做的封装，这点来说没有可比性，肯定首选 Retrofit。</p>
<p>Volley VS Retrofit<br>这两个库都做了不错的封装，但Retrofit解耦的更彻底,尤其Retrofit2.0出来，Jake对之前1.0设计不合理的地方做了大量重构， 职责更细分，而且Retrofit默认使用OkHttp,性能上也要比Volley占优势，再有如果你的项目如果采用了RxJava ，那更该使用 Retrofit 。所以这两个库相比，Retrofit更有优势，在能掌握两个框架的前提下该优先使用 Retrofit。但是Retrofit门槛要比Volley稍高些，要理解他的原理，各种用法，想彻底搞明白还是需要花些功夫的，如果你对它一知半解，那还是建议在商业项目使用Volley吧。</p>
<h3 id="3-Universal-ImageLoader，Picasso，Fresco，Glide对比-源码的话，得自己去看"><a href="#3-Universal-ImageLoader，Picasso，Fresco，Glide对比-源码的话，得自己去看" class="headerlink" title="3.Universal-ImageLoader，Picasso，Fresco，Glide对比( 源码的话，得自己去看)"></a>3.Universal-ImageLoader，Picasso，Fresco，Glide对比( 源码的话，得自己去看)</h3><p>Fresco </p>
<p> Facebook 推出的开源图片缓存工具，主要特点包括：两个内存缓存加上 Native 缓存构成了三级缓存，<br>优点：</p>
<p>图片存储在安卓系统的匿名共享内存, 而不是虚拟机的堆内存中, 图片的中间缓冲数据也存放在本地堆内存, 所以, 应用程序有更多的内存使用, 不会因为图片加载而导致oom, 同时也减少垃圾回收器频繁调用回收 Bitmap 导致的界面卡顿, 性能更高。<br>渐进式加载 JPEG 图片, 支持图片从模糊到清晰加载。<br>图片可以以任意的中心点显示在 ImageView, 而不仅仅是图片的中心。<br>JPEG 图片改变大小也是在 native 进行的, 不是在虚拟机的堆内存, 同样减少 OOM。<br>很好的支持 GIF 图片的显示。<br>缺点:<br>框架较大, 影响 Apk 体积<br>使用较繁琐<br>Universal-ImageLoader：</p>
<p>（估计由于HttpClient被Google放弃，作者就放弃维护这个框架）</p>
<p>优点：<br>1.支持下载进度监听<br>2.可以在 View 滚动中暂停图片加载，通过 PauseOnScrollListener 接口可以在 View 滚动中暂停图片加载。<br>3.默认实现多种内存缓存算法 这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。<br>4.支持本地缓存文件名规则定义</p>
<p>Picasso 优点</p>
<p>1.自带统计监控功能。支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。<br>2.支持优先级处理。每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。<br>3.支持延迟到图片尺寸计算完成加载<br>4.支持飞行模式、并发线程数根据网络类型而变。 手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4，4g 为 3，3g 为 2。 这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。<br>5.“无”本地缓存。无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。</p>
<p>Glide 优点</p>
<p>不仅仅可以进行图片缓存还可以缓存媒体文件。Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。<br>支持优先级处理。<br>与 Activity/Fragment 生命周期一致，支持 trimMemory。Glide 对每个 context 都保持一个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致，并且有对应的 trimMemory 接口实现可供调用。<br>支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。<br>内存友好。Glide 的内存缓存有个 active 的设计，从内存缓存中取数据时，不像一般的实现用 get，而是用 remove，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。内存缓存更小图片，Glide 以 url、view_width、view_height、屏幕的分辨率等做为联合 key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小与 Activity/Fragment 生命周期一致，支持 trimMemory。图片默认使用默认 RGB_565 而不是 ARGB_888，虽然清晰度差些，但图片更小，也可配置到 ARGB_888。<br>6.Glide 可以通过 signature 或不使用本地缓存支持 url 过期</p>
<h3 id="4-说说EventBus的原理"><a href="#4-说说EventBus的原理" class="headerlink" title="4.说说EventBus的原理"></a>4.说说EventBus的原理</h3><p>1、调用getDefault(),里面采用单利双重锁模式创建Eventbus对象</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> EventBus defaultInstance;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">EventBus <span class="hljs-title">getDefault</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (defaultInstance == <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">synchronized</span> (EventBus.class) &#123;<br>					<span class="hljs-keyword">if</span> (defaultInstance == <span class="hljs-keyword">null</span>) &#123;<br>							defaultInstance = <span class="hljs-keyword">new</span> EventBus();<br>					&#125;<br>			&#125;<br>&#125;<br><span class="hljs-keyword">return</span> defaultInstance;<br></code></pre></td></tr></table></figure>



<p>2、构造方法 2.1,粘性事件,保存到ConCurrenHashMap集合,(在构造方法中实现), HashMap效率高,但线程不安全,在多线程的情况下,尽量用ConcurrentHashMap,避免多线程并发异常</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">EventBus(EventBusBuilder <span class="hljs-keyword">builder) </span>&#123;<br>      logger = <span class="hljs-keyword">builder.getLogger();</span><br><span class="hljs-keyword"></span>      <span class="hljs-keyword">subscriptionsByEventType </span>= new HashMap&lt;&gt;();<br>      typesBySubscriber = new HashMap&lt;&gt;();<br>      stickyEvents = new ConcurrentHashMap&lt;&gt;()<span class="hljs-comment">; //线程安全,</span><br>      mainThreadSupport = <span class="hljs-keyword">builder.getMainThreadSupport();</span><br><span class="hljs-keyword"></span>      mainThreadPoster = mainThreadSupport != null ? 					<br>      mainThreadSupport.createPoster(this) : null;<br>      <span class="hljs-keyword">backgroundPoster </span>= new <span class="hljs-keyword">BackgroundPoster(this);</span><br><span class="hljs-keyword"></span>      asyncPoster = new AsyncPoster(this);<br>      indexCount = <span class="hljs-keyword">builder.subscriberInfoIndexes </span>!= null ? <br>      <span class="hljs-keyword">builder.subscriberInfoIndexes.size() </span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">subscriberMethodFinder </span>= new <br>      <span class="hljs-keyword">SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="hljs-keyword"></span>      <span class="hljs-keyword">builder.strictMethodVerification, </span><br>      <span class="hljs-keyword">builder.ignoreGeneratedIndex);</span><br><span class="hljs-keyword"></span>      logSubscriberExceptions = <span class="hljs-keyword">builder.logSubscriberExceptions;</span><br><span class="hljs-keyword"></span>      logNoSubscriberMessages = <span class="hljs-keyword">builder.logNoSubscriberMessages;</span><br><span class="hljs-keyword"></span>      sendSubscriberExceptionEvent = <br>      <span class="hljs-keyword">builder.sendSubscriberExceptionEvent;</span><br><span class="hljs-keyword"></span>      sendNoSubscriberEvent = <span class="hljs-keyword">builder.sendNoSubscriberEvent;</span><br><span class="hljs-keyword"></span>      throwSubscriberException = <span class="hljs-keyword">builder.throwSubscriberException;</span><br><span class="hljs-keyword"></span>      eventInheritance = <span class="hljs-keyword">builder.eventInheritance;</span><br><span class="hljs-keyword"></span>      executorService = <span class="hljs-keyword">builder.executorService;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure>



<p>3、注册register()方法主要做了3件事:</p>
<p>3.1,从缓存中获取订阅方法列表,</p>
<p>3.2,如果缓存中不存在则通过反射获取到订阅者所有的函数,</p>
<p>3.3,遍历再通过权限修饰符.参数长度(只允许一个参数).注解(@Subscribe)来判断是否是具备成为订阅函数的前提</p>
<p>3.4,具备则构建一个SubscriberMethod(订阅方法，其相当于一个数据实体类,包含方法,threadmode,参数类型,优先级,是否粘性事件这些参数),循环结束订阅函数列表构建完成添加进入缓存</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> subscriber</span>)</span> &#123;<br>		Class subscriberClass = subscriber.getClass();<br>		<span class="hljs-comment">//找到订阅者的方法.找出传进来的订阅者的所有订阅方法,然后遍历订阅者的方法.</span><br>		List subscriberMethods = 		<br>		subscriberMethodFinder.findSubscriberMethods(subscriberClass);<br>		synchronized (<span class="hljs-built_in">this</span>) &#123;<br>				<span class="hljs-keyword">for</span> (SubscriberMethod subscriberMethod : 	subscriberMethods) &#123;<br>				<span class="hljs-comment">//订阅者的注册</span><br>				subscribe(subscriber, subscriberMethod);<br>				&#125;<br>		&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">findUsingReflectionInSingleClass</span>(<span class="hljs-params">FindState findState</span>)</span> &#123;<br>		Method[] methods;<br>		<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-comment">// 通过反射来获取订阅者中所有的方法</span><br>				methods = findState.clazz.getDeclaredMethods();<br>		&#125; <span class="hljs-keyword">catch</span> (Throwable th) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>4、事件发送post()</p>
<p>4.1,post调用后先使用ThreadLocal来存储事件,他可以隔离多个线程对数据的访问冲突<br>4.2,根据事件类型(也就是Post参数的类型)为key从subscriptionsByEventType获取订阅方法和订阅者,这个容器不了解的可以看下注册的总结<br>此处我们已经具备了订阅者.订阅方法.待发送事件.post线程.threadmode等信息</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span>(<span class="hljs-params">Object <span class="hljs-keyword">event</span></span>)</span> &#123;<br>		<span class="hljs-comment">//PostingThreadState 保存着事件队列和线程状态信息</span><br>		PostingThreadState postingState = currentPostingThreadState.<span class="hljs-keyword">get</span>();<br>		<span class="hljs-comment">//获取事假队列,并将当期事件插入事件队列</span><br>		List eventQueue = postingState.eventQueue;<br>		eventQueue.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">event</span>);<br><br>		<span class="hljs-keyword">if</span> (!postingState.isPosting) &#123;<br>    		postingState.isMainThread = isMainThread();<br>    		postingState.isPosting = <span class="hljs-literal">true</span>;<br>    		<span class="hljs-keyword">if</span> (postingState.canceled) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EventBusException(<span class="hljs-string">&quot;Internal error. Abort state was not reset&quot;</span>);<br>    		&#125;<br>    		<span class="hljs-keyword">try</span> &#123;<br>     				<span class="hljs-comment">//处理队列中的所有事件,</span><br>    				<span class="hljs-comment">//将所有的事情交给postSingleEvent处理,并移除该事件</span><br>      			<span class="hljs-keyword">while</span> (!eventQueue.isEmpty()) &#123;<br>            		postSingleEvent(eventQueue.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>), postingState);<br>        		&#125;<br>    		&#125; <span class="hljs-keyword">finally</span> &#123;<br>        postingState.isPosting = <span class="hljs-literal">false</span>;<br>        postingState.isMainThread = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5、取消事件订阅</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span>(<span class="hljs-params">Object subscriber</span>)</span> &#123;<br>		<span class="hljs-comment">//typesBySubscriber是一个map集合,</span><br>		<span class="hljs-comment">//通过subscriber找到 subscribedTypes (事件类型集合),</span><br>		List&gt; subscribedTypes = typesBySubscriber.<span class="hljs-keyword">get</span>(subscriber);<br>		<span class="hljs-keyword">if</span> (subscribedTypes != <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">for</span> (Class eventType : subscribedTypes) &#123;<br>						unsubscribeByEventType(subscriber, eventType);<br>				&#125;<br>		&#125;<br>		<span class="hljs-comment">//将subscriber对应的eventType从typesBySubscriber移除</span><br>		typesBySubscriber.<span class="hljs-keyword">remove</span>(subscriber);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-说说EventBus及使用方法"><a href="#5-说说EventBus及使用方法" class="headerlink" title="5.说说EventBus及使用方法"></a>5.说说EventBus及使用方法</h3><p>EvenetBus是一种发布-订阅事件总线.代码简洁,开销小,并很好的实现了发送者和接收者的解耦.</p>
<p>(是一种观察者模式)</p>
<p>使用：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> ‘org.greenrobot:eventbus:<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure>

<p>传递数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageEvent</span> </span>&#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> message;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">MessageEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>)</span>&#123;<br>				<span class="hljs-built_in">this</span>.message = message;<br>		&#125;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>)</span>&#123;<br>				<span class="hljs-keyword">return</span> message;<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//注册成为订阅者</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.register(this);<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//解除注册</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.unregister(this);<br></code></pre></td></tr></table></figure>

<p>在发送消息的地方</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageEvent(<span class="hljs-string">&quot;从fragment将数据传递到activity22222222&quot;</span>)</span>);<br></code></pre></td></tr></table></figure>

<p>四个订阅方法：</p>
<p>onEvent:</p>
<p>如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p>
<p>onEventMainThread:</p>
<p>如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。</p>
<p>onEventBackground:</p>
<p>如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</p>
<p>onEventAsync:</p>
<p>使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync。</p>
<p>3.0以前订阅者的订阅方法为onEvent()、onEventMainThread()、onEventBackgroundThread()和onEventAsync()。在Event Bus3.0之后统一采用注解@Subscribe的形式<br>@Subscribe(threadMode = ThreadMode.MAIN)<br>public void eventBusMain(String str){<br>Log.i(“TAG”, “MAIN:”+str+” Thread=“+Thread.currentThread().getId());</p>
<h3 id="6-用到的一些开源框架，介绍一个看过源码的，内部实现过程。"><a href="#6-用到的一些开源框架，介绍一个看过源码的，内部实现过程。" class="headerlink" title="6.用到的一些开源框架，介绍一个看过源码的，内部实现过程。"></a>6.用到的一些开源框架，介绍一个看过源码的，内部实现过程。</h3><p>这个自己准备几个网络请求的，图片加载的，异步任务的等等（最好手写出流程图）</p>
<h3 id="7-Glide图片加载"><a href="#7-Glide图片加载" class="headerlink" title="7.Glide图片加载"></a>7.Glide图片加载</h3><h5 id="Glide缓存策略"><a href="#Glide缓存策略" class="headerlink" title="Glide缓存策略:"></a>Glide缓存策略:</h5><p><img  src="https://docimg10.docs.qq.com/image/AZ147Hzad5zteKwI7QYuXA?w=1010&h=610"  ><span class="image-caption">img</span></p>
<h5 id="Glide缓存机制"><a href="#Glide缓存机制" class="headerlink" title="Glide缓存机制"></a>Glide缓存机制</h5><p>1、内存(活动缓存、内存缓存 )、磁盘缓存(资源类型，原始数据)</p>
<p>加载时依次顺序：活动缓存、内存缓存、资源缓存、磁盘缓存</p>
<p>活动缓存（界面展示时存入内存缓存，相当于创建一个Map集合，存在Map集合中，当界面销毁后，将活动缓存中的存入到内存缓存）</p>
<p>内存缓存(LruCache缓存：最近最少使用原则，当LinkedHashMap中容量大于最大容量时，移除最近不常使用的图片。sizeOf()计算图片大小，trim ToSize()计算当前LruCache容量是否超出MaxSize。如果是LruCache容量达到灵界点，自己移除的图片，则不需要加入到复用池中。。当活动缓存从内存缓存中获取图片时，内存缓存需要将该图片移除掉，这时候需要将该图片加入到复用池中。。（复用池也是用了LruCache原则，当复用池内存达到灵界点时，则将不常用的图片内存释放掉）)</p>
<p>Glide.with(Contex)主要是获取到一个RequestManager管理类，并创建一个空白的Fragment，将RequestManager管理类与Fragment进行绑定，进行生命周期的监听，RequestManager通过实现一个Lifecy接口，将Glide和fragment生命周期进行绑定。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/topic/topic_java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-二分查找算法-？"><a href="#1-二分查找算法-？" class="headerlink" title="1.二分查找算法 ？"></a>1.二分查找算法 ？</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>二分查找也称为折半查找，它是一种效率较高的查找方法。</p>
<h5 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h5><p>数组必须是有序的，递增或递减。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>比较次数较少、查找速度快、平均性能好。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>待查表为顺序表，插入和删除困难。</p>
<h5 id="查找思想："><a href="#查找思想：" class="headerlink" title="查找思想："></a>查找思想：</h5><ol>
<li><p>首先确定确定整个查找区间的中间位置mid = (start + end)/2；</p>
</li>
<li><p>用待查关键字值与中间位置的关键字值进行比较，若相等则返回下标，不相等有两种情况：</p>
<ol>
<li><p>arr[mid] &gt; key 查找范围缩小到左半区域，具体表现为：start不变，end = mid - 1;</p>
</li>
<li><p>arr[mid] &lt; key 查找范围缩小到右半区域，具体表现为：end不变，start = mid + 1; </p>
</li>
</ol>
</li>
<li><p>对确定的缩小区域，再进行折半查找，重复以上步骤。</p>
</li>
</ol>
<p>注意点：</p>
<p>循环条件，只有满足start &lt;= end才执行</p>
<p>两种实现方式：</p>
<ol>
<li>非递归：</li>
</ol>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">/**<br> * @param arr：需要查找的有序数组<br> * @param <span class="hljs-built_in">left</span>：数组的左边界<br> * @param <span class="hljs-built_in">right</span>：数组的右边界<br> * @param key：需要查找的key<br> * @return： 返回找到的下标，找不到返回-<span class="hljs-number">1</span><br> */<br>public static <span class="hljs-built_in">int</span> binarySearch1(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> ,<span class="hljs-built_in">int</span> key) &#123;<br>    while ( <span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span> ) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">if</span> (key &lt; arr[<span class="hljs-built_in">mid</span>]) &#123;<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>        &#125; else <span class="hljs-built_in">if</span> (key &gt; arr[<span class="hljs-built_in">mid</span>]) &#123;<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>        &#125;else&#123;<br>            return <span class="hljs-built_in">mid</span>;<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="2">
<li>递归方式</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param arr：需要查找的有序数组</span><br><span class="hljs-comment"> * @param left：数组的左边界</span><br><span class="hljs-comment"> * @param right：数组的右边界</span><br><span class="hljs-comment"> * @param key：需要查找的key</span><br><span class="hljs-comment"> * @return： 返回找到的下标，找不到返回-1</span><br><span class="hljs-comment"> */</span><br>public static <span class="hljs-built_in">int</span> binary<span class="hljs-constructor">Search(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span> ,<span class="hljs-params">int</span> <span class="hljs-params">key</span>)</span> &#123;<br><span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> mid = (left + right)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (key &lt; arr<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span>) &#123;<br>        return binary<span class="hljs-constructor">Search(<span class="hljs-params">arr</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span> - 1, <span class="hljs-params">key</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; arr<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span>) &#123;<br>        return binary<span class="hljs-constructor">Search(<span class="hljs-params">arr</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">right</span>, <span class="hljs-params">key</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        return mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-冒泡排序算法-？"><a href="#2-冒泡排序算法-？" class="headerlink" title="2.冒泡排序算法 ？"></a>2.冒泡排序算法 ？</h3><p>定义：</p>
<p>冒泡排序算法也称为下沉排序。在这种类型的排序中，要排序的列表的相邻元素之间互相比较。如果它们按顺序排列错误，将交换值并以正确的顺序排列，直到最终结果“浮”出水面。</p>
<p>代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">int[] numbers = new int[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>&#125;;<br>int i, <span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; numbers.length - 1; i++) &#123;</span><br>    for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; numbers.length - 1 - i; j++) &#123;</span><br>        if (numbers[<span class="hljs-keyword">j] </span>&lt; numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]) &#123;<br>            int temp = numbers[<span class="hljs-keyword">j];</span><br><span class="hljs-keyword"></span>            numbers[<span class="hljs-keyword">j] </span>= numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>];<br>            numbers[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二次for为什么要 -i 不 -i 对排序结果有影响吗？</p>
<p>因为i后面已经排过序了，不 -i 对排序结果没有影响，只是i后面的值每次又比较了一遍。</p>
<h3 id="3-类加载的过程？"><a href="#3-类加载的过程？" class="headerlink" title="3.类加载的过程？"></a>3.类加载的过程？</h3><p>类加载的过程可以分为：</p>
<p>加载：将类的全限定名转化为二进制流，再将二进制流转化为方法区中的类型信息，从而生成一个Class对象。<br>验证：对类的验证，包括格式、字节码、属性等。<br>准备：为类变量分配内存并设置初始值。<br>解析：将常量池的符号引用转化为直接引用。<br>初始化：执行类中定义的Java程序代码，包括类变量的赋值动作和构造函数的赋值。<br>使用<br>卸载</p>
<h3 id="4-说一下四种引用以及他们的区别？"><a href="#4-说一下四种引用以及他们的区别？" class="headerlink" title="4.说一下四种引用以及他们的区别？"></a>4.说一下四种引用以及他们的区别？</h3><p>强引用：强引用还在，垃圾搜集器就不会回收被引用的对象。<br>软引用：对于软引用关联的对象，在系统发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>弱引用：被若引用关联的对象只能存活到下一次GC之前。<br>虚引用：为对象设置虚引用的目的仅仅是为了GC之前收到一个系统通知。</p>
<h3 id="5-如何判断对象可回收？"><a href="#5-如何判断对象可回收？" class="headerlink" title="5.如何判断对象可回收？"></a>5.如何判断对象可回收？</h3><p>判断一个对象可以回收通常采用的算法是引用几算法和可达性算法。由于互相引用导致的计数不好判断，Java采用的可达性算法。</p>
<p>可达性算法的思路是：通过一些列被成为GC Roots的对象作为起始点，自上往下从这些起点往下搜索，搜索所有走过的路径称为引用链，如果一个对象没有跟任何引用链相关联的时候，则证明该对象不可用，所以这些对象就会被判定为可以回收。</p>
<h3 id="6-String-s1-“abc”和String-s2-new-String-“abc”-的区别，生成对象的情况"><a href="#6-String-s1-“abc”和String-s2-new-String-“abc”-的区别，生成对象的情况" class="headerlink" title="6.String s1 = “abc”和String s2 = new String(“abc”)的区别，生成对象的情况"></a>6.String s1 = “abc”和String s2 = new String(“abc”)的区别，生成对象的情况</h3><p>指向方法区：”abc”是常量，所以它会在方法区中分配内存，如果方法区已经给”abc”分配过内存，则s1会直接指向这块内存区域。<br>指向Java堆：new String(“abc”)是重新生成了一个Java实例，它会在Java堆中分配一块内存。<br>所以s1和s2的内存地址肯定不一样，但是内容一样。</p>
<h3 id="7-什么是类型擦除？"><a href="#7-什么是类型擦除？" class="headerlink" title="7.什么是类型擦除？"></a>7.什么是类型擦除？</h3><p>不管泛型的类型传入哪一种类型实参，对于Java来说，都会被当成同一类处理，在内存中也只占用一块空间。通俗一点来说，就是泛型只作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的信息擦除，也就是说，成功编译过后的class文件是不包含任何泛型信息的。</p>
<h3 id="8-说一下对泛型的理解？"><a href="#8-说一下对泛型的理解？" class="headerlink" title="8.说一下对泛型的理解？"></a>8.说一下对泛型的理解？</h3><p>泛型的本质是参数化类型，在不创建新的类型的情况下，通过泛型指定不同的类型来控制形参具体限制的类型。也就是说在泛型的使用中，操作的数据类型被指定为一个参数，这种参数可以被用在类、接口和方法中，分别被称为泛型类、泛型接口和泛型方法。</p>
<p>泛型是Java中的一种语法糖，能够在代码编写的时候起到类型检测的作用，但是虚拟机是不支持这些语法的。</p>
<p>泛型的优点：</p>
<p>类型安全，避免类型的强转。<br>提高了代码的可读性，不必要等到运行的时候才去强制转换。</p>
<h3 id="9-HashMap的特点是什么？HashMap的原理？"><a href="#9-HashMap的特点是什么？HashMap的原理？" class="headerlink" title="9.HashMap的特点是什么？HashMap的原理？"></a>9.HashMap的特点是什么？HashMap的原理？</h3><p>HashMap的特点：</p>
<p>基于Map接口，存放键值对。<br>允许key/value为空。<br>非多线程安全。<br>不保证有序，也不保证使用的过程中顺序不会改变。<br>简单来讲，核心是数组+链表/红黑树，HashMap的原理就是存键值对的时候：</p>
<p>通过键的Hash值确定数组的位置。<br>找到以后，如果该位置无节点，直接存放。<br>该位置有节点即位置发生冲突，遍历该节点以及后续的节点，比较key值，相等则覆盖。<br>没有就新增节点，默认使用链表，相连节点数超过8的时候，在jdk 1.8中会变成红黑树。<br>如果Hashmap中的数组使用情况超过一定比例，就会扩容，默认扩容两倍。<br>当然这是存入的过程，其他过程可以自行查阅。这里需要注意的是：</p>
<p>key的hash值计算过程是高16位不变，低16位和高16位取抑或，让更多位参与进来，可以有效的减少碰撞的发生。<br>初始数组容量为16，默认不超过的比例为0.75。</p>
<h3 id="10-Java中抽象类和接口的特点？"><a href="#10-Java中抽象类和接口的特点？" class="headerlink" title="10.Java中抽象类和接口的特点？"></a>10.Java中抽象类和接口的特点？</h3><p>共同点：</p>
<p>抽象类和接口都不能生成具体的实例。<br>都是作为上层使用。<br>不同点：</p>
<p>抽象类可以有属性和成员方法，接口不可以。<br>一个类只能继承一个类，但是可以实现多个接口。<br>抽象类中的变量是普通变量，接口中的变量是静态变量。<br>抽象类表达的是is-a的关系，接口表达的是like-a的关系。</p>
<h3 id="11-String-StringBuffer-StringBuilder的区别"><a href="#11-String-StringBuffer-StringBuilder的区别" class="headerlink" title="11.String,StringBuffer,StringBuilder的区别"></a>11.String,StringBuffer,StringBuilder的区别</h3><p>String不可改变对象，一旦创建就不能修改</p>
<p>String str=”aaa”; str=”bbb”;<br>以上代码虽然改变了str，但是执行过程是回收str，把值赋给一个新的str<br>StringBuffer创建之后，可以去修改<br>StringBuilder也可修改，执行效率高于StringBuffer，不安全<br>当字符赋值少使用String<br>字符赋值频繁使用StringBuilder<br>当多个线程同步操作数据，使用StringBuffer</p>
<h3 id="12-同步锁对于静态方法锁的对象是什么？"><a href="#12-同步锁对于静态方法锁的对象是什么？" class="headerlink" title="12.同步锁对于静态方法锁的对象是什么？"></a>12.同步锁对于静态方法锁的对象是什么？</h3><p>class本身</p>
<h3 id="13-final-可以修饰类和方法吗？"><a href="#13-final-可以修饰类和方法吗？" class="headerlink" title="13.final 可以修饰类和方法吗？"></a>13.final 可以修饰类和方法吗？</h3><p>可以修饰class表示该类无法被继承，也可以修饰方法表示该方法无法被重写</p>
<h3 id="14-手写出单例模式"><a href="#14-手写出单例模式" class="headerlink" title="14.手写出单例模式"></a>14.手写出单例模式</h3><p>单例模式：分为恶汉式和懒汉式</p>
<p>恶汉式：（效率高）</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>        <br>       <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton getInstance() &#123;<br>        	<span class="hljs-built_in">	return </span>instance ;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>懒汉式：（线程安全）</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public class Singleton02 &#123;<br>       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton02 instance;<br><br>       <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton02 getInstance() &#123;<br>           <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>                synchronized (Singleton02.class)&#123;<br>                       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>                           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton02();<br>                        &#125;<br>                &#125;<br>            &#125;<br>           <span class="hljs-built_in"> return </span>instance;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="15-差值器和估值器"><a href="#15-差值器和估值器" class="headerlink" title="15.差值器和估值器"></a>15.差值器和估值器</h3><p>差值器： 根据时间流逝的百分比计算当前属性改变的百分比。<br>估值器： 根据当前属性改变的百分比计算改变后的属性值</p>
<h3 id="16-谈谈对接口与回调的理解"><a href="#16-谈谈对接口与回调的理解" class="headerlink" title="16.谈谈对接口与回调的理解"></a>16.谈谈对接口与回调的理解</h3><p>接口回调就是指: 可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法。实际上，当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法，这一过程称为对象功能的接口回调。</p>
<h3 id="17-WebSocket与socket的区别"><a href="#17-WebSocket与socket的区别" class="headerlink" title="17.WebSocket与socket的区别"></a>17.WebSocket与socket的区别</h3><p>1.WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。<br>2.Socket是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口。在设计模式中,Socket其实就是一个门面模式,它把…<br>3.区别 Socket是传输控制层协议,WebSocket是应用层协议。</p>
<h3 id="18-HttpClient与HttpUrlConnection的区别-此处延伸：Volley里用的哪种请求方式（2-3前HttpClient，2-3后HttpUrlConnection）"><a href="#18-HttpClient与HttpUrlConnection的区别-此处延伸：Volley里用的哪种请求方式（2-3前HttpClient，2-3后HttpUrlConnection）" class="headerlink" title="18.HttpClient与HttpUrlConnection的区别 (此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection）"></a>18.HttpClient与HttpUrlConnection的区别 (此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection）</h3><p>首先HttpClient和HttpUrlConnection 这两种方式都支持Https协议，都是以流的形式进行上传或者下载数据，也可以说是以流的形式进行数据的传输，还有ipv6,以及连接池等功能。HttpClient这个拥有非常多的API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话，很难进行扩展，也就是这个原因，Google在Android6.0的时候，直接就弃用了这个HttpClient.<br>而HttpUrlConnection相对来说就是比较轻量级了，API比较少，容易扩展，并且能够满足Android大部分的数据传输。比较经典的一个框架volley，在2.3版本以前都是使用HttpClient,在2.3以后就使用了HttpUrlConnection。</p>
<h3 id="19-client如何确定自己发送的消息被server收到"><a href="#19-client如何确定自己发送的消息被server收到" class="headerlink" title="19.client如何确定自己发送的消息被server收到?"></a>19.client如何确定自己发送的消息被server收到?</h3><p>HTTP协议里，有请求就有响应，根据响应的状态吗就能知道。</p>
<h3 id="20-如何验证证书的合法性"><a href="#20-如何验证证书的合法性" class="headerlink" title="20.如何验证证书的合法性?"></a>20.如何验证证书的合法性?</h3><p>1、证书是否是信任的有效证书。所谓信任：浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。所谓有效，就是看看web服务器证书是否在有效期，是否被吊销了。</p>
<p>2、对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一种是用证书做个信封，看对方是否能解开。以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证正式是否吊销可以采用黑名单方式或者OCSP方式。黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实时连接CA去验证，优点是实时，缺点是效率不高。</p>
<h3 id="21-HTTP与HTTPS的区别以及如何实现安全性"><a href="#21-HTTP与HTTPS的区别以及如何实现安全性" class="headerlink" title="21.HTTP与HTTPS的区别以及如何实现安全性"></a>21.HTTP与HTTPS的区别以及如何实现安全性</h3><p>区别：http是明文传输，传输的数据很可能被中间节点获取，从而导致数据传输不安全<br>https是加密传输，可以保证数据的传输安全<br>如何实现：http是应用层协议，它会将要传输的数据以明文的方式给传输层，这样显然不安全。https则是在应用层与传输层之间又加了一层，该层遵守SSL/TLS协议，用于数据加密。</p>
<h3 id="22-HTTP报文结构"><a href="#22-HTTP报文结构" class="headerlink" title="22.HTTP报文结构"></a>22.HTTP报文结构</h3><p>一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。<br>1.请求行<br>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1<br>2.请求头部<br>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。<br>3.空行<br>它的作用是通过一个空行，告诉服务器请求头部到此为止。<br>4.请求数据<br>若方法字段是GET，则此项为空，没有数据。若方法字段是POST,则通常来说此处放置的就是要提交的数据</p>
<h3 id="23-HTTP链接的特点"><a href="#23-HTTP链接的特点" class="headerlink" title="23.HTTP链接的特点"></a>23.HTTP链接的特点</h3><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br>从建立连接到关闭连接的过程称为“一次连接”。</p>
<h3 id="24-Http位于TCP-IP模型中的第几层？为什么说Http是可靠的数据传输协议？"><a href="#24-Http位于TCP-IP模型中的第几层？为什么说Http是可靠的数据传输协议？" class="headerlink" title="24.Http位于TCP/IP模型中的第几层？为什么说Http是可靠的数据传输协议？"></a>24.Http位于TCP/IP模型中的第几层？为什么说Http是可靠的数据传输协议？</h3><p>tcp/ip的五层模型：<br>从下到上：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层<br>其中tcp/ip位于模型中的网络层，处于同一层的还有ICMP（网络控制信息协议）。http位于模型中的应用层<br>由于tcp/ip是面向连接的可靠协议，而http是在传输层基于tcp/ip协议的，所以说http是可靠的数据传输协议。</p>
<h3 id="25-Http-https区别，此处延伸：https的实现原理"><a href="#25-Http-https区别，此处延伸：https的实现原理" class="headerlink" title="25.Http https区别，此处延伸：https的实现原理"></a>25.Http https区别，此处延伸：https的实现原理</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>https实现原理：<br>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。<br>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>（5）Web服务器利用自己的私钥解密出会话密钥。<br>（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<h3 id="26-TCP与UDP的应用"><a href="#26-TCP与UDP的应用" class="headerlink" title="26.TCP与UDP的应用"></a>26.TCP与UDP的应用</h3><p>从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。<br>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h3 id="27-TCP与UDP的区别"><a href="#27-TCP与UDP的区别" class="headerlink" title="27.TCP与UDP的区别"></a>27.TCP与UDP的区别</h3><p>tcp是面向连接的，由于tcp连接需要三次握手，所以能够最低限度的降低风险，保证连接的可靠性。<br>udp 不是面向连接的，udp建立连接前不需要与对象建立连接，无论是发送还是接收，都没有发送确认信号。所以说udp是不可靠的。<br>由于udp不需要进行确认连接，使得UDP的开销更小，传输速率更高，所以实时行更好。</p>
<h3 id="28-为什么不能用两次握手进行连接？"><a href="#28-为什么不能用两次握手进行连接？" class="headerlink" title="28.为什么不能用两次握手进行连接？"></a>28.为什么不能用两次握手进行连接？</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。</p>
<h3 id="29-为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#29-为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="29.为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>29.为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="30-TCP的3次握手和四次挥手"><a href="#30-TCP的3次握手和四次挥手" class="headerlink" title="30.TCP的3次握手和四次挥手"></a>30.TCP的3次握手和四次挥手</h3><p>三次握手：<br>第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x<br>第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y<br>第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1</p>
<p>四次挥手：<br>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p>
<h3 id="31-从网络加载一个10M的图片，说下注意事项"><a href="#31-从网络加载一个10M的图片，说下注意事项" class="headerlink" title="31.从网络加载一个10M的图片，说下注意事项"></a>31.从网络加载一个10M的图片，说下注意事项</h3><p>图片缓存、异常恢复、质量压缩，从这几方面说就好了</p>
<h3 id="32-多线程有什么要注意的问题？"><a href="#32-多线程有什么要注意的问题？" class="headerlink" title="32.多线程有什么要注意的问题？"></a>32.多线程有什么要注意的问题？</h3><p>给线程起有意义的名字，这样方便找Bug<br>缩小同步范围，从而减少锁的争用，例如对于 synchronized，应该尽量使用同步块而不是同步方法<br>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。<br>使用BlockingQueue实现生产者消费者问题<br>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable<br>使用本地变量和不可变类来保证线程安全<br>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务</p>
<h3 id="33-谈谈对多线程的理解"><a href="#33-谈谈对多线程的理解" class="headerlink" title="33.谈谈对多线程的理解"></a>33.谈谈对多线程的理解</h3><p>线程是由一个主线程和很多个子线程组成的，主线程消失，子线程也会消失，但是子线程消失其中一个主线程不会消失<br>线程的生命周期分为5个步骤像人的一生一样，这5个步骤分别对应了5个方法<br>新生–&gt;启动–&gt;运行–&gt;阻塞–&gt;销毁<br>继承Thread类or实现runnable方法–&gt;start–&gt;run–&gt;sleep(睡眠)or wait(挂起)–&gt;destroy</p>
<h3 id="34-什么是线程池，如何使用"><a href="#34-什么是线程池，如何使用" class="headerlink" title="34.什么是线程池，如何使用?"></a>34.什么是线程池，如何使用?</h3><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）</p>
<h3 id="35-死锁的四个必要条件？怎么避免死锁？"><a href="#35-死锁的四个必要条件？怎么避免死锁？" class="headerlink" title="35.死锁的四个必要条件？怎么避免死锁？"></a>35.死锁的四个必要条件？怎么避免死锁？</h3><p>死锁产生的原因：</p>
<p>1、系统资源的竞争，系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p>
<p>2、进程运行推进顺序不合适</p>
<p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>死锁的避免与预防：</p>
<p>死锁避免的基本思想:<br>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。<br>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。<br>死锁避免和死锁预防的区别：<br>死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</p>
<h3 id="36-ReentrantLock-、synchronized和volatile比较"><a href="#36-ReentrantLock-、synchronized和volatile比较" class="headerlink" title="36.ReentrantLock 、synchronized和volatile比较"></a>36.ReentrantLock 、synchronized和volatile比较</h3><p>java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<h3 id="37-synchronized与Lock的区别及使用场景"><a href="#37-synchronized与Lock的区别及使用场景" class="headerlink" title="37.synchronized与Lock的区别及使用场景"></a>37.synchronized与Lock的区别及使用场景</h3><p>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低；<br>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。<br>使用场景：在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h3 id="38-synchronized-和volatile-关键字的区别"><a href="#38-synchronized-和volatile-关键字的区别" class="headerlink" title="38.synchronized 和volatile 关键字的区别"></a>38.synchronized 和volatile 关键字的区别</h3><p>1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
<h3 id="39-volatile的作用，原理，性能。"><a href="#39-volatile的作用，原理，性能。" class="headerlink" title="39.volatile的作用，原理，性能。"></a>39.volatile的作用，原理，性能。</h3><p>作用：1、保持内存可见性 2、防止指令重排<br>原理：获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。<br>lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。<br>性能：读操作与普通变量无差别，写操作会慢一些，大多情况比锁消耗低。</p>
<h3 id="40-Synchronized用法及原理"><a href="#40-Synchronized用法及原理" class="headerlink" title="40.Synchronized用法及原理"></a>40.Synchronized用法及原理</h3><p>用法：修饰静态方法、实例方法、代码块<br>原理：<a href="https://blog.csdn.net/zc19921215/article/details/84780335">https://blog.csdn.net/zc19921215/article/details/84780335</a></p>
<h3 id="41-线程间操作List"><a href="#41-线程间操作List" class="headerlink" title="41.线程间操作List"></a>41.线程间操作List</h3><p>List list = Collections.synchronizedList(new ArrayList());</p>
<h3 id="42-两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"><a href="#42-两个进程同时要求写或者读，能不能实现？如何防止进程的同步？" class="headerlink" title="42.两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"></a>42.两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</h3><p>可以实现的。<br>同步方式有： 互斥锁、条件变量、读写锁、记录锁(文件锁)和信号灯</p>
<h3 id="43-如何保证线程安全？"><a href="#43-如何保证线程安全？" class="headerlink" title="43.如何保证线程安全？"></a>43.如何保证线程安全？</h3><p>1.synchronized；<br>2.Object方法中的wait,notify；<br>3.ThreadLocal机制 来实现的。</p>
<h3 id="44-讲一下java中的同步的方法-另一种问法：数据一致性如何保证？"><a href="#44-讲一下java中的同步的方法-另一种问法：数据一致性如何保证？" class="headerlink" title="44.讲一下java中的同步的方法(另一种问法：数据一致性如何保证？)"></a>44.讲一下java中的同步的方法(另一种问法：数据一致性如何保证？)</h3><p>1.即有synchronized关键字修饰的方法。<br>2.同步代码块(如：双重判断的单例模式)<br>3.使用特殊域变量(volatile)实现线程同步<br>4.使用重入锁实现线程同步<br>5.使用局部变量实现线程同步</p>
<h3 id="45-线程如何关闭？"><a href="#45-线程如何关闭？" class="headerlink" title="45.线程如何关闭？"></a>45.线程如何关闭？</h3><p>一种是调用它里面的stop()方法<br>另一种就是你自己设置一个停止线程的标记 （推荐这种）</p>
<h3 id="46-在Java中wait和seelp方法的不同；"><a href="#46-在Java中wait和seelp方法的不同；" class="headerlink" title="46.在Java中wait和seelp方法的不同；"></a>46.在Java中wait和seelp方法的不同；</h3><p>wait是Object的方法，是对象锁，锁住对象不再往下执行，当执行notify的时候才会往下执行。</p>
<p>sleep是Thread的方法，会释放cpu资源，当睡眠结束的时候会继续执行。</p>
<h3 id="47-如何控制某个方法允许并发访问线程的个数？"><a href="#47-如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="47.如何控制某个方法允许并发访问线程的个数？"></a>47.如何控制某个方法允许并发访问线程的个数？</h3><p>semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）<br>semaphore.release() 释放一个信号量，此时信号量个数+1</p>
<h3 id="48-run-和start-方法区别"><a href="#48-run-和start-方法区别" class="headerlink" title="48.run()和start()方法区别"></a>48.run()和start()方法区别</h3><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="49-为什么要有线程，而不是仅仅用进程？"><a href="#49-为什么要有线程，而不是仅仅用进程？" class="headerlink" title="49.为什么要有线程，而不是仅仅用进程？"></a>49.为什么要有线程，而不是仅仅用进程？</h3><p>线程可以增加并发的程度啊。其实多进程也是可以并发，但是为什么要是线程呢？因为线程是属于进程的，是个轻量级的对象。所以再切换线程时只需要做少量的工作，而切换进程消耗很大。这是从操作系统角度讲。<br>从用户程序角度讲，有些程序在逻辑上需要线程，比如扫雷，它需要一个线程等待用户的输入，另一个线程的来更新时间。还有一个例子就是聊天程序，一个线程是响应用户输入，一个线程是响应对方输入。如果没有多线程，那么只能你说一句我说一句，你不说我这里就不能动，我还不能连续说。所以用户程序有这种需要，操作系统就要提供响应的机制</p>
<h3 id="50-开启线程的三种方式？"><a href="#50-开启线程的三种方式？" class="headerlink" title="50.开启线程的三种方式？"></a>50.开启线程的三种方式？</h3><p>java有三种创建线程的方式，分别是继承Thread类、实现Runable接口和使用线程池</p>
<h3 id="51-String为什么要设计成不可变的？"><a href="#51-String为什么要设计成不可变的？" class="headerlink" title="51.String为什么要设计成不可变的？"></a>51.String为什么要设计成不可变的？</h3><p>1、字符串池的需求<br>字符串池是方法区（Method Area）中的一块特殊的存储区域。当一个字符串已经被创建并且该字符串在 池 中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如: string2）的字符串将会导致另一个引用（如: string1）出现脏数据。<br>2、允许字符串缓存哈希码<br>在java中常常会用到字符串的哈希码，例如： HashMap 。String的不变性保证哈希码始终一，因此，他可以不用担心变化的出现。 这种方法意味着不必每次使用时都重新计算一次哈希码——这样，效率会高很多。<br>3、安全<br>String广泛的用于java 类中的参数，如：网络连接（Network connetion），打开文件（opening files ）等等。如果String不是不可变的，网络连接、文件将会被改变——这将会导致一系列的安全威胁。操作的方法本以为连接上了一台机器，但实际上却不是。由于反射中的参数都是字符串，同样，也会引起一系列的安全问题。</p>
<h3 id="52-Java中String的了解"><a href="#52-Java中String的了解" class="headerlink" title="52.Java中String的了解"></a>52.Java中String的了解</h3><p>在源码中string是用final 进行修饰，它是不可更改，不可继承的常量。</p>
<h3 id="53-说说你对Java反射的理解"><a href="#53-说说你对Java反射的理解" class="headerlink" title="53.说说你对Java反射的理解"></a>53.说说你对Java反射的理解</h3><p>JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性。 从对象出发，通过反射（Class类）可以取得取得类的完整信息（类名 Class类型，所在包、具有的所有方法 Method[]类型、某个方法的完整信息（包括修饰符、返回值类型、异常、参数类型）、所有属性 Field[]、某个属性的完整信息、构造器 Constructors），调用类的属性或方法自己的总结： 在运行过程中获得类、对象、方法的所有信息。</p>
<h3 id="54-Java中实现多态的机制是什么？"><a href="#54-Java中实现多态的机制是什么？" class="headerlink" title="54.Java中实现多态的机制是什么？"></a>54.Java中实现多态的机制是什么？</h3><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现<br>重写Overriding是父类与子类之间多态性的一种表现<br>重载Overloading是一个类中多态性的一种表现.</p>
<p>55.Java的异常体系</p>
<p>Throwable，Error，Exception</p>
<h3 id="56-静态代理和动态代理的区别，什么场景使用？"><a href="#56-静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="56.静态代理和动态代理的区别，什么场景使用？"></a>56.静态代理和动态代理的区别，什么场景使用？</h3><p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。<br>场景：著名的Spring框架、Hibernate框架等等都是动态代理的使用例子</p>
<h3 id="57-string-转换成-integer的方式及原理"><a href="#57-string-转换成-integer的方式及原理" class="headerlink" title="57.string 转换成 integer的方式及原理"></a>57.string 转换成 integer的方式及原理</h3><p>String —&gt;integer Intrger.parseInt(string);<br>Integer—&gt; string Integer.toString();<br>原理：<br>parseInt(String s)–内部调用parseInt(s,10)（默认为10进制）<br>正常判断null，进制范围，length等<br>判断第一个字符是否是符号位<br>循环遍历确定每个字符的十进制值<br>通过*= 和-= 进行计算拼接<br>判断是否为负值 返回结果。</p>
<h3 id="58-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#58-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="58.成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>58.成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h3><p>java中内部类主要分为：</p>
<p>成员内部类<br>局部内部类(嵌套在方法和作用域内)<br>匿名内部类（没构造方法）<br>静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>因为Java不支持多继承，支持实现多个接口。但有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<h3 id="59-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#59-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="59.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>59.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h3><p>可继承 不可重写 而是被隐藏<br>如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成。</p>
<h3 id="60-Serializable-和Parcelable-的区别"><a href="#60-Serializable-和Parcelable-的区别" class="headerlink" title="60.Serializable 和Parcelable 的区别"></a>60.Serializable 和Parcelable 的区别</h3><p>Serializable  Java的序列化接口  在磁盘上读写    效率低  由于在读写的时候有大量的变量产生，内部执行大量的io操作</p>
<p>Parcelable   Android的序列化接口  在内存上读写  效率高  使用麻烦，对象不能保存在磁盘上</p>
<h3 id="61-final，finally，finalize的区别"><a href="#61-final，finally，finalize的区别" class="headerlink" title="61.final，finally，finalize的区别"></a>61.final，finally，finalize的区别</h3><p>final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写<br>finally:与try…catch…共同使用，确保无论是否出现异常都能被调用到<br>finalize:类的方法,垃圾回收之前会调用此方法,子类可以重写finalize()方法实现对资源的回收</p>
<h3 id="62-进程和线程的区别"><a href="#62-进程和线程的区别" class="headerlink" title="62.进程和线程的区别"></a>62.进程和线程的区别</h3><p>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。<br>进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。<br>一个进程内可拥有多个线程，进程可开启进程，也可开启线程。<br>一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。</p>
<h3 id="63-父类的静态方法能否被子类重写"><a href="#63-父类的静态方法能否被子类重写" class="headerlink" title="63.父类的静态方法能否被子类重写"></a>63.父类的静态方法能否被子类重写</h3><p>不能，父类的静态方法能够被子类继承，但是不能够被子类重写，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法。</p>
<h3 id="64-抽象类与接口的应用场景"><a href="#64-抽象类与接口的应用场景" class="headerlink" title="64.抽象类与接口的应用场景"></a>64.抽象类与接口的应用场景</h3><p>如果父类的方法必须要有默认实现，就可以用抽象类；</p>
<p>如果实现多继承，那就使用接口；</p>
<p>由于java不支持多继承，不可以集成多个父类，但是可以实现多个接口，因此可以用接口来解决这个问题。</p>
<p>如果有一些基本功能在不断改变，那就比较适合用抽象类。</p>
<p>如果有一些基本功能在不断改变，并且使用接口的话，那么就需要改变实现这个接口的所以类。</p>
<h3 id="65-抽象类和接口区别"><a href="#65-抽象类和接口区别" class="headerlink" title="65.抽象类和接口区别"></a>65.抽象类和接口区别</h3><p>相同：<br>1、都能被继承<br>2、继承的类都必须将未实现的函数实现<br>3、只关注方法的定义，不关注方法的实现</p>
<p>差异：<br>1、一个子类可以继承多个接口，但是只能继承一个父类<br>2、抽象类在对象中只能表示一种对象，接口可以被很多对象继承</p>
<h3 id="66-什么是内部类？内部类的作用"><a href="#66-什么是内部类？内部类的作用" class="headerlink" title="66.什么是内部类？内部类的作用"></a>66.什么是内部类？内部类的作用</h3><p>内部类：将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p>
<p>作用：</p>
<p>1、每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整；</p>
<p>2、方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏；</p>
<p>3、方便编写事件驱动程序；</p>
<p>4、方便编写线程代码</p>
<h3 id="67-谈谈对java多态的理解"><a href="#67-谈谈对java多态的理解" class="headerlink" title="67.谈谈对java多态的理解"></a>67.谈谈对java多态的理解</h3><p>1、多态是指一种行为具有多种不同的表现形式，子类与父类之间的重写，类中的方法重载都是属于多态的表现；</p>
<p>2、多态的三要素：继承、重写、父类引用指向子类对象；</p>
<p>3、多态的好处：可以消除类型之间的耦合关系，具有接口性、简化性、可扩展性、灵活性。</p>
<h3 id="68-int与integer的区别"><a href="#68-int与integer的区别" class="headerlink" title="68.int与integer的区别"></a>68.int与integer的区别</h3><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p>
<h3 id="69-char、int、long、double各占多少字节数"><a href="#69-char、int、long、double各占多少字节数" class="headerlink" title="69.char、int、long、double各占多少字节数"></a>69.char、int、long、double各占多少字节数</h3><p>char:2字节、int:4字节、long\double:8字节</p>
<h3 id="70-java中-和equals和hashCode的区别"><a href="#70-java中-和equals和hashCode的区别" class="headerlink" title="70.java中==和equals和hashCode的区别"></a>70.java中==和equals和hashCode的区别</h3><p>==是运算符，用来比较两个值、两个对象的内存地址是否相等；<br>equals是Object类的方法，默认情况下比较两个对象是否是同一个对象，内部实现是通过“==”来实现的。<br>hashCoed也是Object类里面的方法，返回值是一个对象的哈希码，同一个对象哈希码一定相等，但不同对象哈希码也有可能相等。</p>
<h3 id="71-String-StringBuffer-StringBuilder的区别"><a href="#71-String-StringBuffer-StringBuilder的区别" class="headerlink" title="71.String/StringBuffer/StringBuilder的区别"></a>71.String/StringBuffer/StringBuilder的区别</h3><p>String 一旦创建不可改变，重新赋值其实是创建了一个新的对象</p>
<p>StringBuilder 效率高  线程不安全，因为有缓冲区</p>
<p>StringBuffer  效率低  线程安全</p>
<h3 id="72-线程池都有哪些状态？"><a href="#72-线程池都有哪些状态？" class="headerlink" title="72.线程池都有哪些状态？"></a>72.线程池都有哪些状态？</h3><p>线程池有5种状态：Running运行、ShutDown关机、Stop停止、Tidying清理、Terminated终止。</p>
<h3 id="73-什么是死锁？"><a href="#73-什么是死锁？" class="headerlink" title="73.什么是死锁？"></a>73.什么是死锁？</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
<h3 id="74-说一下-synchronized-底层实现原理？"><a href="#74-说一下-synchronized-底层实现原理？" class="headerlink" title="74.说一下 synchronized 底层实现原理？"></a>74.说一下 synchronized 底层实现原理？</h3><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>四大组件</title>
    <url>/topic/topic_%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="1-App的启动流程"><a href="#1-App的启动流程" class="headerlink" title="1.App的启动流程"></a>1.App的启动流程</h3><p>当点击桌面图标时，Launcher会获取到点击View的Tag，判断Tag是否包含ShortCutInfo，包含的话从ShortCutInfo中拿到intent，然后调用startActivitySafely()，这个方法其实是对startActivity()的封装，然后调用startActivity()启动App的MainActivity，这就是App的启动流程。</p>
<h3 id="2-View的绘制原理"><a href="#2-View的绘制原理" class="headerlink" title="2.View的绘制原理"></a>2.View的绘制原理</h3><p>Window、DocorView、ViewRootImpl之间的联系：</p>
<ol>
<li><p>一个Activity包含一个Window，Window是一个抽象基类，是Activity和整个View系统交互的接口。</p>
</li>
<li><p>PhoneWindow是Window的唯一实现类，提供了一系列窗口的方法，比如设置背景，标题等。</p>
</li>
<li><p>一个PhoneWindow对应一个DocorView和一个ViewRootImpl。</p>
</li>
<li><p>DocorView是整个ViewTree中的顶层布局，继承自FrameLayout，包含两个子View，状态栏View和LinearLayout</p>
</li>
<li><p>LinearLayout包含一个title和一个content，title就是平时用的TitleBar或者ActionBar。content也是framelayout，activity通过setContent将布局加载到这个view上。</p>
</li>
<li><p>ViewRootImpl就是建立在Window和DocorView之间的关系。</p>
</li>
</ol>
<p>measure、layout、draw方法的作用：</p>
<p>measure：根据父View传递的MeasureSpec进行计算大小</p>
<p>layout：根据measure子View的大小，将view放置到合适的位置上面</p>
<p>draw：将view对象绘制到屏幕上</p>
<p>measure、layout、draw方法的入口：</p>
<p>这三个核心阶段的入口是在ViewRootImpl的perFormTraversals() 方法中。</p>
<p>performTraversals会依次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程。其中performMeasure中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有子元素进行measure过程，这样就完成了一次measure过程；子元素会重复父容器的measure过程，如此反复完成了整个View数的遍历。</p>
<p>measure过程决定了View的宽/高，完成后可通过getMeasuredWidth/getMeasureHeight方法来获取View测量后的宽/高。</p>
<p>Layout过程决定了View的四个顶点的坐标和实际View的宽高，完成后可通过getTop、getBotton、getLeft和getRight拿到View的四个定点坐标。 </p>
<p>Draw过程决定了View的显示，完成后View的内容才能呈现到屏幕上。</p>
<p>measure方法：</p>
<p>首先要了解一下MeasureSpec，是一个32位二进制的整数型，前面两位代表的是mode，后面30为代表的是size。View的MeasureSpec并不是父View独自决定，它是根据父View的MeasureSpec和子View的LayoutParems通过相应的规则转化决定的。</p>
<p>mode主要分为三类：</p>
<p>EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。<br>AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content<br>UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况）</p>
<p>onMeasure(）<br>由于measure是final类型的，所以子类不能覆盖，但是onMeasure方法可以被重写，所以我们可以在onMeasure方法中重写测量设置View尺寸。onMeasure也是测量View的核心代码。<br>在这个方法中测量流程是会判断如果父类传递过来的模式是否是MeasureSpec.UNSPECIFIED，如果是就会获取到最小建议值，如果不是有返回值AT_MOST或者EXACTLY模式，则设置父类传递过来的大小。 然后调用setMeasuredDimension 方法进行存储大小。</p>
<p>layout方法：</p>
<ol>
<li><p>判断当前是否正在执行动画，如果在执行动画，则等待动画执行完调用requestLayout，如果没有添加动画或者动画已经执行完了，则调用layout，也就是View的layout。</p>
</li>
<li><p>在View的layout中设置view在父View中的位置，判断位置是都发生变化，是否需要重新进行排版布局，需要的话重新调用onLayout。</p>
</li>
<li><p>onLayout中，ViewGruop会遍历它里面的所有View然后调用每个view 的layout(l,t,r,b)方法进行位置设置。</p>
</li>
</ol>
<p>draw方法：</p>
<p>第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。<br>第三步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。<br>第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。<br>第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。<br>第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮</p>
<h3 id="3-Activity的启动流程"><a href="#3-Activity的启动流程" class="headerlink" title="3.Activity的启动流程?"></a>3.Activity的启动流程?</h3><p>通常我们在一个Activity中启动另一个Activity，一般都是调用startActivity方法，这个最终会调用到Activity的startActivityForResult方法，那有没有想过Activity的启动到底经历了什么 ？现在我们一起来分析一下吧：</p>
<p>首先要了解一个类：<br>Instrumentation：<br>负责发起Activity的启动，并具体负责Activity的创建，以及Activity生命周期的回调，一个应用进程只会有一个Instrumentation对象，App内所有的Activity都持有该对象的引用。</p>
<p>启动流程：</p>
<ol>
<li><p>在startActivityForResult()方法中调用了Instrumentation中的execStartActivity()方法。</p>
</li>
<li><p>在execStartActivity()方法中，通过ActivityManagerNative.getDefaut()获取到ActivityManagerService的一个本地代理对象ActivityManagerProXY，然后调用了其startActivity()方法</p>
</li>
<li><p>ActivityManagerProXY的startActivity()最终会调用到AMS的startActivity()，并将ApplicationThread对象传入到AMS所在进程，当然AMS拿到的实际上是ApplicationThread代理对象ApplicationThreadProxy，AMS就要通过这个代理对象与我们的App进程进行通信。<br>无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； </p>
</li>
<li><p>ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息；</p>
</li>
<li><p>ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread指的是调用AMS的startActivity的进程，对于点击图标启动的Activity，这个进程就是Luncher了，对于在Activity内部通过调用startActivity启动的Activity，这个进程就是这个Activity所在的进程了。</p>
</li>
<li><p>ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity；</p>
</li>
<li><p>对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动；</p>
</li>
<li><p>ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作；</p>
</li>
<li><p>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</p>
</li>
</ol>
<h3 id="4-Activity的启动流程"><a href="#4-Activity的启动流程" class="headerlink" title="4.Activity的启动流程"></a>4.Activity的启动流程</h3><p><a href="https://www.jianshu.com/p/9ecea420eb52">https://www.jianshu.com/p/9ecea420eb52</a></p>
<h3 id="5-Android消息机制介绍？"><a href="#5-Android消息机制介绍？" class="headerlink" title="5.Android消息机制介绍？"></a>5.Android消息机制介绍？</h3><p>Android消息机制中的四大概念：</p>
<p>ThreadLocal：当前线程存储的数据仅能从当前线程取出。<br>MessageQueue：具有时间优先级的消息队列。<br>Looper：轮询消息队列，看是否有新的消息到来。<br>Handler：具体处理逻辑的地方。<br>过程：</p>
<p>准备工作：创建Handler，如果是在子线程中创建，还需要调用Looper#prepare()，在Handler的构造函数中，会绑定其中的Looper和MessageQueue。<br>发送消息：创建消息，使用Handler发送。<br>进入MessageQueue：因为Handler中绑定着消息队列，所以Message很自然的被放进消息队列。<br>Looper轮询消息队列：Looper是一个死循环，一直观察有没有新的消息到来，之后从Message取出绑定的Handler，最后调用Handler中的处理逻辑，这一切都发生在Looper循环的线程，这也是Handler能够在指定线程处理任务的原因。</p>
<h3 id="6-Activity中onStart和onResume的区别？onPause和onStop的区别？"><a href="#6-Activity中onStart和onResume的区别？onPause和onStop的区别？" class="headerlink" title="6.Activity中onStart和onResume的区别？onPause和onStop的区别？"></a>6.Activity中onStart和onResume的区别？onPause和onStop的区别？</h3><p>首先，Activity有三类：</p>
<p>前台Activity：活跃的Activity，正在和用户交互的Activity。<br>可见但非前台的Activity：常见于栈顶的Activity背景透明，处在其下面的Activity就是可见但是不可和用户交互。<br>后台Activity：已经被暂停的Activity，比如已经执行了onStop方法。<br>所以，onStart和onStop通常指的是当前活动是否位于前台这个角度，而onResume和onPause从是否可见这个角度来讲的。</p>
<h3 id="7-说下-Activity-跟-跟-window-，-view-之间的关系？"><a href="#7-说下-Activity-跟-跟-window-，-view-之间的关系？" class="headerlink" title="7.说下 Activity 跟 跟 window ， view 之间的关系？"></a>7.说下 Activity 跟 跟 window ， view 之间的关系？</h3><p>Activity 创建时通过 attach()初始化了一个 Window 也就是PhoneWindow，一个 PhoneWindow 持有一个DecorView 的实例，DecorView 本身是一个 FrameLayout，继承于 View，Activty 通过setContentView 将xml 布局控件不断 addView()添加到 View 中，最终显示到 Window 于我们交互；</p>
<h3 id="8-FragmentPagerAdapter-与-与-FragmentStatePagerAdapter-的区别与使用场景？"><a href="#8-FragmentPagerAdapter-与-与-FragmentStatePagerAdapter-的区别与使用场景？" class="headerlink" title="8.FragmentPagerAdapter 与 与 FragmentStatePagerAdapter 的区别与使用场景？"></a>8.FragmentPagerAdapter 与 与 FragmentStatePagerAdapter 的区别与使用场景？</h3><p>FragmentPagerAdapter 的每个 Fragment 会持久的保存在 FragmentManager 中，只要用户可以返回到页面中，它都不会被销毁。因此适用于那些数据 相对静态的页，Fragment 数量也比较少的那种;FragmentStatePagerAdapter 只保留当前页面，当页面不可见时，该 Fragment 就会被消除，释放其资源。因此适用于那些 数据动态性较大、 占用内存较多，多 Fragment 的情况；</p>
<h3 id="9-Fragment中add与replace的区别？"><a href="#9-Fragment中add与replace的区别？" class="headerlink" title="9.Fragment中add与replace的区别？"></a>9.Fragment中add与replace的区别？</h3><p>add不会重新初始化fragment,replace每次都会；<br>添加相同的fragment时，replace不会有任何变化，add会报IllegalStateException 异常；<br>replace 先 remove 掉相同 id 的所有 fragment，然后在add 当前的这个 fragment，而 add 是覆盖前一个fragment。所以如果使用 add 一般会伴随 hide()和show()，避免布局重叠；<br>使用 add，如果应用放在后台，或以其他方式被系统销毁，再打开时，hide()中引用的 fragment 会销毁，所以依然会出现布局重叠 bug，可以使用 replace 或使用 add时，添加一个 tag 参数；</p>
<h3 id="10-activity，fragment传值问题"><a href="#10-activity，fragment传值问题" class="headerlink" title="10.activity，fragment传值问题"></a>10.activity，fragment传值问题</h3><p>通过Bundle传值，在activty定义变量传值，扩展fragment创建传值</p>
<h3 id="11-推送到达率如何提高"><a href="#11-推送到达率如何提高" class="headerlink" title="11.推送到达率如何提高"></a>11.推送到达率如何提高</h3><p>判手机系统，小米使用小米推送，华为使用华为推送，其他手机使用友盟推送</p>
<h3 id="12-启动优化"><a href="#12-启动优化" class="headerlink" title="12.启动优化"></a>12.启动优化</h3><p>什么是逻辑异步？就是用多线程去替代之前单个主线程的工作，尽量保证让onCreate流畅不被堵塞。那么我们该怎么设计呢？设计的思路我们可以参考Gradle，将逻辑Task化。</p>
<p>1.将原本冗余的逻辑代码区分开来，抽象成一个Task</p>
<p>2.确定Task是否必须执行在主线程，是否必须在onCreate中执行完，执行上下是否存在依赖关系</p>
<p>3.设计一个Task分发管理类，负责将所有Task集合后生成一个有向无环图，这点也是参考Gradle的</p>
<p>1.逻辑异步</p>
<p>2.逻辑延迟</p>
<p>3.逻辑懒加载</p>
<h3 id="13-什么是aar-aar是jar有什么区别"><a href="#13-什么是aar-aar是jar有什么区别" class="headerlink" title="13.什么是aar?aar是jar有什么区别?"></a>13.什么是aar?aar是jar有什么区别?</h3><p>jar打包不能包含资源文件<br>“aar”包是 Android 的类库项目的二进制发行包。文件扩展名是.aar</p>
<h3 id="14-如何打开res-aw目录中的数据库文件"><a href="#14-如何打开res-aw目录中的数据库文件" class="headerlink" title="14.如何打开res aw目录中的数据库文件?"></a>14.如何打开res aw目录中的数据库文件?</h3><p>在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。<br>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。<br>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p>
<h3 id="15-为什么Android引入广播机制"><a href="#15-为什么Android引入广播机制" class="headerlink" title="15.为什么Android引入广播机制?"></a>15.为什么Android引入广播机制?</h3><p>ａ:从MVC的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。</p>
<p>android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构<br>它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。</p>
<p>b：程序间互通消息(例如在自己的应用程序内监听系统来电)<br>c：效率上(参考UDP的广播协议在局域网的方便性)<br>d：设计模式上(反转控制的一种应用，类似监听者模式)</p>
<h3 id="16-onStart-与onResume-有什么区别？"><a href="#16-onStart-与onResume-有什么区别？" class="headerlink" title="16.onStart()与onResume()有什么区别？"></a>16.onStart()与onResume()有什么区别？</h3><p>onStart()是activity界面被显示出来的时候执行的，但不能与它交互；<br>onResume()是当该activity与用户能进行交互时被执行，用户可以获得activity的焦点，能够与用户交互。</p>
<h3 id="17-AIDL解决了什么问题？"><a href="#17-AIDL解决了什么问题？" class="headerlink" title="17.AIDL解决了什么问题？"></a>17.AIDL解决了什么问题？</h3><p>AIDL出现的目的就是为了解决一对多并发及时进程通信了</p>
<h3 id="18-什么是AIDL？"><a href="#18-什么是AIDL？" class="headerlink" title="18.什么是AIDL？"></a>18.什么是AIDL？</h3><p>AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。</p>
<h3 id="19-Binder机制"><a href="#19-Binder机制" class="headerlink" title="19.Binder机制"></a>19.Binder机制</h3><p>直观来说，Binder是Android中的一个类，它实现了IBinder接口，从IPC的角度来说，Binder是Android中的一种跨进程通信的一种方式，同时还可以理解为是一种虚拟的物理设备，它的设备驱动是／dev/binder/。从Framework角度来说，Binder是ServiceManager的桥梁。从应用层来说，Binder是客户端和服务端进行通信的媒介。<br>我们先来了解一下这个类中每个方法的含义：<br>DESCRIPTOR：Binder的唯一标识，一般用于当前Binder的类名表示。<br>asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转化过程是区分进程的，如果客户端和服务端位于同一个进程，那么这个方法返回的是服务端的stub对象本身，否则返回的是系统封装后的Stub.proxy对象。<br>asBinder()：用于返回当前Binder对象。<br>onTransact：该方法运行在服务端的Binder线程池中，当客户端发起跨进程通信请求的时候，远程请求通过系统底层封装后交给该方法处理。注意这个方法public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)，服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就像reply中写入返回值。这个方法的执行过程就是这样的。如果这个方法返回false，客户端是会请求失败的，所以我们可以在这个方法中做一些安全验证。</p>
<p>Binder的工作机制但是要注意一些问题：1、当客户端发起请求时，由于当前线程会被挂起，直到服务端返回数据，如果这个远程方法很耗时的话，那么是不能够在UI线程，也就是主线程中发起这个远程请求的。<br>2、由于Service的Binder方法运行在线程池中，所以Binder方法不管是耗时还是不耗时都应该采用同步的方式，因为它已经运行在一个线程中了。</p>
<h3 id="20-启动页白屏及黑屏解决？"><a href="#20-启动页白屏及黑屏解决？" class="headerlink" title="20.启动页白屏及黑屏解决？"></a>20.启动页白屏及黑屏解决？</h3><p>把启动图bg_splash设置为窗体背景，避免刚刚启动App的时候出现，黑/白屏<br>@drawable/bg_splash</p>
<h3 id="21-Android中开启摄像头的主要步骤"><a href="#21-Android中开启摄像头的主要步骤" class="headerlink" title="21.Android中开启摄像头的主要步骤"></a>21.Android中开启摄像头的主要步骤</h3><p>获得摄像头管理器CameraManager mCameraManager，mCameraManager.openCamera()来打开摄像头<br>指定要打开的摄像头，并创建openCamera()所需要的CameraDevice.StateCallback stateCallback<br>在CameraDevice.StateCallback stateCallback中调用takePreview()，这个方法中，使用CaptureRequest.Builder创建预览需要的CameraRequest，并初始化了CameraCaptureSession，最后调用了setRepeatingRequest(previewRequest, null, childHandler)进行了预览<br>点击屏幕，调用takePicture()，这个方法内，最终调用了capture(mCaptureRequest, null, childHandler)<br>在new ImageReader.OnImageAvailableListener(){}回调方法中，将拍照拿到的图片进行展示</p>
<h3 id="22-下拉状态栏是不是影响activity的生命周期"><a href="#22-下拉状态栏是不是影响activity的生命周期" class="headerlink" title="22.下拉状态栏是不是影响activity的生命周期"></a>22.下拉状态栏是不是影响activity的生命周期</h3><p>不会影响</p>
<h3 id="23-Android系统为什么会设计ContentProvider？"><a href="#23-Android系统为什么会设计ContentProvider？" class="headerlink" title="23.Android系统为什么会设计ContentProvider？"></a>23.Android系统为什么会设计ContentProvider？</h3><p>ContentProvider应用程序间非常通用的共享数据的一种方式，也是Android官方推荐的方式。Android中许多系统应用都使用该方式实现数据共享，比如通讯录、短信等。</p>
<p>设计用意在于：</p>
<p>封装。对数据进行封装，提供统一的接口，使用者完全不必关心这些数据是在DB，XML、Preferences或者网络请求来的。当项目需求要改变数据来源时，使用我们的地方完全不需要修改。<br>提供一种跨进程数据共享的方式。<br>就是数据更新通知机制了。因为数据是在多个应用程序中共享的，当其中一个应用程序改变了这些共享数据的时候，它有责任通知其它应用程序，让它们知道共享数据被修改了，这样它们就可以作相应的处理。</p>
<h3 id="24-怎么去除重复代码？"><a href="#24-怎么去除重复代码？" class="headerlink" title="24.怎么去除重复代码？"></a>24.怎么去除重复代码？</h3><p>1、为你的项目定义一个基Activity或Fragment<br>2、抽取相同部分<br>3、用include减少局部布局的重复<br>4、用ViewStub减少整体的布局的重复<br>5、多用引用而不是写死，对于资源文件的引用，比如文字text、文字大小textSize、文字颜色textColor等统一处理</p>
<h3 id="25-有没有尝试简化Parcelable的使用？"><a href="#25-有没有尝试简化Parcelable的使用？" class="headerlink" title="25.有没有尝试简化Parcelable的使用？"></a>25.有没有尝试简化Parcelable的使用？</h3><p>as的插件<br>在Android studio上下载android parcelable code generator插件<br>点击右键弹出提示框，选择Parcelable生成即可：<br>序列化时选择需要的属性：<br>最后是自动生成的代码，也表示成功的实现了Parcelable接口</p>
<h3 id="26-Android为什么引入Parcelable？"><a href="#26-Android为什么引入Parcelable？" class="headerlink" title="26.Android为什么引入Parcelable？"></a>26.Android为什么引入Parcelable？</h3><p>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p>Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递（除基本类外的类数据）</p>
<p>Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的</p>
<h3 id="27-广播引起anr的时间限制是多少？"><a href="#27-广播引起anr的时间限制是多少？" class="headerlink" title="27.广播引起anr的时间限制是多少？"></a>27.广播引起anr的时间限制是多少？</h3><p>在Android中Activity中阻塞5秒、Service 20秒、BroadCastReceiver 10秒，就会造成ANR。</p>
<h3 id="28-广播是否可以请求网络？"><a href="#28-广播是否可以请求网络？" class="headerlink" title="28.广播是否可以请求网络？"></a>28.广播是否可以请求网络？</h3><p>子线程可以，主线程超过10s引起anr</p>
<h3 id="29-如何通过广播拦截和abort一条短信？"><a href="#29-如何通过广播拦截和abort一条短信？" class="headerlink" title="29.如何通过广播拦截和abort一条短信？"></a>29.如何通过广播拦截和abort一条短信？</h3><p>首先添加接收短信的权限</p>
<p>在清单文件中注册广播接收器，设置该广播接收器优先级,尽量设高一点<br>创建一个BroadcastReceiver来实现广播的处理，并设置拦截器abortBroadcast();</p>
<h3 id="30-AndroidManifest的作用与理解"><a href="#30-AndroidManifest的作用与理解" class="headerlink" title="30.AndroidManifest的作用与理解"></a>30.AndroidManifest的作用与理解</h3><p>AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders， Services， 和Intent Receivers，还能指定permissions和instrumentation（安全控制和测试）。</p>
<h3 id="31-进程和-Application-的生命周期"><a href="#31-进程和-Application-的生命周期" class="headerlink" title="31.进程和 Application 的生命周期"></a>31.进程和 Application 的生命周期</h3><p>onCreate():Application创建的时候调用<br>onConfigurationChanged(Configuration newConfig):当配置信息改变的时候会调用，如屏幕旋转、语言切换时。<br>onLowMemory():Android系统整体内存较低时候调用，通常在这里释放一些不重要的资源，或者提醒用户清一下垃圾，来保证内存足够而让APP进程不被系统杀掉。它和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同。<br>onTrimMemory(int level)：Android 4.0 之后提供的一个API，用于取代onLowMemory()。在系统内存不足的时会被调用，提示开发者清理部分资源来释放内存，从而避免被 Android 系统杀死。详见《Android代码内存优化建议-OnTrimMemory优化》<br>onTerminate():Application结束的时候会调用,由系统决定调用的时机</p>
<h3 id="32-说说Activity、Intent、Service-是什么关系"><a href="#32-说说Activity、Intent、Service-是什么关系" class="headerlink" title="32.说说Activity、Intent、Service 是什么关系"></a>32.说说Activity、Intent、Service 是什么关系</h3><p>一个 Activity 通常是一个单独的屏幕，每一个 Activity 都被实现为一个单独的类，这些类都 是从 Activity 基类中继承来的， Activity 类会显示由视图控件组成的用户接口，并对视图控 件的事件做出响应。</p>
<p>Intent 的调用是用来进行架构屏幕之间的切换的。 Intent 是描述应用想要做什么。 Intent 数 据结构中两个最重要的部分是动作和动作 对应的数据， 一个动作对应一个动作数据。</p>
<p>Android Service 是运行在后台的代码，不能与用户交互，可以运行在自己的进程，也可以 运行在其他应用程序进程的上下文里。需要通过某一个 Activity 或者其他 Context 对象来调 用。 Activity 跳转到 Activity，Activity 启动 Service，Service 打开 Activity ，Activity 跳转到 Activity，Activity 启动 Service，Service 打开 Activity</p>
<h3 id="33-IntentService原理及作用是什么？"><a href="#33-IntentService原理及作用是什么？" class="headerlink" title="33.IntentService原理及作用是什么？"></a>33.IntentService原理及作用是什么？</h3><p>IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。<br>所有请求都在一个单线程中，不会阻塞应用程序的主线程（UI Thread），同一时间只处理一个请求。</p>
<h3 id="34-AndroidService与Activity之间通信的几种方式"><a href="#34-AndroidService与Activity之间通信的几种方式" class="headerlink" title="34.AndroidService与Activity之间通信的几种方式"></a>34.AndroidService与Activity之间通信的几种方式</h3><p>通过 broadcast:通过广播发送消息到 activitry<br>通过 Binder：通过与 activity 进行绑定</p>
<h3 id="35-请介绍下ContentProvider-是如何实现数据共享的？"><a href="#35-请介绍下ContentProvider-是如何实现数据共享的？" class="headerlink" title="35.请介绍下ContentProvider 是如何实现数据共享的？"></a>35.请介绍下ContentProvider 是如何实现数据共享的？</h3><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。<br>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。<br>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？<br>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p>
<h3 id="36-ActivityThread，AMS，WMS的工作原理"><a href="#36-ActivityThread，AMS，WMS的工作原理" class="headerlink" title="36.ActivityThread，AMS，WMS的工作原理"></a>36.ActivityThread，AMS，WMS的工作原理</h3><p>Activity与Window：<br>Activity只负责生命周期和事件处理<br>Window只控制视图<br>一个Activity包含一个Window，如果Activity没有Window，那就相当于Service。</p>
<p>AMS与WMS：<br>AMS统一调度所有应用程序的Activity<br>WMS控制所有Window的显示与隐藏以及要显示的位置。在视图层次中，Activity在WIndow之上</p>
<p>ActivityThread：是Android应用的主线程（UI线程）</p>
<p>WMS(WindowManagerService)：管理的整个系统所有窗口的UI<br>作用:<br>为所有窗口分配Surface：客户端向WMS添加一个窗口的过程，其实就是WMS为其分配一块Suiface的过程，一块块Surface在WMS的管理下有序的排布在屏幕上。Window的本质就是Surface。（简单的说Surface对应了一块屏幕缓冲区）<br>管理Surface的显示顺序、尺寸、位置<br>管理窗口动画<br>输入系统相关：WMS是派发系统按键和触摸消息的最佳人选，当接收到一个触摸事件，它需要寻找一个最合适的窗口来处理消息，而WMS是窗口的管理者，系统中所有的窗口状态和信息都在其掌握之中，完成这一工作不在话下。</p>
<p>AMS（ActivityManagerService）<br>ActivityManager是客户端用来管理系统中正在运行的所有Activity包括Task、Memory、Service等信息的工具。但是这些这些信息的维护工作却不是又ActivityManager负责的。在ActivityManager中有大量的get()方法，那么也就说明了他只是提供信息给AMS，由AMS去完成交互和调度工作。</p>
<p>作用：<br>统一调度所有应用程序的Activity的生命周期<br>启动或杀死应用程序的进程<br>启动并调度Service的生命周期<br>注册BroadcastReceiver，并接收和分发Broadcast<br>启动并发布ContentProvider<br>调度task<br>处理应用程序的Crash<br>查询系统当前运行状态</p>
<h3 id="37-Activity-Window-View三者的差别"><a href="#37-Activity-Window-View三者的差别" class="headerlink" title="37.Activity-Window-View三者的差别"></a>37.Activity-Window-View三者的差别</h3><p>这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。<br>1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。<br>2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。<br>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等<br>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。</p>
<h3 id="38-讲解一下Context"><a href="#38-讲解一下Context" class="headerlink" title="38.讲解一下Context"></a>38.讲解一下Context</h3><p>Context是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。Context下有两个子类，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。<br>getApplicationContext()和getApplication()方法得到的对象都是同一个application对象，只是对象的类型不一样。<br>Context数量 = Activity数量 + Service数量 + 1 （1为Application）</p>
<h3 id="39-BroadcastReceiver，LocalBroadcastReceiver-区别"><a href="#39-BroadcastReceiver，LocalBroadcastReceiver-区别" class="headerlink" title="39.BroadcastReceiver，LocalBroadcastReceiver 区别"></a>39.BroadcastReceiver，LocalBroadcastReceiver 区别</h3><p>一、应用场景不同<br>1、BroadcastReceiver用于应用之间的传递消息；<br>2、而LocalBroadcastManager用于应用内部传递消息，比broadcastReceiver更加高效。<br>二、使用安全性不同<br>1、BroadcastReceiver使用的Content API，所以本质上它是跨应用的，所以在使用它时必须要考虑到不要被别的应用滥用；<br>2、LocalBroadcastManager不需要考虑安全问题，因为它只在应用内部有效。</p>
<h3 id="40-本地广播和全局广播有什么差别？"><a href="#40-本地广播和全局广播有什么差别？" class="headerlink" title="40.本地广播和全局广播有什么差别？"></a>40.本地广播和全局广播有什么差别？</h3><p>BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式<br>LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。</p>
<h3 id="41-Broadcast注册方式与区别-（此处延伸：什么情况下用动态注册）"><a href="#41-Broadcast注册方式与区别-（此处延伸：什么情况下用动态注册）" class="headerlink" title="41.Broadcast注册方式与区别 （此处延伸：什么情况下用动态注册）"></a>41.Broadcast注册方式与区别 （此处延伸：什么情况下用动态注册）</h3><p>Broadcast广播，注册方式主要有两种.<br>第一种是静态注册，也可成为常驻型广播，这种广播需要在Androidmanifest.xml中进行注册，这中方式注册的广播，不受页面生命周期的影响，即使退出了页面，也可以收到广播这种广播一般用于想开机自启动啊等等，由于这种注册的方式的广播是常驻型广播，所以会占用CPU的资源。<br>第二种是动态注册，而动态注册的话，是在代码中注册的，这种注册方式也叫非常驻型广播，收到生命周期的影响，退出页面后，就不会收到广播，我们通常运用在更新UI方面。这种注册方式优先级较高。最后需要解绑，否会会内存泄露<br>广播是分为有序广播和无序广播。</p>
<h3 id="42-请描述一下广播BroadcastReceiver的理解"><a href="#42-请描述一下广播BroadcastReceiver的理解" class="headerlink" title="42.请描述一下广播BroadcastReceiver的理解"></a>42.请描述一下广播BroadcastReceiver的理解</h3><p>广播，是一个全局的监听器，属于Android四大组件之一。Android 广播分为两个角色：广播发送者、广播接收者。作用是监听 / 接收 应用 App 发出的广播消息，并 做出响应<br>可应用在：<br>Android不同组件间的通信（含 ：应用内 / 不同应用之间）<br>多线程通信<br>与 Android 系统在特定情况下的通信<br>如：电话呼入时、网络可用时</p>
<h3 id="43-service和activity怎么进行数据交互？"><a href="#43-service和activity怎么进行数据交互？" class="headerlink" title="43.service和activity怎么进行数据交互？"></a>43.service和activity怎么进行数据交互？</h3><p>1.通过 broadcast:通过广播发送消息到 activitry<br>2.通过 Binder：通过与 activity 进行绑定<br>（1）添加一个继承 Binder 的内部类，并添加相应的逻辑方法。<br>（2）重写 Service 的 onBind 方法，返回我们刚刚定义的那个内部类实例。<br>（3）Activity 中创建一个 ServiceConnection 的匿名内部类，并且 重 写 里 面 的 onServiceConnected 方 法 和onServiceDisconnected 方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用（在onServiceConnected方法中，我们可以得到一个刚才那个 service 的 binder 对象，通过对这个 binder 对象进行向下转型，得到我们那个自定义的 Binder 实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了）。</p>
<h3 id="44-Activity-怎么和Service-绑定？怎么在Activity-中启动自己对应的Service？"><a href="#44-Activity-怎么和Service-绑定？怎么在Activity-中启动自己对应的Service？" class="headerlink" title="44.Activity 怎么和Service 绑定？怎么在Activity 中启动自己对应的Service？"></a>44.Activity 怎么和Service 绑定？怎么在Activity 中启动自己对应的Service？</h3><p>1、activity能进行绑定得益于Serviece的接口。为了支持Service的绑定，实现onBind方法。<br>2、Service和Activity的连接可以用ServiceConnection来实现。需要实现一个新的ServiceConnection，重现onServiceConnected和OnServiceDisconnected方法，一旦连接建立，就能得到Service实例的引用。<br>3、执行绑定，调用bindService方法，传入一个选择了要绑定的Service的Intent(显示或隐式)和一个你实现了的ServiceConnection的实例</p>
<h3 id="45-fragment之间传递数据的方式？"><a href="#45-fragment之间传递数据的方式？" class="headerlink" title="45.fragment之间传递数据的方式？"></a>45.fragment之间传递数据的方式？</h3><p>1、在fragment中设置一个方法，然后进行调用<br>2、采取接口回调的方式进行数据传递。<br>3、广播或者是使用三方开源框架：EventBus</p>
<h3 id="46-如何实现Fragment的滑动？"><a href="#46-如何实现Fragment的滑动？" class="headerlink" title="46.如何实现Fragment的滑动？"></a>46.如何实现Fragment的滑动？</h3><p>将Fragment与viewpager绑定，通过viewpager中的touch事件，会进行move事件的滑动处理。</p>
<h3 id="47-Activity状态保存与恢复"><a href="#47-Activity状态保存与恢复" class="headerlink" title="47.Activity状态保存与恢复"></a>47.Activity状态保存与恢复</h3><p>当 Activity 在异常情况( 系统内存不足或者系统配置发生了改变等 )被销毁重建后， 在销毁的时候 Activity 会调用 onSaveInstanceState() 方法用于保存 Activity 相关的状态和数据，然后在重建后的 Activity 的中我们可以通过 onCreate() 或者 onRestoreInstanceState() 方法恢复数据，这里我们需要注意的是如果通过 onCreate() 方法恢复，那么得先判断它的 intent 参数 是否为空，如果在 onRestoreInstanceState() 方法恢复就不会，因为只要 onRestoreInstanceState() 方法被调用就说明一定有数据，不会为空。Google 推荐使用 onRestoreInstanceState() 方法。</p>
<h3 id="48-Activity的四种启动模式对比"><a href="#48-Activity的四种启动模式对比" class="headerlink" title="48.Activity的四种启动模式对比"></a>48.Activity的四种启动模式对比</h3><p>standard 模式：默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。<br>singleTop 模式：如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。<br>singleTask 模式：如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。<br>singleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p>
<h3 id="49-两个Activity-之间跳转时必然会执行的是哪几个方法？"><a href="#49-两个Activity-之间跳转时必然会执行的是哪几个方法？" class="headerlink" title="49.两个Activity 之间跳转时必然会执行的是哪几个方法？"></a>49.两个Activity 之间跳转时必然会执行的是哪几个方法？</h3><p>a. 正常情况下 Activity A 跳转到 Activity B 时:</p>
<p>A 调用 onPause() 方法，然后调用新的 Activity B 中的 onCreate() 方法 -&gt; onStart() 方法 -&gt; onResume() 方法。最后 A 再调用onStop()方法。</p>
<p>b. 当 Activity B 为透明主题时:</p>
<p>除了最后 Activity A 不调用 onStop() 方法之外，其它都和 a 中的一样。</p>
<h3 id="50-Activity上有Dialog的时候按Home键时的生命周期"><a href="#50-Activity上有Dialog的时候按Home键时的生命周期" class="headerlink" title="50.Activity上有Dialog的时候按Home键时的生命周期"></a>50.Activity上有Dialog的时候按Home键时的生命周期</h3><p>有 Dialog 和 无 Dialog 按 Home 键效果一样：</p>
<p>正常启动: onCreate() -&gt; onStart() -&gt; onResume()<br>按 home 键: onPause() -&gt; onStop()<br>再次启动: onRestart() -&gt; onStart() -&gt; onResume()</p>
<h3 id="51-Activity与Fragment之间生命周期比较"><a href="#51-Activity与Fragment之间生命周期比较" class="headerlink" title="51.Activity与Fragment之间生命周期比较"></a>51.Activity与Fragment之间生命周期比较</h3><p>a. 在创建的过程中，是 Activity 带领 Fragment 执行生命周期的方法，所以它们生命周期执行的顺序如下:<br>Activity – onCreate() ，<br>Fragment – onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated  .</p>
<p>Activity – onStart()<br>Fragment – onStart()</p>
<p>Activity – onResume()<br>Fragment – onResume()</p>
<p>最后，在销毁时是 Fragment 带领 Activity 执行生命周期的方法:<br>Fragment – onPause()<br>Activity – onPause()</p>
<p>Fragment – onStop()<br>Activity – onStop()</p>
<p>Fragment – onDestroyView() -&gt; onDestroy() -&gt; onDetach()<br>Activity – onDestroy()</p>
<h3 id="52-横竖屏切换的时候，Activity-各种情况下的生命周期"><a href="#52-横竖屏切换的时候，Activity-各种情况下的生命周期" class="headerlink" title="52.横竖屏切换的时候，Activity 各种情况下的生命周期"></a>52.横竖屏切换的时候，Activity 各种情况下的生命周期</h3><p>分两种情况：<br>1.不设置Activity的android:configChanges，或设置Activity的android:configChanges=”orientation”，或设置Activity的android:configChanges=”orientation|keyboardHidden”，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。<br>横竖屏切换造成 activity 的生命周期<br>onPause()-onSaveInstanceState()-onStop()-onDestroy()-onCreat()-onStart()-onRestoreInstanceState()-onResume()即会导致 activity 的销毁和重建 。</p>
<p>2.配置 android:configChanges=”orientation|keyboardHidden|screenSize”，才不会销毁 activity，且只调用 onConfigurationChanged方法。<br>onSaveInstanceState() 与onRestoreIntanceState() 资源相关的系统配置发生改变或者资源不足时(例如屏幕旋转)，当前 Activity 会销毁，并且在 onStop 之前回调 onSaveInstanceState 保存数据，在重新创建 Activity 的时候在onStart 之后回调 onRestoreInstanceState。其中 Bundle 数据会传到 onCreate（不一定有数据）和 onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个 Activity 的时候不会回调（如代码中 finish（）或用户按下 back，不会回调），其他情况都会调用，来保存界面信息。</p>
<h3 id="53-Activity之间的通信方式"><a href="#53-Activity之间的通信方式" class="headerlink" title="53.Activity之间的通信方式"></a>53.Activity之间的通信方式</h3><p>Intent<br>借助类的静态变量<br>借助全局变量/Application<br>借助外部工具<br>借助SharedPreference<br>使用Android数据库SQLite<br>赤裸裸的使用File<br>Android剪切板<br>借助Service</p>
<h3 id="54-四大组件的生命周期和简单用法"><a href="#54-四大组件的生命周期和简单用法" class="headerlink" title="54.四大组件的生命周期和简单用法"></a>54.四大组件的生命周期和简单用法</h3><p>activity：</p>
<p>onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDetroy() ，onReStart</p>
<p>Service：<br>service 启动方式有两种，一种是通过startService()方式进行启动，另一种是通过bindService()方式进行启动。不同的启动方式他们的生命周期是不一样.</p>
<p>startService()：调用startService() –&gt; onCreate()–&gt; onStartConmon()–&gt; onDestroy()。</p>
<pre><code>        这种方式启动的话，需要注意一下几个问题

        第一：当我们通过startService被调用以后，多次在调用startService(),onCreate()方法也只会被调用一次，而onStartConmon()会被多次调用当我们调用stopService()的时候，onDestroy()就会被调用，从而销毁服务。

        第二：当我们通过startService启动时候，通过intent传值，在onStartConmon()方法中获取值的时候，一定要先判断intent是否为null。
</code></pre>
<p>bindService()方式进行绑定：bindService–&gt;onCreate()–&gt;onBind()–&gt;unBind()–&gt;onDestroy()<br>            好处：更加便利activity中操作service，比如加入service中有几个方法，a,b ，如果要在activity中调用，在需要在activity获取ServiceConnection对象，通过ServiceConnection来获取service中内部类的类对象，然后通过这个类对象就可以调用类中的方法，当然这个类需要继承Binder对象<br>contentProvider：</p>
<p>contentProvider的生命周期、理解应该跟进程一样，它作为系统应用组件、其生命周期应该跟app应用的生命周期类似，只是它属于系统应用、所以随系统启动而初始化，随系统关机而结束；但也存在其他状态下结束进程、比如说系统内存不够时，进行内存回收、会根据生成时间态、用户操作等情况进行是否内存回收。</p>
<p>BroadcastReceiver：</p>
<p>广播的生命周期从调用开始到onReceiver执行完毕结束，需要注意的是，一般广播的生命周期都极短，需要在10s内处理完onReceiver中的所有工作，所以，一般不进行耗时长的工作，如果有耗时长的工作，应当通过Intent传递给Service进行处理。（注意，不要在onReceiver中开启线程进行耗时任务处理，否则，在10s后，该线程会变成空线程，从而导致任务的丢失。同样的，也不要使用bindService来绑定服务。）<br>值得注意的是，如果是在代码中动态注册的广播，如：在Activity注册，那么在Activity的onDestory中需要使用unregisterReceiver注销广播。</p>
<h3 id="55-四大组件是什么？"><a href="#55-四大组件是什么？" class="headerlink" title="55.四大组件是什么？"></a>55.四大组件是什么？</h3><p>Activity<br>Service服务<br>Content Provider内容提供者<br>BroadcastReceiver</p>
<h3 id="56-Handler机制"><a href="#56-Handler机制" class="headerlink" title="56.Handler机制"></a>56.Handler机制</h3><p>Handler主要作用是消息通信，有一个小细节，Handler在子线程直接向主线程（其他线程）发送消息时会报错，原因是在子线程中handler没有Looper.prepare()，而在启动App时候，主线程（Activity）中在实例化的时候已经对Handler进行了Looper.prepare()。一个线程只能有一个Looper对象并且一个线程只能调用一次Looper.prepare()。在Looper.prepare方法中去创建Looper对象，并将其存放在ThreadLocal中，在Looper对象的构造方法中去创建MessageQueue对象，并且让Looper持有其对象，让Looper同时持有当前线程对象。创建Handler对象，在Handler构造方法中得到当前线程的Looper，通过Looper对象得到当前线程的MessageQueue对象，通过入参拿到回调CallBack，Handler初始化结束。Lopper.loop()作用从当前线程的MessageQueue中不断取出Message，并发送出去。在死循环中每次循环会依次判断是否有消息，有发送，发送完之后回收。没有消息会阻塞。所以MessageQueue的next方法可能会阻塞线程，但不会造成ANR。</p>
<p>当MessageQueue没有消息时，next方法中调用nativePollOnce导致线程阻塞，直到有新消息加入MesssageQueue时调用nativeWake来唤醒线程</p>
<p>当MessageQueue有消息时且队头消息为延时消息时，next方法调用nativePollOnce导致线程阻塞nextPollTimeoutMillis的时间，中途有新消息加入MessageQueue时调用nativeWake可以唤醒线程，也可以等nextPollTimeoutMillis后自动唤醒线程</p>
<h3 id="57-Activity到启动流程"><a href="#57-Activity到启动流程" class="headerlink" title="57.Activity到启动流程"></a>57.Activity到启动流程</h3><p>1:启动一个 Activity，都会统一的执行 startActivityForResult() 方法，然后系统经过多次传递后，交给了 AMS 来发出启动的请求。</p>
<p>2:AMS 接收到请求之后，会先进行一些初始化和状态的更新操作，接着解析这个 Activity 的启动模式，做一些初始化工作，然后会判断存放 Activity 的任务栈的情况，如果为空，就直接放进去，如果不为空，先将栈顶 Activity 的退出，置为 pause 状态。</p>
<p>3:然后开始启动目标 Activity，如果这个 Activity 已经启动过了，那么直接执行 onRestart() 恢复启动，否则就执行冷启动，冷启动时，首先会通过 Zygote 创建一个新的进程，并且去执行 ActivityThread 的 main 方法，这便是一个应用程序的入口处，在这里会进行一些初始化操作，比如创建 Looper 开启循环，实例化 ActivityThread 对象，此时Activity 所在的进程和主线程都初始化完成了。</p>
<p>4:开始启动它，首先会对 Activity 的 ComponentName、ContextImpl、Activity 以及 Application 对象进行了初始化并相互关联，然后设置 Activity 主题，最后执行onCreate 等生命周期方法完成Activity的启动</p>
<h5 id="李岩：-另一种解法"><a href="#李岩：-另一种解法" class="headerlink" title="李岩：(另一种解法)"></a>李岩：(另一种解法)</h5><p>Activity 的启动流程主要分为两类： </p>
<p>一个是根Activity启动（从桌面点击图标启动Launcher Activity） </p>
<p>另一个是普通Activity的启动流程，相比根Activity 少了一些步骤。 </p>
<p>主要流程概述： </p>
<p>主体就是 Launcher进程   AMS 系统服务进程   Zytoge进程   应用程序进程 这四个进程相互调用的过程。 </p>
<p>Launcher进程请求AMS系统进程，然后请求创建应用程序进程到Zytoge进程，Zytoge进程创建并启动应用程序进程， 应用程序准备就绪后通知AMS系统服务进程，最后AMS系统服务进程启动根Activity 到应用程序进程。</p>
<p>一. Launcher请求AMS </p>
<ol>
<li>点击图标，调用 Launcher类 的 startActivitySafely 方法，其中调用了内部方法 startActivity </li>
<li>方法里设置了 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);这样根Activity会在新的任务栈中启动，然后调用了activity的 startActivity方法 </li>
<li>startActivity 又调用 startActivityForResult 方法 </li>
<li>startActivityForResult 中判断mParent 是否为空 ，因为是根Activity还没创建，所以会走为空的分支 ，调用 Instrumentation的 execStartActivity 方法（不为空 走startActivityFromChild 方法 这个方法最终还是调用 Instrumentation的 execStartActivity 方法 具体情况后续分析） </li>
<li>看到 Instrumentation的 execStartActivity 方法 ，首先会调用ActivityManagerNative的getDefault来获取ActivityManageService（以后简称为AMS)的代理对象（AMP），接着调用它的startActivity方法。 </li>
<li>AMP是 ActivityManagerNative 的内部类 ，startActivity方法，通过IBinder对象mRemote向AMS发送一个START_ACTIVITY_TRANSACTION类型的进程间通信请求。那么服务端AMS就会从Binder线程池中读取我们客户端发来的数据，最终会调用ActivityManagerNative的onTransact方法中执行， </li>
<li>onTransact中会调用AMS的startActivity方法 </li>
</ol>
<p>二.  AMS到ApplicationThread调用流程 (这个可以只记住主要的就是创建ApplicationThread)</p>
<ol>
<li>AMS的startActivity方法中return了startActivityAsUser方法： </li>
<li>startActivityAsUser方法中又return了mActivityStarter的startActivityMayWait方法 </li>
<li>又调用了startActivityLocked方法 </li>
<li>接着又调用startActivityUnchecked方法： </li>
<li>startActivityUnchecked方法中调用了ActivityStackSupervisor类型的mSupervisor的resumeFocusedStackTopActivityLocked方法 </li>
<li>然后调用了ActivityStack类型mFocusedStack的resumeTopActivityUncheckedLocked方法： </li>
<li>紧接着查看ActivityStack的resumeTopActivityInnerLocked方法 </li>
<li>最后运行 realStartActivityLocked方法 ，app.thread指的是IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread，其中ApplicationThread继承了ApplicationThreadNative，而ApplicationThreadNative继承了Binder并实现了IApplicationThread接口。最后调用了ApplicationThread的scheduleLaunchActivity方法 </li>
</ol>
<p>三.  ActivityThread启动Activity </p>
<ol>
<li>ApplicationThread的scheduleLaunchActivity方法，scheduleLaunchActivity方法会将启动Activity的参数封装成ActivityClientRecord，调用sendMessage传递参数</li>
<li>sendMessage方法发送类型为LAUNCH_ACTIVITY的消息到mH, 它是ActivityThread的内部类并继承Handler的，并将ActivityClientRecord 传递过去。</li>
<li>通过getPackageInfoNoCheck方法获得LoadedApk类型的对象并赋值给ActivityClientRecord 的成员变量packageInfo 。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而LoadedApk就是用来描述已加载的APK文件。</li>
<li>调用handleLaunchActivity方法，里面会调用performLaunchActivity方法用来启动Activity ，performLaunchActivity中会获取ActivityInfo，获取APK文件的描述类LoadedApk，获取要启动的Activity的ComponentName类，ComponentName类中保存了该Activity的包名和类名。根据ComponentName中存储的Activity类名，用类加载器来创建该Activity的实例。还会创建Application，makeApplication方法内部会调用Application的onCreate方法，创建要启动Activity的上下文环境。调用Activity的attach方法初始化Activity，attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联。最后会调用Instrumentation的callActivityOnCreate方法来启动Activity</li>
<li>如果performLaunchActivity获取的Activity为null则会通知ActivityManager停止启动Activity。如果不为空将Activity 的状态置为Resume。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/topic/topic_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-有时候我们想中断run-方法的执行，怎么办呢，是直接使用stop-方法还是使用interrupt-？"><a href="#1-有时候我们想中断run-方法的执行，怎么办呢，是直接使用stop-方法还是使用interrupt-？" class="headerlink" title="1.有时候我们想中断run()方法的执行，怎么办呢，是直接使用stop()方法还是使用interrupt ？"></a><strong>1.有时候我们想中断run()方法的执行，怎么办呢，是直接使用stop()方法还是使用interrupt ？</strong></h3><p>正确的姿势是使用interrupt</p>
<ol>
<li><p>stop()方法会直接杀死线程，一点喘息的机会都不给，如果被杀死的线程持有sychronized隐式锁，你就再也不会释放掉这个锁了，接下来的线程也都不会获得这个锁了，同样suspend()和resume()方法也不建议使用</p>
</li>
<li><p>interrupt()方法相比于stop()方法就柔和很多，它只是通知线程后续的操作可以不用执行了，线程可以选择继续执行，也可以选择立即停止，也可以选择过一段时间再停止。interrupt()只是通知一下线程而已。就比如你做火车去一个地方，突然通知你这个火车晚点了，你可以选择无视这个通知继续等待，或者选择另一个火车，但是不管你做什么，和火车站都没有关系，它通知的责任尽到了。</p>
</li>
</ol>
<h3 id="2-java进程的生命周期"><a href="#2-java进程的生命周期" class="headerlink" title="2.java进程的生命周期"></a>2.java进程的生命周期</h3><p>系统/java的线程通用生命周期：</p>
<ol>
<li>new ：线程被创建，没有分配到CPU，因为这个状态只是说明这个线程在编程语言层面被创建了，操作系统层面还没有被创建。</li>
<li>ready ：在操作系统层面创建了，接下来就是等待分配CPU执行了。</li>
<li>running ：分配了CPU，开始执行的状态。</li>
<li>wating ： 正在执行的时候，需要进行I/O操作，或者需要等待一段时间再执行，此时会释放掉CPU资源。</li>
<li>terminoted ：线程执行完毕/遇到异常，此状态不能再切换到任何状态了。</li>
</ol>
<p>java线程的生命周期：</p>
<ol>
<li><p>new ： 同上</p>
</li>
<li><p>runnable ：thread调用了start方法，java线程正在执行时的状态</p>
</li>
<li><p>blocked ：线程等待synchronized隐式锁时，就会从runnable状态转换为blocked状态，也就是等待持有锁的线程释放锁，获得锁的时候会切换到runnable状态。此时在操作系统层面还是runnable状态。</p>
</li>
<li><p>waiting ：执行wait方法进入等待状态</p>
</li>
<li><p>timed_wating ：超时限等待状态，与wating相比就是多了个时间限制</p>
</li>
<li><p>terminoted ：同上<br> 在java的生命周期中，runnable状态是将ready和running状态合并到了一起。<br> 而blocked/waiting/timed_waiting这三种状态其实就是waiting，也就是线程要等待某些事件发生，才能继续执行下去。</p>
</li>
</ol>
<h3 id="3-java中独占锁-共享锁"><a href="#3-java中独占锁-共享锁" class="headerlink" title="3.java中独占锁/共享锁"></a>3.java中独占锁/共享锁</h3><p>写锁（独占锁）：是指该锁一次只能被一个线程锁持有。对ReentrantLock和Sychronized而言都是独占锁。<br>读锁（共享锁）：是指该锁可被多个线程持有。对ReentrantReadWriteLock而言，其读锁是共享锁，其写锁是独占锁。读锁的共享性可保证并发读是非常高效的，读写、写读、写写的过程都是互斥的。</p>
<h3 id="4-说一下对线程池的理解"><a href="#4-说一下对线程池的理解" class="headerlink" title="4.说一下对线程池的理解"></a>4.说一下对线程池的理解</h3><p>线程池的好处：</p>
<p>1、通过对线程的复用，减小创建线程及销毁线程的性能消耗；</p>
<p>2、能控制线程池中的并发数，否则会因为大量的线程争夺CPU资源造成阻塞；</p>
<p>3、能对对线程进行管理，比如使用schaduledTheadPool可以延迟执行任务/循环执行任务。</p>
<p>线程池接口Executor：</p>
<p>Executor是一个接口，它的实现是ThreadPoolExecutor，Android中的线程池都是直接或者间接配置ThreadPoolExector来实现不同特性的线程池。</p>
<p>ThreadPoolExecutor执行任务的步骤：</p>
<p>1、当线程数&lt;核心线程数时，直接创建一个核心线程执行任务；</p>
<p>2、当线程数&gt;=核心线程数时，且当workQueue未满时，会将任务加入到workQueue等待执行；</p>
<p>3、当workQueue满时，会创建一个非核心线程执行任务；</p>
<p>4、当线程数&gt;核心线程数，且workQueue已满，且线程数&gt;最大线程数，调用handler默认抛出RejectExecutionExpection异常。</p>
<p>Android中的四种线程池：</p>
<p>1、FixedTheadPool：只有核心线程，并且数量固定，也不会被回收。当所有线程都在活动时，因为队列没有限制大小，新任务会等待执行。由于线程不会被回收，所以执行外界任务时更快一些。</p>
<p>2、SingleThreadPool：只有一个核心线程，确保所有任务都在同一个线程中按顺序执行。因此不需要处理线程同步问题。</p>
<p>3、CahcedThreadPool：只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则利用空闲线程（60s空闲时间，过了就会被回收，所以线程池中有0个线程的可能）处理任务。比较适合执行大量的耗时较少的任务</p>
<p>4、 ScheduledThreadPool：核心线程数固定，非核心线程（闲着没活干会被立即回收）数没有限制。主要用于执行定时任务以及有固定周期的重复任务。</p>
<p>总结自：<a href="https://www.cnblogs.com/1925yiyi/p/9040605.html">https://www.cnblogs.com/1925yiyi/p/9040605.html</a></p>
<h3 id="5-多线程间的有序性、可见性和原子性是什么意思？"><a href="#5-多线程间的有序性、可见性和原子性是什么意思？" class="headerlink" title="5.多线程间的有序性、可见性和原子性是什么意思？"></a>5.多线程间的有序性、可见性和原子性是什么意思？</h3><p>原子性：执行一个或者多个操作的时候，要么全部执行，要么都不执行，并且中间过程中不会被打断。Java中的原子性可以通过独占锁和CAS去保证<br>可见性：指多线程访问同一个变量的时候，一个线程修改了变量的值，其他线程能够立刻看得到修改的值。锁和volatile能够保证可见性<br>有序性：程序执行的顺序按照代码先后的顺序执行。锁和volatile能够保证有序性</p>
<h3 id="6-wait-notify和Condition类实现的等待通知有什么区别？"><a href="#6-wait-notify和Condition类实现的等待通知有什么区别？" class="headerlink" title="6.wait/notify和Condition类实现的等待通知有什么区别？"></a>6.wait/notify和Condition类实现的等待通知有什么区别？</h3><p>  synchronized与wait/notify结合的等待通知只有一个条件，而Condition类可以实现多个条件等待。</p>
<h3 id="7-notify和notifyAll方法的区别？"><a href="#7-notify和notifyAll方法的区别？" class="headerlink" title="7.notify和notifyAll方法的区别？"></a>7.notify和notifyAll方法的区别？</h3><p>notify随机唤醒一个线程，notifyAll唤醒所有等待的线程，让他们竞争锁。</p>
<h3 id="8-CAS是什么？底层原理？"><a href="#8-CAS是什么？底层原理？" class="headerlink" title="8.CAS是什么？底层原理？"></a>8.CAS是什么？底层原理？</h3><p>CAS全称Compare And Set，核心的三个元素是：内存位置、预期原值和新值，执行CAS的时候，会将内存位置的值与预期原值进行比较，如果一致，就将原值更新为新值，否则就不更新。 底层原理：是借助CPU底层指令cmpxchg实现原子操作。</p>
<h3 id="9-悲观锁和乐观锁的举例？以及它们的相关实现？"><a href="#9-悲观锁和乐观锁的举例？以及它们的相关实现？" class="headerlink" title="9.悲观锁和乐观锁的举例？以及它们的相关实现？"></a>9.悲观锁和乐观锁的举例？以及它们的相关实现？</h3><p>悲观锁和乐观锁的概念：</p>
<p>悲观锁：悲观锁会认为，修改共享数据的时候其他线程也会修改数据，因此只在不会受到其他线程干扰的情况下执行。这样会导致其他有需要锁的线程挂起，等到持有锁的线程释放锁<br>乐观锁：每次不加锁，每次直接修改共享数据假设其他线程不会修改，如果发生冲突就直接重试，直到成功为止<br>举例：</p>
<p>悲观锁：典型的悲观锁是独占锁，有synchronized、ReentrantLock。<br>乐观锁：典型的乐观锁是CAS，实现CAS的atomic为代表的一系列类</p>
<h3 id="10-synchronized和Lock的区别？"><a href="#10-synchronized和Lock的区别？" class="headerlink" title="10.synchronized和Lock的区别？"></a>10.synchronized和Lock的区别？</h3><p>主要区别：</p>
<p>synchronized是Java中的关键字，是Java的内置实现；Lock是Java中的接口。<br>synchronized遇到异常会释放锁；Lock需要在发生异常的时候调用成员方法Lock#unlock()方法。<br>synchronized是不可以中断的，Lock可中断。<br>synchronized不能去尝试获得锁，没有获得锁就会被阻塞；Lock可以去尝试获得锁，如果未获得可以尝试处理其他逻辑。<br>synchronized多线程效率不如Lock，不过Java在1.6以后已经对synchronized进行大量的优化，所以性能上来讲，其实差不了多少。</p>
<h3 id="11-synchronized的原理？"><a href="#11-synchronized的原理？" class="headerlink" title="11.synchronized的原理？"></a>11.synchronized的原理？</h3><p>任何一个对象都有一个monitor与之相关联，JVM基于进入和退出mointor对象来实现代码块同步和方法同步，两者实现细节不同：</p>
<p>代码块同步：在编译字节码的时候，代码块起始的地方插入monitorenter指令，异常和代码块结束处插入monitorexit指令，线程在执行monitorenter指令的时候尝试获取monitor对象的所有权，获取不到的情况下就是阻塞<br>方法同步：synchronized方法在method_info结构有AAC_synchronized标记，线程在执行的时候获取对应的锁，从而实现同步方法</p>
<h3 id="12-synchronized关键字的使用？synchronized的参数放入对象和Class有什么区别？"><a href="#12-synchronized关键字的使用？synchronized的参数放入对象和Class有什么区别？" class="headerlink" title="12.synchronized关键字的使用？synchronized的参数放入对象和Class有什么区别？"></a>12.synchronized关键字的使用？synchronized的参数放入对象和Class有什么区别？</h3><p>synchronized关键字的用法：</p>
<p>修饰方法<br>修饰代码块：需要自己提供锁对象，锁对象包括对象本身、对象的Class和其他对象。<br>放入对象和Class的区别是：</p>
<p>锁住的对象不同：成员方法锁住的实例对象，静态方法锁住的是Class。<br>访问控制不同：如果锁住的是实例，只会针对同一个对象方法进行同步访问，多线程访问同一个对象的synchronized代码块是串行的，访问不同对象是并行的。如果锁住的是类，多线程访问的不管是同一对象还是不同对象的synchronized代码块是都是串行的。</p>
<h3 id="13-IdleHandler介绍？"><a href="#13-IdleHandler介绍？" class="headerlink" title="13.IdleHandler介绍？"></a>13.IdleHandler介绍？</h3><p>介绍： IdleHandler是在Hanlder空闲时处理空闲任务的一种机制。</p>
<p>执行场景：</p>
<p>MessageQueue没有消息，队列为空的时候。<br>MessageQueue属于延迟消息，当前没有消息执行的时候。<br>会不会发生死循环： 答案是否定的，MessageQueue使用计数的方法保证一次调用MessageQueue#next方法只会使用一次的IdleHandler集合。</p>
<h3 id="14-Looper在主线程中死循环为什么没有导致界面的卡死？"><a href="#14-Looper在主线程中死循环为什么没有导致界面的卡死？" class="headerlink" title="14.Looper在主线程中死循环为什么没有导致界面的卡死？"></a>14.Looper在主线程中死循环为什么没有导致界面的卡死？</h3><p>导致卡死的是在Ui线程中执行耗时操作导致界面出现掉帧，甚至ANR，Looper.loop()这个操作本身不会导致这个情况。<br>有人可能会说，我在点击事件中设置死循环会导致界面卡死，同样都是死循环，不都一样的吗？Looper会在没有消息的时候阻塞当前线程，释放CPU资源，等到有消息到来的时候，再唤醒主线程。<br>App进程中是需要死循环的，如果循环结束的话，App进程就结束了。<br>建议阅读：<a href="https://www.zhihu.com/question/34652589">https://www.zhihu.com/question/34652589</a></p>
<h3 id="15-Hander原理"><a href="#15-Hander原理" class="headerlink" title="15.Hander原理"></a>15.Hander原理</h3><p>Handler，loop轮询检测发送消息到MessagerQuery,MessageQuery对Message入列，Handler回调方法处理消息，重写handMessage方法刷新ui</p>
<h3 id="16-进程和线程的区别"><a href="#16-进程和线程的区别" class="headerlink" title="16.进程和线程的区别"></a>16.进程和线程的区别</h3><p>概念：进程包括多个线程，一个程序一个进程，多线程的优点可以提高执行效率，提高资源利用率<br>创建：Thread类和Runnable接口，<br>常用方法有：<br>start()用于启动线程<br>run()调用线程对象中的run方法<br>join()合并插队到当前线程<br>sellp()睡眠释放cpu资源<br>setPriority()设置线程优先级</p>
<h3 id="17-wait和-sleep-的区别"><a href="#17-wait和-sleep-的区别" class="headerlink" title="17.wait和 sleep 的区别"></a>17.wait和 sleep 的区别</h3><p>wait是Object的方法，wait是对象锁，锁定方法不让继续执行，当执行notify方法后就会继续执行，sleep 是Thread的方法，sleep 是使线程睡眠，让出cpu，结束后自动继续执行</p>
<h3 id="18-跨进程通信的几种方式"><a href="#18-跨进程通信的几种方式" class="headerlink" title="18.跨进程通信的几种方式"></a>18.跨进程通信的几种方式</h3><p>Intent,比如拨打电话<br>ContentProvider数据库存储数据<br>Broadcast广播通信<br>AIDL通信，通过接口共享数据</p>
<h3 id="19-obtinMessage的优势，为什么不用new-Message？"><a href="#19-obtinMessage的优势，为什么不用new-Message？" class="headerlink" title="19.obtinMessage的优势，为什么不用new Message？"></a>19.obtinMessage的优势，为什么不用new Message？</h3><p>从整个Messge池中返回一个新的Message实例，在许多情况下使用它，因为它能避免分配新的对象</p>
<p>如果是这样的话，那么通过调用obtainMessage方法获取Message对象就能避免创建对象，从而减少内存的开销了。</p>
<h3 id="20-handler的延时发送消息是怎么实现的"><a href="#20-handler的延时发送消息是怎么实现的" class="headerlink" title="20.handler的延时发送消息是怎么实现的"></a>20.handler的延时发送消息是怎么实现的</h3><p>本质上是通过调用handler的sendMessageAtTime，起原理的在消息插入队列的时候，会根据消息插入时的当前时间+需要延时的时间，来算好消息在队列中的位置，loop去取消息的时候，会判断当前时间和该消息的发送时间，如果当前时间大于发送的时间，loop则取出消息并发送，否则让线程进入休息，一段时间，到下次消息需要发送的时候，再触发。</p>
<h3 id="21-线程池"><a href="#21-线程池" class="headerlink" title="21.线程池"></a>21.线程池</h3><p>Android中常见的线程池有四种，FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadExecutor。</p>
<p>FixedThreadPool线程池是通过Executors的new FixedThreadPool方法来创建。它的特点是该线程池中的线程数量是固定的。即使线程处于闲置的状态，它们也不会被回收，除非线程池被关闭。当所有的线程都处于活跃状态的时候，新任务就处于队列中等待线程来处理。注意，FixedThreadPool只有核心线程，没有非核心线程。</p>
<p>CachedThreadPool线程池是通过Executors的newCachedThreadPool进行创建的。它是一种线程数目不固定的线程池，它没有核心线程，只有非核心线程，当线程池中的线程都处于活跃状态，就会创建新的线程来处理新的任务。否则就会利用闲置的线程来处理新的任务。线程池中的线程都有超时机制，这个超时机制时长是60s，超过这个时间，闲置的线程就会被回收。这种线程池适合处理大量并且耗时较少的任务。这里得说一下，CachedThreadPool的任务队列，基本都是空的。</p>
<p>ScheduledThreadPool线程池是通过Executors的newScheduledThreadPool进行创建的，它的核心线程是固定的，但是非核心线程数是不固定的，并且当非核心线程一处于空闲状态，就立即被回收。这种线程适合执行定时任务和具有固定周期的重复任务。</p>
<p>SingleThreadExecutor线程池是通过Executors的newSingleThreadExecutor方法来创建的，这类线程池中只有一个核心线程，也没有非核心线程，这就确保了所有任务能够在同一个线程并且按照顺序来执行，这样就不需要考虑线程同步的问题。</p>
<h3 id="22-进程保活的方式"><a href="#22-进程保活的方式" class="headerlink" title="22.进程保活的方式"></a>22.进程保活的方式</h3><p>此处延伸：进程的优先级是什么<br>当前业界的Android进程保活手段主要分为** 黑、白、灰 **三种，其大致的实现思路如下：<br>黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）<br>白色保活：启动前台Service<br>灰色保活：利用系统的漏洞启动前台Service<br>黑色保活<br>所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：<br>场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app<br>场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景3<br>场景3：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）<br>白色保活<br>白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如下方的LBE和QQ音乐这样：<br>灰色保活<br>灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下：<br>思路一：API &lt; 18，启动前台Service时直接传入new Notification()； 思路二：API &gt;= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理<br>熟悉Android系统的童鞋都知道，系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app。这套杀进程回收内存的机制就叫 Low Memory Killer ，它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。<br>进程的重要性，划分5级：<br>前台进程 (Foreground process)<br>可见进程 (Visible process)<br>服务进程 (Service process)<br>后台进程 (Background process)<br>空进程 (Empty process)<br>了解完 Low Memory Killer，再科普一下oom_adj。什么是oom_adj？它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。对于oom_adj的作用，你只需要记住以下几点即可：<br>进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收<br>普通app进程的oom_adj&gt;=0,系统进程的oom_adj才可能&lt;0<br>有些手机厂商把这些知名的app放入了自己的白名单中，保证了进程不死来提高用户体验（如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通app一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。<br>还有一种就是放到对应手机厂商的白名单中，那进程不会被杀死了。</p>
<h3 id="23-Android进程分类？"><a href="#23-Android进程分类？" class="headerlink" title="23.Android进程分类？"></a>23.Android进程分类？</h3><p>前台进程，可见进程，服务进程，后台进程，空进程</p>
<h3 id="24-Java多线程引发的性能问题，怎么解决？"><a href="#24-Java多线程引发的性能问题，怎么解决？" class="headerlink" title="24.Java多线程引发的性能问题，怎么解决？"></a>24.Java多线程引发的性能问题，怎么解决？</h3><p>使用线程池来进行管理</p>
<h3 id="25-线程池有没有上限？"><a href="#25-线程池有没有上限？" class="headerlink" title="25.线程池有没有上限？"></a>25.线程池有没有上限？</h3><p>其实这个没有上限的，因为资源都限制在这个进程里，你开多少线程都最多用这些资源。</p>
<h3 id="26-Android线程有没有上限？"><a href="#26-Android线程有没有上限？" class="headerlink" title="26.Android线程有没有上限？"></a>26.Android线程有没有上限？</h3><p>Android系统会给每个应用分配一个内存空间（不同的系统分配的内存大小不同），这块内存空间大小是有限的。<br>创建线程需要占用内存空间，<br>不可能拿有限的内存空间创建无限的线程。<br>结论：<br>Android线程是有上限的。如果应用创建线程的数量过多，而没有及时释放会导致OOM</p>
<h3 id="27-ANR定位和修正"><a href="#27-ANR定位和修正" class="headerlink" title="27.ANR定位和修正"></a>27.ANR定位和修正</h3><p>定位：ANR一般有三种类型<br>KeyDispatchTimeout(5 seconds) –主要类型<br>按键或触摸事件在特定时间内无响应<br>BroadcastTimeout(10 seconds)<br>BroadcastReceiver在特定时间内无法处理完成<br>ServiceTimeout(20 seconds) –小概率类型<br>Service在特定的时间内无法处理完成</p>
<p>修正：</p>
<p>1、主线程当中执行IO/网络操作，容易阻塞。<br>2、主线程当中执行了耗时的计算。（比如自定义控件中的onDraw()方法）<br>在onDraw()方法里面创建对象容易导致内存抖动（绘制动作时会大量不间断调用，产生大量垃圾对象导致GC很频繁，就造成了内存抖动），内存抖动就容易造成UI出现掉帧、卡顿等问题。<br>3、BroadCastReceiver没有在10秒内完成处理。<br>4、BroadCastReceiver的onReceived代码中也要尽量减少耗时的操作，建议使用IntentService处理。<br>5、Service执行了耗时的操作，因为Service也是在主线程当中执行的，所以耗时操作应该在Service里面开启子线程来做。<br>6、使用AsyncTask处理耗时的IO等操作。<br>7、Activity的onCreate和onResume回调中尽量耗时的操作。</p>
<h3 id="28-ANR产生的原因是什么？"><a href="#28-ANR产生的原因是什么？" class="headerlink" title="28.ANR产生的原因是什么？"></a>28.ANR产生的原因是什么？</h3><p>ANR即Application Not Responding，顾名思义就是应用程序无响应。</p>
<p>在Android中，一般情况下，四大组件均是工作在主线程中的，Android中的Activity Manager和Window Manager会随时监控应用程序的响应情况，如果因为一些耗时操作（网络请求或者IO操作）造成主线程阻塞一定时间（例如造成5s内不能响应用户事件或者BroadcastReceiver的onReceive方法执行时间超过10s），那么系统就会显示ANR对话框提示用户对应的应用处于无响应状态。</p>
<h3 id="29-为什么不能在子线程更新UI？"><a href="#29-为什么不能在子线程更新UI？" class="headerlink" title="29.为什么不能在子线程更新UI？"></a>29.为什么不能在子线程更新UI？</h3><p>目的在于提高移动端更新UI的效率和和安全性，以此带来流畅的体验。原因是：<br>Android的UI访问是没有加锁的，多个线程可以同时访问更新操作同一个UI控件。也就是说访问UI的时候，android系统当中的控件都不是线程安全的，这将导致在多线程模式下，当多个线程共同访问更新操作同一个UI控件时容易发生不可控的错误，而这是致命的。所以Android中规定只能在UI线程中访问UI，这相当于从另一个角度给Android的UI访问加上锁，一个伪锁。</p>
<h3 id="30-AsyncTask适合做什么？不适合做什么？"><a href="#30-AsyncTask适合做什么？不适合做什么？" class="headerlink" title="30.AsyncTask适合做什么？不适合做什么？"></a>30.AsyncTask适合做什么？不适合做什么？</h3><p>适合：<br>a.执行过程单一，仅输入一次，输出一次。<br>b.花费时间非常短但是仍然需要到后台去做事情，然后更新UI。例如加载文件，web页面或者数据库到UI。<br>c.执行线程必须是UI线程<br>d.不需要长期维护状态。</p>
<p>不适合：</p>
<p>a.长时间的任务。<br>b.可重复调用的任务。<br>c.需要线程执行多个不同任务，任务之间又有关联。<br>d.执行线程不是UI线程。<br>e.任务执行后仍然需要维护一些状态。<br>f.后台服务模块,需要提供独立的API.</p>
<h3 id="31-如何取消AsyncTask？"><a href="#31-如何取消AsyncTask？" class="headerlink" title="31.如何取消AsyncTask？"></a>31.如何取消AsyncTask？</h3><p>1、调用cancel()：但是他是在doInBackground（）之后执行</p>
<p>如果调用cancel（）方法，它不会立即执行，只有当doInBackground()方法执行完有返回值之后，会在UI主线程调用cancel（），同时也会间接的调用iscancelled（），并且返回true ，这个时候就不会再调onPostExecute（），然后在doInBackground（）里定期检查iscancelled（）方法的返回值，是否被cancel，如果return true，就尽快停止。</p>
<p>2、在耗时操作中设置一些flag：我们可以在这个线程中的耗时操作中设置一些flag，也就是AsyncTask的doInBackground方法中的某些关键步骤。<br>然后在外层需要终止此线程的地方改变这个flag值，线程中的耗时代码一步步执行，当某一时刻发现flag的值变了，throwException，线程就不会再继续执行了。为了保险起见，在外层我们还要捕获这个异常，进行相应处理。（子线程被发生异常后会自己死掉而不会引起其他问题，更不会影响到主线程，更何况我们为了更加安全还捕获了异常并做处理）</p>
<h3 id="32-AsyncTask原理及不足"><a href="#32-AsyncTask原理及不足" class="headerlink" title="32.AsyncTask原理及不足"></a>32.AsyncTask原理及不足</h3><p>原理：<br>AsyncTask是Android本身提供的一种轻量级的异步任务类。它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程更新UI。实际上，AsyncTask内部是封装了Thread和Handler。虽然AsyncTask很方便的执行后台任务，以及在主线程上更新UI，但是，AsyncTask并不合适进行特别耗时的后台操作，对于特别耗时的任务，个人还是建议使用线程池。<br>AsyncTask提供有4个核心方法：<br>1、onPreExecute():该方法在主线程中执行，在执行异步任务之前会被调用，一般用于一些准备工作。<br>2、doInBackground(String… params):这个方法是在线程池中执行，此方法用于执行异步任务。在这个方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法，另外，任务的结果返回给onPostExecute方法。<br>3、onProgressUpdate(Object… values):该方法在主线程中执行，主要用于任务进度更新的时候，该方法会被调用。<br>4、onPostExecute(Long aLong)：在主线程中执行，在异步任务执行完毕之后，该方法会被调用，该方法的参数及为后台的返回结果。<br>除了这几个方法之外还有一些不太常用的方法，如onCancelled(),在异步任务取消的情况下，该方法会被调用。<br>源码可以知道从上面的execute方法内部调用的是executeOnExecutor()方法，即executeOnExecutor(sDefaultExecutor, params);而sDefaultExecutor实际上是一个串行的线程池。而onPreExecute()方法在这里就会被调用了。接着看这个线程池。AsyncTask的执行是排队执行的，因为有关键字synchronized，而AsyncTask的Params参数就封装成为FutureTask类，FutureTask这个类是一个并发类，在这里它充当了Runnable的作用。接着FutureTask会交给SerialExecutor的execute方法去处理，而SerialExecutor的executor方法首先就会将FutureTask添加到mTasks队列中，如果这个时候没有任务，就会调用scheduleNext()方法，执行下一个任务。如果有任务的话，则执行完毕后最后在调用 scheduleNext();执行下一个任务。直到所有任务被执行完毕。而AsyncTask的构造方法中有一个call()方法，而这个方法由于会被FutureTask的run方法执行。所以最终这个call方法会在线程池中执行。而doInBackground这个方法就是在这里被调用的。我们好好研究一下这个call()方法。mTaskInvoked.set(true);表示当前任务已经执行过了。接着执行doInBackground方法，最后将结果通过postResult(result);方法进行传递。postResult()方法中通过sHandler来发送消息，sHandler的中通过消息的类型来判断一个MESSAGE_POST_RESULT，这种情况就是调用onPostExecute(result)方法或者是onCancelled(result)。另一种消息类型是MESSAGE_POST_PROGRESS则调用更新进度onProgressUpdate。</p>
<p>不足：AsyncTask的优点在于执行完后台任务后可以很方便的更新UI，然而使用它存在着诸多的限制。先抛开内存泄漏问题，使用AsyncTask主要存在以下局限性：<br>在Android 4.1版本之前，AsyncTask类必须在主线程中加载，这意味着对AsyncTask类的第一次访问必须发生在主线程中；在Android 4.1以及以上版本则不存在这一限制，因为ActivityThread（代表了主线程）的main方法中会自动加载AsyncTask<br>AsyncTask对象必须在主线程中创建<br>AsyncTask对象的execute方法必须在主线程中调用<br>一个AsyncTask对象只能调用一次execute方法</p>
<h3 id="33-AsyncTask设计的思想是什么？"><a href="#33-AsyncTask设计的思想是什么？" class="headerlink" title="33.AsyncTask设计的思想是什么？"></a>33.AsyncTask设计的思想是什么？</h3><p>AsyncTask的设计是为了成为一个关于Thread和Handler的帮助类，并不是一个通用的线程框架。AsyncTask理想情况下，应该被使用于非常短的操作（最多几秒）。如果您希望您的线程可以运行很长时间，非常建议您使用java.util.concurrent包里面的API。例如Executor，ThreadPoolExecutor 和FutureTask</p>
<h3 id="34-AsyncTask是什么？"><a href="#34-AsyncTask是什么？" class="headerlink" title="34.AsyncTask是什么？"></a>34.AsyncTask是什么？</h3><p>AsyncTask使得可以恰当和简单地使用 UI线程。这个class允许你在后台做一些事情，然后把进度和结果告诉UI线程，而不需要操作handler和线程。</p>
<h3 id="35-请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系"><a href="#35-请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系" class="headerlink" title="35.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系"></a>35.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</h3><p>Android中主线程是不能进行耗时操作的，子线程是不能进行更新UI的。所以就有了handler，它的作用就是实现线程之间的通信。<br>handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创建的时候，就会在主线程中创建handler对象，<br>我们通过要传送的消息保存到Message中，handler通过调用sendMessage方法将Message发送到MessageQueue中，Looper对象就会不断的调用loop()方法<br>不断的从MessageQueue中取出Message交给handler进行处理。从而实现线程之间的通信。</p>
<h3 id="36-主线程中的Looper-loop-一直无限循环为什么不会造成ANR？"><a href="#36-主线程中的Looper-loop-一直无限循环为什么不会造成ANR？" class="headerlink" title="36.主线程中的Looper.loop()一直无限循环为什么不会造成ANR？"></a>36.主线程中的Looper.loop()一直无限循环为什么不会造成ANR？</h3><p>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。</p>
<h3 id="37-Looper为什么要无限循环？"><a href="#37-Looper为什么要无限循环？" class="headerlink" title="37.Looper为什么要无限循环？"></a>37.Looper为什么要无限循环？</h3><p>主线程中如果没有looper进行循环，那么主线程一运行完毕就会退出。那么我们还能运行APP吗，显然，这是不可能的，Looper主要就是做消息循环，然后由Handler进行消息分发处理，一旦退出消息循环，那么你的应用也就退出了。</p>
<h3 id="38-Handler机制和底层实现"><a href="#38-Handler机制和底层实现" class="headerlink" title="38.Handler机制和底层实现"></a>38.Handler机制和底层实现</h3><p>上面一共出现了几种类，ActivityThread，Handler，MessageQueue，Looper，msg（Message）,对这些类作简要介绍：<br>ActivityThread：程序的启动入口，该类就是我们说的主线程，它对Looper进行操作的。<br>Handler：字面意思是操控者，该类有比较重要的地方，就是通过handler来发送消息（sendMessage）到<br>MessageQueue和 操作控件的更新（handleMessage）。handler下面持有这MessageQueue和Looper的对象。<br>MessageQueue：字面意思是消息队列，就是封装Message类。对Message进行插入和取出操作。<br>Message：这个类是封装消息体并被发送到MessageQueue中的，给类是通过链表实现的，其好处方便MessageQueue的插入和取出操作。还有一些字段是（int what，Object obj，int arg1，int arg2）。what是用户定义的消息和代码，以便接收者（handler）知道这个是关于什么的。obj是用来传输任意对象的，arg1和arg2是用来传递一些简单的整数类型的。</p>
<p>先获取looper，如果没有就创建</p>
<p>创建过程：</p>
<p>ActivityThread 执行looperMainPrepare（），该方法先实例化MessageQueue对象，然后实例化Looper对象，封装mQueue和主线程，把自己放入ThreadLocal中</p>
<p>再执行loop（）方法，里面会重复死循环执行读取MessageQueue。接着ActivityThread 执行Looper对象中的loop（）方法）<br>此时调用sendMessage（）方法，往MessageQueue中添加数据，其取出消息队列中的handler，执行dispatchMessage（），进而执行handleMessage（），Message的数据结构是基于链表的</p>
<h3 id="39-ThreadLocal原理，实现及如何保证Local属性？"><a href="#39-ThreadLocal原理，实现及如何保证Local属性？" class="headerlink" title="39.ThreadLocal原理，实现及如何保证Local属性？"></a>39.ThreadLocal原理，实现及如何保证Local属性？</h3><p>ThreadLocal：当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。（Looper、ActivityThread以及AMS中都用到了），如使用ThreadLocal可以解决不同线程不同Looper的需求。</p>
<p>虽然在不同线程中访问的是同一个ThreadLocal对象，但是它们通过ThreadLocal来获取到的值却是不一样的，这就是ThreadLocal的奇妙之处。ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。（从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所做的读写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰地存储和修改数据。）</p>
<h3 id="40-关于Handler，在任何地方new-Handler-都是什么线程下"><a href="#40-关于Handler，在任何地方new-Handler-都是什么线程下" class="headerlink" title="40.关于Handler，在任何地方new Handler 都是什么线程下?"></a>40.关于Handler，在任何地方new Handler 都是什么线程下?</h3><p>Handler内部通过 Looper.myLooper() 来获取 Looper 对象，也就是说对于不传递 Looper 对象的情况下，<br>在哪个线程创建 Handler 默认获取的就是该线程的 Looper 对象，那么 Handler 的一系列操作都是在该<br>线程进行的。</p>
<p>对于传递 Looper 对象创建 Handler 的情况下，传递的 Looper 是哪个线程的，Handler 绑定的就是该线程。</p>
<h3 id="41-为什么在主线程可以直接使用-Handler？"><a href="#41-为什么在主线程可以直接使用-Handler？" class="headerlink" title="41.为什么在主线程可以直接使用 Handler？"></a>41.为什么在主线程可以直接使用 Handler？</h3><p>因为主线程已经创建了 Looper 对象并开启了消息循环</p>
<h3 id="42-Handler、Thread和HandlerThread的差别"><a href="#42-Handler、Thread和HandlerThread的差别" class="headerlink" title="42.Handler、Thread和HandlerThread的差别"></a>42.Handler、Thread和HandlerThread的差别</h3><p>Handler：在Android中负责发送和处理消息，通过它可以实现其他支线线程与主线程之间的消通讯<br>Thread：线程，可以看作是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的独立运行的基本单位<br>HandlerThread：封装了Handler + ThreadHandlerThread适合在有需要一个工作线程（非UI线程）+任务的等待队列的形式，优点是不会有堵塞，减少了对性能的消耗，缺点是不能同时进行多个任务的处理，需要等待进行处理。处理效率低，可以当成一个轻量级的线程池来用</p>
<h3 id="43-谈谈多线程在Android中的使用"><a href="#43-谈谈多线程在Android中的使用" class="headerlink" title="43.谈谈多线程在Android中的使用"></a>43.谈谈多线程在Android中的使用</h3><p>Handler+Thread<br>AsyncTask<br>ThreadPoolExecutor<br>IntentService</p>
<h3 id="44-AsyncTask-如何使用"><a href="#44-AsyncTask-如何使用" class="headerlink" title="44.AsyncTask 如何使用?"></a>44.AsyncTask 如何使用?</h3><p>Android的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。<br>首先明确Android之所以有Handler和AsyncTask，都是为了不阻塞主线程（UI线程），且UI的更新只能在主线程中完成，因此异步处理是不可避免的。<br>Android为了降低这个开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，顾名思义就是异步任务。</p>
<p>AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法(至少重载一个)。</p>
<p>例：</p>
<p>public class Task extends AsyncTask//Void是三个泛型参数的原始状态,并且Void也是一个类而不是void</p>
<p>AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>
<p>Params 启动任务执行的输入参数，比如HTTP请求的URL。(可传入多个参数)<br>Progress 后台任务执行的百分比。<br>Result 后台执行任务最终返回的结果，比如String。<br>使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：</p>
<p>doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。<br>publicProgress(Progress…)会将Progress…传给onProgressUpdate(Progress…)作为ProgressUpdate(Progress…)的接收参数。<br>onPostExecute(Result) 相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回<br>有必要的话你还得重写以下这三个方法，但不是必须的：</p>
<p>onProgressUpdate(Progress…) 可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。<br>onPreExecute() 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。<br>onCancelled() 用户调用取消时，要做的操作<br>使用AsyncTask类，以下是几条必须遵守的准则：</p>
<p>Task的实例必须在UI thread(主线程)中创建；<br>execute方法必须在UI thread中调用；<br>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法；<br>该task只能被执行一次，否则多次调用时将会出现异常；</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Android数据库GreenDao使用解析</title>
    <url>/study/GreenDao%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img  src="../../images/webp.webp"  ><span class="image-caption">img</span></p>
<p>数据库GreenDao.jpg</p>
<p>之前在开发过程中，数据库基本上会使用Litepal或者SQlite自己写，最近换新环境，公司原先使用的数据库就是GreenDao，在各种情况的作用下，准备了解下GreenDao，顺便写一篇文章记录下GreenDao的基本使用！如果你是Android开发者，你在开发路上遇到任何问题，欢迎来我的公众号给我留言，咱们一起讨论，加入的Android开发讨论小组，一起进步！文章转载请注明出处。</p>
<blockquote>
<p>本文主要从如下几个方面进行讲解</p>
<ol>
<li>存储的数据库结构</li>
<li>GreenDao的优缺点</li>
<li>GreenDao的使用配置</li>
<li>使用GreenDao实现数据的增删改查</li>
<li>GreenDao的注解使用</li>
<li>GreenDao的关系处理</li>
<li>GreenDao的升级</li>
<li>GreenDao数据库加密</li>
<li>项目地址<a href="https://links.jianshu.com/go?to=https://github.com/aserbao/AserbaosAndroid">AserbaosAndroid</a></li>
<li>总结</li>
<li>参考博客</li>
<li>简书暂时不支持目录，<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/qq_32175491/article/details/82913904">如果想看该文章带目录版本，请点击跳转该文章的CSDN地址</a></li>
</ol>
</blockquote>
<p>咱们先看一波最终的效果图：文章最后有项目地址;</p>
<p><img  src="https://upload-images.jianshu.io/upload_images/3965704-380337dcf6303758.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/292/format/webp"  ><span class="image-caption">img</span></p>
<p>greendao</p>
<h1 id="1-存储的数据库结构"><a href="#1-存储的数据库结构" class="headerlink" title="1. 存储的数据库结构"></a>1. 存储的数据库结构</h1><p>学习数据库之前，我们先得设计自己的数据库，不多废话，下面是我此次学习的数据库结构，后面所有的数据请参考这个图进行学习：</p>
<p><img  src="https://upload-images.jianshu.io/upload_images/3965704-5a95ace87186a409.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1143/format/webp"  ><span class="image-caption">img</span></p>
<p>GreenDao关系图.jpg</p>
<h1 id="2-GreenDao的介绍"><a href="#2-GreenDao的介绍" class="headerlink" title="2. GreenDao的介绍"></a>2. GreenDao的介绍</h1><p>简单的GreenDao的介绍，嫌麻烦的可以直接跳到GreenDao使用开始看。</p>
<h2 id="什么是GreenDao？"><a href="#什么是GreenDao？" class="headerlink" title="什么是GreenDao？"></a>什么是GreenDao？</h2><p>GreenDAO是一个开源的Android ORM(“对象/关系映射”)，通过ORM（称为“对象/关系映射”），在我们数据库开发过程中节省了开发时间！</p>
<p><img  src="https://upload-images.jianshu.io/upload_images/3965704-b5a94b75c040f6d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp"  ><span class="image-caption">img</span></p>
<p>GreenDao的原理.png</p>
<h2 id="GreenDao的官方文档"><a href="#GreenDao的官方文档" class="headerlink" title="GreenDao的官方文档"></a>GreenDao的官方文档</h2><ol>
<li><a href="https://links.jianshu.com/go?to=http://greenrobot.org/greendao/">GreenDao：适用于您的SQLite数据库的Android ORM</a></li>
<li><a href="https://links.jianshu.com/go?to=https://github.com/greenrobot/greenDAO">GreenDao的github地址</a></li>
<li><a href="https://links.jianshu.com/go?to=https://groups.google.com/forum/%23!forum/greendao">GreenDao的Google讨论区</a></li>
<li><a href="https://links.jianshu.com/go?to=https://www.zetetic.net/sqlcipher/sqlcipher-for-android/">GreenDao 加密SQLCipher for Android官方说明地址</a></li>
<li><a href="https://links.jianshu.com/go?to=http://greenrobot.org/greendao/documentation/">GreenDao使用文档</a></li>
</ol>
<h2 id="GreenDao的作用？"><a href="#GreenDao的作用？" class="headerlink" title="GreenDao的作用？"></a>GreenDao的作用？</h2><p>通过GreenDao，我们可以更快速的操作数据库，我们可以使用简单的面相对象的API来存储，更新，删除和查询Java对象。</p>
<h2 id="GreenDao的优缺点？"><a href="#GreenDao的优缺点？" class="headerlink" title="GreenDao的优缺点？"></a>GreenDao的优缺点？</h2><ol>
<li><p>高性能，下面是官方给出的关于GreenDao，OrmLite和ActiveAndroid三种ORM解决方案的数据统计图：</p>
<p><img  src="https://upload-images.jianshu.io/upload_images/3965704-4b86f761a36ffb57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1022/format/webp"  ><span class="image-caption">img</span></p>
<p>GreenDao性能对比图.png</p>
</li>
<li><p>易于使用的强大API，涵盖关系和连接；</p>
</li>
<li><p>最小的内存消耗;</p>
</li>
<li><p>小库大小（&lt;100KB）以保持较低的构建时间并避免65k方法限制;</p>
</li>
<li><p>数据库加密：greenDAO支持SQLCipher，以确保用户的数据安全;</p>
</li>
</ol>
<h1 id="3-GreenDao的使用"><a href="#3-GreenDao的使用" class="headerlink" title="3. GreenDao的使用"></a>3. GreenDao的使用</h1><p>GreenDao的核心类有三个：分别是DaoMaster,DaoSession,XXXDao，这三个类都会自动创建，无需自己编写创建！</p>
<ul>
<li><p>DaoMaster:：DaoMaster保存数据库对象（SQLiteDatabase）并管理特定模式的DAO类（而不是对象）。它有静态方法来创建表或删除它们。它的内部类OpenHelper和DevOpenHelper是SQLiteOpenHelper实现，它们在SQLite数据库中创建模式。</p>
</li>
<li><p>DaoSession：管理特定模式的所有可用DAO对象，您可以使用其中一个getter方法获取该对象。DaoSession还提供了一些通用的持久性方法，如实体的插入，加载，更新，刷新和删除。</p>
</li>
<li><p>XXXDao：数据访问对象（DAO）持久存在并查询实体。对于每个实体，greenDAO生成DAO。它具有比DaoSession更多的持久性方法，例如：count，loadAll和insertInTx。</p>
</li>
<li><p>Entities ：可持久化对象。通常, 实体对象代表一个数据库行使用标准 Java 属性(如一个POJO 或 JavaBean )。</p>
</li>
<li><p><img  src="https://upload-images.jianshu.io/upload_images/3965704-b14ec30195c9eaa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/150/format/webp"  ><span class="image-caption">img</span></p>
<p>GreenDao核心.png</p>
</li>
</ul>
<h2 id="1-导入Gradle插件和Dao代码生成"><a href="#1-导入Gradle插件和Dao代码生成" class="headerlink" title="1. 导入Gradle插件和Dao代码生成"></a>1. 导入Gradle插件和Dao代码生成</h2><p>要在Android项目中使用GreenDao，您需要添加GreenDao Gradle插件并添加GreenDao库：</p>
<ol>
<li>导入插件</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 在 Project的build.gradle 文件中添加:</span><br>buildscript &#123;<br>    repositories &#123;<br>        jcenter()<br>        mavenCentral() <span class="hljs-comment">// add repository</span><br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:3.1.2&#x27;</span><br>        classpath <span class="hljs-string">&#x27;org.greenrobot:greendao-gradle-plugin:3.2.2&#x27;</span> <span class="hljs-comment">// add plugin</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>配置相关依赖</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 在 Moudle:app的  build.gradle 文件中添加:</span><br>apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;org.greenrobot.greendao&#x27;</span> <span class="hljs-comment">// apply plugin</span><br> <br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;org.greenrobot:greendao:3.2.2&#x27;</span> <span class="hljs-comment">// add library</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>配置数据库相关信息</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">greendao &#123;<br>    schemaVersion <span class="hljs-number">1</span> <span class="hljs-comment">//数据库版本号</span><br>    daoPackage <span class="hljs-string">&#x27;com.aserbao.aserbaosandroid.functions.database.greenDao.db&#x27;</span><br><span class="hljs-comment">// 设置DaoMaster、DaoSession、Dao 包名</span><br>    targetGenDir <span class="hljs-string">&#x27;src/main/java&#x27;</span><span class="hljs-comment">//设置DaoMaster、DaoSession、Dao目录,请注意，这里路径用/不要用.</span><br>    generateTests <span class="hljs-literal">false</span> <span class="hljs-comment">//设置为true以自动生成单元测试。</span><br>    targetGenDirTests <span class="hljs-string">&#x27;src/main/java&#x27;</span> <span class="hljs-comment">//应存储生成的单元测试的基本目录。默认为 src / androidTest / java。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置完成，在Android Studio中使用Build&gt; Make Project，重写build项目，GreenDao集成完成！</p>
<h2 id="2-创建存储对象实体类"><a href="#2-创建存储对象实体类" class="headerlink" title="2. 创建存储对象实体类"></a>2. 创建存储对象实体类</h2><p>使用GreenDao存储数据只需要在存储数据类前面声明@Entity注解就让GreenDao为其生成必要的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span>(autoincrement = <span class="hljs-keyword">true</span>)<br>    Long id;<br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">int</span> studentNo;<span class="hljs-comment">//学号</span><br>    <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">String</span> telPhone;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-built_in">String</span> sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-built_in">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">String</span> address;<span class="hljs-comment">//家庭住址</span><br>    <span class="hljs-built_in">String</span> schoolName;<span class="hljs-comment">//学校名字</span><br>    <span class="hljs-built_in">String</span> grade;<span class="hljs-comment">//几年级</span><br>    ……getter and setter and constructor method……<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-GreenDao初始化"><a href="#3-GreenDao初始化" class="headerlink" title="3. GreenDao初始化"></a>3. GreenDao初始化</h2><p>我们可以在Application中维持一个全局的会话。我们在Applicaiton进行数据库的初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 初始化GreenDao,直接在Application中进行初始化操作</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initGreenDao</span><span class="hljs-params">()</span> </span>&#123;<br>       DaoMaster.DevOpenHelper helper = <span class="hljs-keyword">new</span> DaoMaster.<span class="hljs-built_in">DevOpenHelper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;aserbao.db&quot;</span>);<br>       SQLiteDatabase db = helper.<span class="hljs-built_in">getWritableDatabase</span>();<br>       DaoMaster daoMaster = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DaoMaster</span>(db);<br>       daoSession = daoMaster.<span class="hljs-built_in">newSession</span>();<br>   &#125;<br>   <br>   <span class="hljs-keyword">private</span> DaoSession daoSession;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> DaoSession <span class="hljs-title">getDaoSession</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> daoSession;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>初始化完成之后重新rebuild一下项目会发现在设置的targetGenDir的目录生成三个类文件，这个是GreenDao自动生成的！说明数据库已经连接好了，咱们接下来只需要进行数据库的增删改查操作就行了。Let’s Go!</p>
<h2 id="4-使用GreenDao实现增删改查"><a href="#4-使用GreenDao实现增删改查" class="headerlink" title="4. 使用GreenDao实现增删改查"></a>4. 使用GreenDao实现增删改查</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1. 增"></a>1. 增</h3><p><strong>insert()</strong> 插入数据</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Override</span><br>   public <span class="hljs-keyword">void</span> insertData(Thing s) &#123;<br>    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>              Student student = <span class="hljs-keyword">new</span> Student();<br>                       student.setStudentNo(i);<br>                       <span class="hljs-built_in">int</span> age = mRandom.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">10</span>;<br>                       student.setAge(age);<br>                       student.setTelPhone(RandomValue.getTel());<br>                       <span class="hljs-built_in">String</span> chineseName = RandomValue.getChineseName();<br>                       student.setName(chineseName);<br>                       <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                           student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>                       &#125; <span class="hljs-keyword">else</span> &#123;<br>                           student.setSex(<span class="hljs-string">&quot;女&quot;</span>);<br>                       &#125;<br>                       student.setAddress(RandomValue.getRoad());<br>                       student.setGrade(<span class="hljs-built_in">String</span>.valueOf(age % <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;年纪&quot;</span>);<br>                       student.setSchoolName(RandomValue.getSchoolName());<br>                       daoSession.insert(student);<br>           &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>**insertOrReplace()**数据存在则替换，数据不存在则插入</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Override</span><br>    public <span class="hljs-keyword">void</span> insertData(Thing s) &#123;<br>    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                 Student student = <span class="hljs-keyword">new</span> Student();<br>                        student.setStudentNo(i);<br>                        <span class="hljs-built_in">int</span> age = mRandom.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">10</span>;<br>                        student.setAge(age);<br>                        student.setTelPhone(RandomValue.getTel());<br>                        <span class="hljs-built_in">String</span> chineseName = RandomValue.getChineseName();<br>                        student.setName(chineseName);<br>                        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                            student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            student.setSex(<span class="hljs-string">&quot;女&quot;</span>);<br>                        &#125;<br>                        student.setAddress(RandomValue.getRoad());<br>                        student.setGrade(<span class="hljs-built_in">String</span>.valueOf(age % <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;年纪&quot;</span>);<br>                        student.setSchoolName(RandomValue.getSchoolName());<br>                        daoSession.insertOrReplace(student);<span class="hljs-comment">//插入或替换</span><br>            &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-删"><a href="#2-删" class="headerlink" title="2. 删"></a>2. 删</h3><p>删除有两种方式：delete()和deleteAll()；分别表示删除单个和删除所有。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">@<span class="hljs-function">Override</span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteData</span><span class="hljs-params">(Student s)</span> </span>&#123;<br>       DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>       daoSession.<span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>(s);<br>   &#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span> </span>&#123;<br>       DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>       daoSession.deleteAll(Student.class);<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-改"><a href="#3-改" class="headerlink" title="3. 改"></a>3. 改</h3><p>通过update来进行修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updataData</span><span class="hljs-params">(Student s)</span> </span>&#123;<br>        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>        daoSession.update(s);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-查"><a href="#4-查" class="headerlink" title="4. 查"></a>4. 查</h3><p>查询的方法有：</p>
<ul>
<li>loadAll()：查询所有数据。</li>
<li>queryRaw()：根据条件查询。</li>
<li>queryBuilder() : 方便查询的创建，后面详细讲解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryAll</span><span class="hljs-params">()</span></span>&#123;<br>       List&lt;Student&gt; students = daoSession.loadAll(Student.class);<br>       <span class="hljs-keyword">return</span> students;<br>   &#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> void queryData(String s) &#123;<br>     List&lt;Student&gt; students = daoSession.queryRaw(Student.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot; where id = ?&quot;</span>, s);<br>      mDataBaseAdapter.addNewStudentData(students);<br>  &#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-QueryBuilder的使用"><a href="#4-QueryBuilder的使用" class="headerlink" title="4. QueryBuilder的使用"></a>4. QueryBuilder的使用</h1><p>编写SQL可能很困难并且容易出现错误，这些错误仅在运行时才会被注意到。该QueryBuilder的类可以让你建立你的实体，而不SQL自定义查询，并有助于在编译时已检测错误。</p>
<p>我们先讲下QueryBuilder的常见方法：</p>
<ul>
<li>where(WhereCondition cond, WhereCondition… condMore): 查询条件，参数为查询的条件！</li>
<li>or(WhereCondition cond1, WhereCondition cond2, WhereCondition… condMore): 嵌套条件或者，用法同or。</li>
<li>and(WhereCondition cond1, WhereCondition cond2, WhereCondition… condMore): 嵌套条件且，用法同and。</li>
<li>join(Property sourceProperty, Class<J> destinationEntityClass):多表查询，后面会讲。<br> 输出结果有四种方式，选择其中一种最适合的即可，list()返回值是List,而其他三种返回值均实现Closeable,需要注意的不使用数据时游标的关闭操作：</li>
<li>list （）所有实体都加载到内存中。结果通常是一个没有魔法的 ArrayList。最容易使用。</li>
<li>listLazy （）实体按需加载到内存中。首次访问列表中的元素后，将加载并缓存该元素以供将来使用。必须关闭。</li>
<li>listLazyUncached （）实体的“虚拟”列表：对列表元素的任何访问都会导致从数据库加载其数据。必须关闭。</li>
<li>listIterator （）让我们通过按需加载数据（懒惰）来迭代结果。数据未缓存。必须关闭。</li>
<li>orderAsc() 按某个属性升序排；</li>
<li>orderDesc() 按某个属性降序排；</li>
</ul>
<p>GreenDao中SQL语句的缩写，我们也了解下，源码在Property中,使用的时候可以自己点进去查询即可：</p>
<ul>
<li>eq()：”equal (‘=?’)” 等于；</li>
<li>notEq() ：”not equal (‘&lt;&gt;?’)” 不等于；</li>
<li>like()：” LIKE ?” 值等于；</li>
<li>between()：” BETWEEN ? AND ?” 取中间范围；</li>
<li>in()：” IN (“  in命令;</li>
<li>notIn()：” NOT IN (“ not in 命令;</li>
<li>gt()：”&gt;?”  大于;</li>
<li>lt()：”&lt;? “  小于;</li>
<li>ge()：”&gt;=?”  大于等于;</li>
<li>le()：”&lt;=? “  小于等于;</li>
<li>isNull()：” IS NULL” 为空;</li>
<li>isNotNull()：” IS NOT NULL” 不为空;</li>
</ul>
<h2 id="1-使用QueryBuilder进行查询操作"><a href="#1-使用QueryBuilder进行查询操作" class="headerlink" title="1. 使用QueryBuilder进行查询操作"></a>1. 使用QueryBuilder进行查询操作</h2><h3 id="1-简单条件查询"><a href="#1-简单条件查询" class="headerlink" title="1. 简单条件查询"></a>1. 简单条件查询</h3><p>查询当前Student表的所有的数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryAllList</span><span class="hljs-params">()</span></span>&#123;<br>      DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>      QueryBuilder&lt;Student&gt; qb = daoSession.<span class="hljs-built_in">queryBuilder</span>(Student.class);<br>      List&lt;Student&gt; list = qb.<span class="hljs-built_in">list</span>(); <span class="hljs-comment">// 查出所有的数据</span><br>  <span class="hljs-keyword">return</span> list;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>查询Name为“一”的所有Student:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> List queryListByMessage(String name)&#123;<br>        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>       QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.<span class="hljs-keyword">class</span>);<br>       QueryBuilder&lt;Student&gt; studentQueryBuilder = qb.<span class="hljs-keyword">where</span>(StudentDao.Properties.Name.eq(<span class="hljs-string">&quot;一&quot;</span>)).orderAsc(StudentDao.Properties.Name);<br>       List&lt;Student&gt; studentList = studentQueryBuilder.list(); <span class="hljs-comment">//查出当前对应的数据</span><br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-原始查询"><a href="#2-原始查询" class="headerlink" title="2. 原始查询"></a>2. 原始查询</h3><p>通过原始的SQL查询语句进行查询！其实上面有提到QueryBuilder的目的就是方便快捷的编写SQL查询语句，避免我们自己在编写过程中出错！简单介绍下通过QueryBuilder编写数据库，方式方法如下 ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryListBySqL</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 查询ID大于5的所有学生</span><br>        DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>        Query&lt;Student&gt; query = daoSession.<span class="hljs-built_in">queryBuilder</span>(Student.class).<span class="hljs-built_in">where</span>(<br>                <span class="hljs-keyword">new</span> WhereCondition.<span class="hljs-built_in">StringCondition</span>(<span class="hljs-string">&quot;_ID IN &quot;</span> +<br>                        <span class="hljs-string">&quot;(SELECT _ID FROM STUDENT WHERE _ID &gt; 5)&quot;</span>)<br>        ).<span class="hljs-built_in">build</span>();<br>        List&lt;Student&gt; list = query.<span class="hljs-built_in">list</span>();<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-嵌套条件查询"><a href="#3-嵌套条件查询" class="headerlink" title="3. 嵌套条件查询"></a>3. 嵌套条件查询</h3><p>查询Id大于5小于10，且Name值为”一”的数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> List queryList()&#123;<br>        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>        QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.<span class="hljs-keyword">class</span>);<br>        qb = daoSession.queryBuilder(Student.<span class="hljs-keyword">class</span>);<br>        List&lt;Student&gt; list2 = qb.<span class="hljs-keyword">where</span>(StudentDao.Properties.Name.eq(<span class="hljs-string">&quot;一&quot;</span>),<br>                qb.and(StudentDao.Properties.Id.gt(<span class="hljs-number">5</span>),<br>                        StudentDao.Properties.Id.le(<span class="hljs-number">50</span>))).list();<br>        <span class="hljs-keyword">return</span>  list2;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>取10条Id大于1的数据，且偏移2条</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryListByOther</span><span class="hljs-params">()</span></span>&#123;<br>       DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>       QueryBuilder&lt;Student&gt; qb = daoSession.<span class="hljs-built_in">queryBuilder</span>(Student.class);<br><br>       <span class="hljs-comment">//搜索条件为Id值大于1，即结果为[2,3,4,5,6,7,8,9,10,11];</span><br>       <span class="hljs-comment">// offset(2)表示往后偏移2个，结果为[4,5,6,7,8,9,10,11,12,13];</span><br>       List&lt;Student&gt; list = qb.<span class="hljs-built_in">where</span>(StudentDao.Properties.Id.<span class="hljs-built_in">gt</span>(<span class="hljs-number">1</span>)).<span class="hljs-built_in">limit</span>(<span class="hljs-number">10</span>).<span class="hljs-built_in">offset</span>(<span class="hljs-number">2</span>).<span class="hljs-built_in">list</span>();<br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-多次执行查找"><a href="#4-多次执行查找" class="headerlink" title="4. 多次执行查找"></a>4. 多次执行查找</h3><p>使用QueryBuilder构建查询后，可以重用 Query对象以便稍后执行查询。这比始终创建新的Query对象更有效。如果查询参数没有更改，您可以再次调用list / unique方法。可以通过setParameter方法来修改条件参数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">queryListByMoreTime</span><span class="hljs-params">()</span></span>&#123;<br>       DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>       QueryBuilder&lt;Student&gt; qb = daoSession.<span class="hljs-built_in">queryBuilder</span>(Student.class);<br><br>       <span class="hljs-comment">//搜索条件为Id值大于1，即结果为[2,3,4,5,6,7,8,9,10,11];</span><br>       <span class="hljs-comment">// offset(2)表示往后偏移2个，结果为[4,5,6,7,8,9,10,11,12,13];</span><br>       Query&lt;Student&gt; query = qb.<span class="hljs-built_in">where</span>(StudentDao.Properties.Id.<span class="hljs-built_in">gt</span>(<span class="hljs-number">1</span>)).<span class="hljs-built_in">limit</span>(<span class="hljs-number">10</span>).<span class="hljs-built_in">offset</span>(<span class="hljs-number">2</span>).<span class="hljs-built_in">build</span>();<br>       List&lt;Student&gt; list = query.<span class="hljs-built_in">list</span>();<br>       <br>       <span class="hljs-comment">//通过SetParameter来修改上面的查询条件，比如我们将上面条件修改取10条Id值大于5，往后偏移两位的数据，方法如下！</span><br>       query.<span class="hljs-built_in">setParameter</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>       List&lt;Student&gt; list1 = query.<span class="hljs-built_in">list</span>();<br>       <span class="hljs-keyword">return</span> list1;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-在多个线程中使用QueryBuilder"><a href="#5-在多个线程中使用QueryBuilder" class="headerlink" title="5. 在多个线程中使用QueryBuilder"></a>5. 在多个线程中使用QueryBuilder</h3><p>如果在多个线程中使用查询，则必须调用 forCurrentThread （）以获取当前线程的Query实例。Query的对象实例绑定到构建查询的拥有线程。</p>
<p>这使您可以安全地在Query对象上设置参数，而其他线程不会干扰。如果其他线程尝试在查询上设置参数或执行绑定到另一个线程的查询，则会抛出异常。像这样，您不需要同步语句。实际上，您应该避免锁定，因为如果并发事务使用相同的Query对象，这可能会导致死锁。</p>
<p>每次调用forCurrentThread （）时， 参数都会在使用其构建器构建查询时设置为初始参数。</p>
<h2 id="2-使用QueryBuilder进行批量删除操作"><a href="#2-使用QueryBuilder进行批量删除操作" class="headerlink" title="2. 使用QueryBuilder进行批量删除操作"></a>2. 使用QueryBuilder进行批量删除操作</h2><p>使用QueryBuilder进行批量删除操作，不会删除单个实体，但会删除符合某些条件的所有实体。要执行批量删除，请创建QueryBuilder，调用其 buildDelete （）方法，然后执行返回的 DeleteQuery。</p>
<p>例子：删除数据库中id大于5的所有其他数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> boolean deleteItem()&#123;<br>        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>        QueryBuilder&lt;Student&gt; <span class="hljs-keyword">where</span> = daoSession.queryBuilder(Student.<span class="hljs-keyword">class</span>).<span class="hljs-keyword">where</span>(StudentDao.Properties.Id.gt(<span class="hljs-number">5</span>));<br>        DeleteQuery&lt;Student&gt; deleteQuery = <span class="hljs-keyword">where</span>.buildDelete();<br>        deleteQuery.executeDeleteWithoutDetachingEntities();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="5-注解讲解"><a href="#5-注解讲解" class="headerlink" title="5. 注解讲解"></a>5. 注解讲解</h1><p>从GreenDao 3 使用注解来定义模型和实体，前面也讲过，通过注解的使用可以快速构建数据库表，包括设置主键，自增，值是否唯一等等等……</p>
<p>下面我们来看下注解的简单使用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span>(autoincrement = <span class="hljs-keyword">true</span>)<br>    Long id;<br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">int</span> studentNo;<span class="hljs-comment">//学号</span><br>    <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">String</span> telPhone;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-built_in">String</span> sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-built_in">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">String</span> address;<span class="hljs-comment">//家庭住址</span><br>    <span class="hljs-built_in">String</span> schoolName;<span class="hljs-comment">//学校名字</span><br>    <span class="hljs-built_in">String</span> grade;<span class="hljs-comment">//几年级</span><br>    ……getter and setter and constructor method……<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-Entity注解"><a href="#1-Entity注解" class="headerlink" title="1. @Entity注解"></a>1. @Entity注解</h2><p>@Entity是GreenDao必不可少的注解，只有在实体类中使用了@Entity注解GreenDao才会创建对应的表。当然我们也可以使用@Entity配置一些细节：</p>
<ul>
<li>schema：如果你有多个架构，你可以告诉GreenDao当前属于哪个架构。</li>
<li>active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法。</li>
<li>nameInDb：在数据中使用的别名，默认使用的是实体的类名。</li>
<li>indexes：标记如果DAO应该创建数据库表(默认为true)，如果您有多个实体映射到一个表，或者表的创建是在greenDAO之外进行的，那么将其设置为false。</li>
<li>createInDb：标记创建数据库表。</li>
<li>generateGettersSetters：如果缺少，是否应生成属性的getter和setter方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">        schema = &quot;myschema&quot;,</span><br><span class="hljs-meta">        active = true,</span><br><span class="hljs-meta">        nameInDb = &quot;AWESOME_USERS&quot;,</span><br><span class="hljs-meta">        indexes = &#123;</span><br><span class="hljs-meta">                @Index(value = &quot;message DESC&quot;, unique = true)</span><br><span class="hljs-meta">        &#125;,</span><br><span class="hljs-meta">        createInDb = false,</span><br><span class="hljs-meta">        generateConstructors = true,</span><br><span class="hljs-meta">        generateGettersSetters = true</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;   <br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-基础属性注解（-Id，-Property，-NotNull，-Transient）"><a href="#2-基础属性注解（-Id，-Property，-NotNull，-Transient）" class="headerlink" title="2.  基础属性注解（@Id，@Property，@NotNull，@Transient）"></a>2.  基础属性注解（@Id，@Property，@NotNull，@Transient）</h2><p><strong>@Id</strong><br> @Id注解选择 long / Long属性作为实体ID。在数据库方面，它是主键。参数autoincrement = true 表示自增，id不给赋值或者为赋值为null即可（这里需要注意，如果要实现自增，id必须是Long,为long不行！)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id(autoincrement = true)</span><br>    <span class="hljs-built_in">Long</span> id;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@Property</strong><br> 允许您定义属性映射到的非默认列名。如果不存在，GreenDAO将以SQL-ish方式使用字段名称（大写，下划线而不是camel情况，例如 name将成为 NAME）。注意：您当前只能使用内联常量来指定列名。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@Entity</span><br>public class Student &#123;<br>    <span class="hljs-keyword">@Id</span>(autoincrement = true)<br>    Long id;<br>    <span class="hljs-keyword">@Property</span> (nameInDb=<span class="hljs-string">&quot;name&quot;</span>) //设置了，数据库中的表格属性名为<span class="hljs-string">&quot;name&quot;</span>,如果不设置，数据库中表格属性名为<span class="hljs-string">&quot;NAME&quot;</span><br>    String name;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@NotNull</strong> ：设置数据库表当前列不能为空 。</p>
<p><strong>@Transient</strong> ：添加次标记之后不会生成数据库表的列。标记要从持久性中排除的属性。将它们用于临时状态等。或者，您也可以使用Java中的transient关键字。</p>
<h2 id="3-索引注解"><a href="#3-索引注解" class="headerlink" title="3. 索引注解"></a>3. 索引注解</h2><ul>
<li>@Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束。</li>
<li>@Unique：向索引添加UNIQUE约束，强制所有值都是唯一的。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id(autoincrement = true)</span><br>    <span class="hljs-built_in">Long</span> id;<br>    <span class="hljs-meta">@Property(nameInDb=<span class="hljs-meta-string">&quot;name&quot;</span>)</span><br>    <span class="hljs-meta">@Index(unique = true)</span><br>     String name;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上面这种情况，约定name为唯一值，向数据库中通过insert方法继续添加已存在的name数据，会抛异常：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-number">10</span>-<span class="hljs-number">08</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">46.274</span> <span class="hljs-number">31939</span>-<span class="hljs-number">31939</span>/com.example.aserbao.aserbaosandroid E/AndroidRuntime: FATAL <span class="hljs-built_in">EXCEPTION</span>: main<br>    Process: com.example.aserbao.aserbaosandroid, PID: <span class="hljs-number">31939</span><br>    android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: STUDENT.name (Sqlite code <span class="hljs-number">2067</span>), (OS <span class="hljs-built_in">error</span> - <span class="hljs-number">2</span>:No such file <span class="hljs-keyword">or</span> <span class="hljs-built_in">directory</span>)<br>    ……<br></code></pre></td></tr></table></figure>

<p>若使用insertOrReplace()方法添加数据，当前数据库中不会有重复的数据，但是重复的这条数据的id会被修改！若项目中有用到id字段进行排序的话，这一点需要特别注意。</p>
<h2 id="4-关系注解"><a href="#4-关系注解" class="headerlink" title="4. 关系注解"></a>4. 关系注解</h2><p>关系型注解GreenDao中主要就两个：</p>
<ul>
<li>@ToOne：定义与另一个实体（一个实体对象）的关系</li>
<li>@ToMany：定义与多个实体对象的关系<br> 至于如何使用，我们马上就讲。</li>
</ul>
<h1 id="6-一对一，一对多，多对多关系表的创建"><a href="#6-一对一，一对多，多对多关系表的创建" class="headerlink" title="6. 一对一，一对多，多对多关系表的创建"></a>6. 一对一，一对多，多对多关系表的创建</h1><p>平常项目中，我们经常会使用到多表关联，如文章开头所说的数据库表结构设置的那样！接下来我们来讲如何通过GreenDao实现多表关联。</p>
<h2 id="1-一对一"><a href="#1-一对一" class="headerlink" title="1. 一对一"></a>1. 一对一</h2><p>一个学生对应一个身份证号:<br> 做法：</p>
<ol>
<li>我们在Student中设置一个注解@ToOne(joinProperty = “name”)</li>
<li>在创建Student的时候，将对应的数据传递给IdCard;<br> 代码部分：</li>
</ol>
<p>学生Student代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span>(autoincrement = <span class="hljs-keyword">true</span>)<br>    Long id;<br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">int</span> studentNo;<span class="hljs-comment">//学号</span><br>    <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">String</span> telPhone;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-built_in">String</span> sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-built_in">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">String</span> address;<span class="hljs-comment">//家庭住址</span><br>    <span class="hljs-built_in">String</span> schoolName;<span class="hljs-comment">//学校名字</span><br>    <span class="hljs-built_in">String</span> grade;<span class="hljs-comment">//几年级</span><br>    <span class="hljs-meta">@ToOne</span>(joinProperty = <span class="hljs-string">&quot;name&quot;</span>)<br>    IdCard student;<br>    ……getter and setter ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p>身份证IdCard代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdCard</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span> <br>    <span class="hljs-built_in">String</span> userName;<span class="hljs-comment">//用户名</span><br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">String</span> idNo;<span class="hljs-comment">//身份证号</span><br>       ……getter and setter ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p>insert一组数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">()</span></span>&#123;<br>                        DaoSession daoSession = ((AserbaoApplication) <span class="hljs-built_in">getApplication</span>()).<span class="hljs-built_in">getDaoSession</span>();<br>                        Student student = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>();<br>                        student.<span class="hljs-built_in">setStudentNo</span>(i);<br>                        <span class="hljs-keyword">int</span> age = mRandom.<span class="hljs-built_in">nextInt</span>(<span class="hljs-number">10</span>) + <span class="hljs-number">10</span>;<br>                        student.<span class="hljs-built_in">setAge</span>(age);<br>                        student.<span class="hljs-built_in">setTelPhone</span>(RandomValue.<span class="hljs-built_in">getTel</span>());<br>                        String chineseName = RandomValue.<span class="hljs-built_in">getChineseName</span>();<br>                        student.<span class="hljs-built_in">setName</span>(chineseName);<br>                        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                            student.<span class="hljs-built_in">setSex</span>(<span class="hljs-string">&quot;男&quot;</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            student.<span class="hljs-built_in">setSex</span>(<span class="hljs-string">&quot;女&quot;</span>);<br>                        &#125;<br>                        student.<span class="hljs-built_in">setAddress</span>(RandomValue.<span class="hljs-built_in">getRoad</span>());<br>                        student.<span class="hljs-built_in">setGrade</span>(String.<span class="hljs-built_in">valueOf</span>(age % <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;年纪&quot;</span>);<br>                        student.<span class="hljs-built_in">setSchoolName</span>(RandomValue.<span class="hljs-built_in">getSchoolName</span>());<br>                        daoSession.<span class="hljs-built_in">insert</span>(student);<br>                        <br>                        <span class="hljs-comment">//插入对应的IdCard数据</span><br>                        IdCard idCard = <span class="hljs-keyword">new</span> <span class="hljs-built_in">IdCard</span>();<br>                        idCard.<span class="hljs-built_in">setUserName</span>(userName);<br>                        idCard.<span class="hljs-built_in">setIdNo</span>(RandomValue.<span class="hljs-built_in">getRandomID</span>());<br>                        daoSession.<span class="hljs-built_in">insert</span>(idCard);<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>ok,数据可以了！现在数据库表插入完成了。</p>
<h2 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2. 一对多"></a>2. 一对多</h2><p>一个人拥有多个信用卡<br> 做法：</p>
<ol>
<li>在我们在Student中设置@ToMany(referencedJoinProperty = “studentId”);</li>
<li>我们在CreditCard中设置编写对应的id主键；</li>
</ol>
<p>Student的代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-variable">@Id</span>(autoincrement = <span class="hljs-literal">true</span>)<br>    Long id;<br><br>    <span class="hljs-variable">@Unique</span><br>    int studentNo;<span class="hljs-regexp">//</span>学号<br><br>    int age; <span class="hljs-regexp">//</span>年龄<br>    String telPhone;<span class="hljs-regexp">//</span>手机号<br>    String sex; <span class="hljs-regexp">//</span>性别<br>    String name;<span class="hljs-regexp">//</span>姓名<br>    String address;<span class="hljs-regexp">//</span>家庭住址<br>    String schoolName;<span class="hljs-regexp">//</span>学校名字<br>    String grade;<span class="hljs-regexp">//</span>几年级<br>    <br>    <span class="hljs-variable">@ToMany</span>(referencedJoinProperty = <span class="hljs-string">&quot;studentId) // 这个studentId是对应在CreditCard中的studentId</span><br><span class="hljs-string">    List&lt;CreditCard&gt; creditCardsList;</span><br><span class="hljs-string">      ……getter and setter ……</span><br><span class="hljs-string">    &#125;</span><br></code></pre></td></tr></table></figure>

<p>CreditCard的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreditCard</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    Long id;<br>    Long studentId;<br>    Long teacherId;<br>    <span class="hljs-built_in">String</span> userName;<span class="hljs-comment">//持有者名字</span><br>    <span class="hljs-built_in">String</span> cardNum;<span class="hljs-comment">//卡号</span><br>    <span class="hljs-built_in">String</span> whichBank;<span class="hljs-comment">//哪个银行的</span><br>    <span class="hljs-built_in">int</span> cardType;<span class="hljs-comment">//卡等级，分类 0 ~ 5</span><br>     ……getter and setter ……<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>添加数据代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">public <span class="hljs-keyword">void</span> addStudent()&#123;<br>                        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();<br>                        Student student = <span class="hljs-keyword">new</span> Student();<br>                        student.setStudentNo(i);<br>                        <span class="hljs-built_in">int</span> age = mRandom.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">10</span>;<br>                        student.setAge(age);<br>                        student.setTelPhone(RandomValue.getTel());<br>                        <span class="hljs-built_in">String</span> chineseName = RandomValue.getChineseName();<br>                        student.setName(chineseName);<br>                        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                            student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            student.setSex(<span class="hljs-string">&quot;女&quot;</span>);<br>                        &#125;<br>                        student.setAddress(RandomValue.getRoad());<br>                        student.setGrade(<span class="hljs-built_in">String</span>.valueOf(age % <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;年纪&quot;</span>);<br>                        student.setSchoolName(RandomValue.getSchoolName());<br>                        daoSession.insert(student);<br>                        <br>                        <span class="hljs-comment">//插入对应的CreditCard数据</span><br>                       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span> ; j++) &#123;<br>                        CreditCard creditCard = <span class="hljs-keyword">new</span> CreditCard();<br>                        creditCard.setUserId(id);<br>                        creditCard.setUserName(userName);<br>                        creditCard.setCardNum(<span class="hljs-built_in">String</span>.valueOf(random.nextInt(<span class="hljs-number">899999999</span>) + <span class="hljs-number">100000000</span>) + <span class="hljs-built_in">String</span>.valueOf(random.nextInt(<span class="hljs-number">899999999</span>) + <span class="hljs-number">100000000</span>));<br>                        creditCard.setWhichBank(RandomValue.getBankName());<br>                        creditCard.setCardType(random.nextInt(<span class="hljs-number">10</span>));<br>                        daoSession.insert(creditCard);<br>                    &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-多对多"><a href="#3-多对多" class="headerlink" title="3. 多对多"></a>3. 多对多</h2><p>一个学生有多个老师，老师有多个学生。<br> 做法：</p>
<ol>
<li><p>我们需要创建一个学生老师管理器(StudentAndTeacherBean)，用来对应学生和老师的ID;</p>
</li>
<li><p>我们需要在学生对象中，添加注解：</p>
<p>@ToMany<br> @JoinEntity(entity = StudentAndTeacherBean.class,sourceProperty = “studentId”,targetProperty = “teacherId”)<br> List<Teacher> teacherList;</p>
</li>
<li><p>我们需要在老师对象中，添加注解：@ToMany</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@JoinEntity</span>(entity = StudentAndTeacherBean.class,sourceProperty = <span class="hljs-string">&quot;teacherId&quot;</span>,targetProperty = <span class="hljs-string">&quot;studentId&quot;</span>)<br>  List&lt;Student&gt; studentList;<br></code></pre></td></tr></table></figure>

<p>StudentAndTeacherBean代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentAndTeacherBean</span> </span>&#123;<br>    <span class="hljs-meta">@Id(autoincrement = true)</span><br>    <span class="hljs-built_in">Long</span> id;<br>    <span class="hljs-built_in">Long</span> studentId;<span class="hljs-comment">//学生ID</span><br>    <span class="hljs-built_in">Long</span> teacherId;<span class="hljs-comment">//老师ID</span><br>    ……getter and setter ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Student 代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span>(autoincrement = <span class="hljs-keyword">true</span>)<br>    Long id;<br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">int</span> studentNo;<span class="hljs-comment">//学号</span><br>    <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">String</span> telPhone;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-built_in">String</span> sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-built_in">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">String</span> address;<span class="hljs-comment">//家庭住址</span><br>    <span class="hljs-built_in">String</span> schoolName;<span class="hljs-comment">//学校名字</span><br>    <span class="hljs-built_in">String</span> grade;<span class="hljs-comment">//几年级</span><br>    <span class="hljs-meta">@ToMany</span><br>    <span class="hljs-meta">@JoinEntity</span>(entity = StudentAndTeacherBean.<span class="hljs-keyword">class</span>,sourceProperty = <span class="hljs-string">&quot;studentId&quot;</span>,targetProperty = <span class="hljs-string">&quot;teacherId&quot;</span>)<br>    <span class="hljs-built_in">List</span>&lt;Teacher&gt; teacherList;<br>        ……getter and setter ……<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Teacher代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span>(autoincrement = <span class="hljs-keyword">true</span>)<br>    Long id;<br>    <span class="hljs-meta">@Unique</span><br>    <span class="hljs-built_in">int</span> teacherNo;<span class="hljs-comment">//职工号</span><br>    <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">String</span> sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-built_in">String</span> telPhone;<br>    <span class="hljs-built_in">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">String</span> schoolName;<span class="hljs-comment">//学校名字</span><br>    <span class="hljs-built_in">String</span> subject;<span class="hljs-comment">//科目</span><br><br>    <span class="hljs-meta">@ToMany</span><br>    <span class="hljs-meta">@JoinEntity</span>(entity = StudentAndTeacherBean.<span class="hljs-keyword">class</span>,sourceProperty = <span class="hljs-string">&quot;teacherId&quot;</span>,targetProperty = <span class="hljs-string">&quot;studentId&quot;</span>)<br>    <span class="hljs-built_in">List</span>&lt;Student&gt; studentList;<br>  ……getter and setter ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p>数据添加：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addData</span>(<span class="hljs-params"></span>)</span>&#123;<br>                       Student student = <span class="hljs-keyword">new</span> Student();<br>                        student.setStudentNo(i);<br>                        <span class="hljs-built_in">int</span> age = mRandom.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">10</span>;<br>                        student.setAge(age);<br>                        student.setTelPhone(RandomValue.getTel());<br>                        String chineseName = RandomValue.getChineseName();<br>                        student.setName(chineseName);<br>                        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                            student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            student.setSex(<span class="hljs-string">&quot;女&quot;</span>);<br>                        &#125;<br>                        student.setAddress(RandomValue.getRoad());<br>                        student.setGrade(String.valueOf(age % <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;年纪&quot;</span>);<br>                        student.setSchoolName(RandomValue.getSchoolName());<br>                        daoSession.insert(student);<br><br>                        Collections.shuffle(teacherList);<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; mRandom.nextInt(<span class="hljs-number">8</span>) + <span class="hljs-number">1</span>; j++) &#123;<br>                            <span class="hljs-keyword">if</span>(j &lt; teacherList.size())&#123;<br>                                Teacher teacher = teacherList.<span class="hljs-keyword">get</span>(j);<br>                                StudentAndTeacherBean teacherBean = <span class="hljs-keyword">new</span> StudentAndTeacherBean(student.getId(), teacher.getId());<br>                                daoSession.insert(teacherBean);<br>                            &#125;<br>                        &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure>

<p>好了，成功;</p>
<h1 id="7-数据库的升级"><a href="#7-数据库的升级" class="headerlink" title="7.  数据库的升级"></a>7.  数据库的升级</h1><p>GreenDao的OpenHelper下有个 onUpgrade(Database db, int oldVersion, int newVersion)方法，当设置的数据库版本改变时，在数据库初始化的时候就会回调到这个方法，我们可以通过继承OpenHelper重写onUpgrade方法来实现数据库更新操作：</p>
<p>GreenDao的升级思路：</p>
<ol>
<li>创建临时表TMP_,复制原来的数据库到临时表中；</li>
<li>删除之前的原表；</li>
<li>创建新表；</li>
<li>将临时表中的数据复制到新表中，最后将TMP_表删除掉；</li>
</ol>
<p>ok,思路就是这样， 总共两个类： 一个MyDaoMaster(OpenHelper继承类)，一个MigrationHelper(数据库操作类) 下面是代码编写：</p>
<p>修改Application中的DaoMaster的创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">        MyDaoMaster helper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyDaoMaster</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;aserbaos.db&quot;</span>);<br><span class="hljs-comment">//      DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;aserbao.db&quot;);</span><br>        SQLiteDatabase db = helper.<span class="hljs-built_in">getWritableDatabase</span>();<br>        DaoMaster daoMaster = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DaoMaster</span>(db);<br>        daoSession = daoMaster.<span class="hljs-built_in">newSession</span>();<br></code></pre></td></tr></table></figure>

<p>MyDaoMaster代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDaoMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OpenHelper</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;MyDaoMaster&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDaoMaster</span><span class="hljs-params">(Context context, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDaoMaster</span><span class="hljs-params">(Context context, String name, SQLiteDatabase.CursorFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, factory);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(Database db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onUpgrade(db, oldVersion, newVersion);<br>        MigrationHelper.migrate(db, <span class="hljs-keyword">new</span> MigrationHelper.ReCreateAllTableListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreateAllTables</span><span class="hljs-params">(Database db, <span class="hljs-keyword">boolean</span> ifNotExists)</span> </span>&#123;<br>                DaoMaster.createAllTables(db, ifNotExists);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDropAllTables</span><span class="hljs-params">(Database db, <span class="hljs-keyword">boolean</span> ifExists)</span> </span>&#123;<br>                DaoMaster.dropAllTables(db, ifExists);<br>            &#125;<br>        &#125;,ThingDao.class);<br>        Log.e(TAG, <span class="hljs-string">&quot;onUpgrade: &quot;</span> + oldVersion + <span class="hljs-string">&quot; newVersion = &quot;</span> + newVersion);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MigrationHelper 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs tsx">public final class MigrationHelper &#123;<br><br>    public static boolean DEBUG = false;<br>    private static String TAG = &quot;MigrationHelper&quot;;<br>    private static final String SQLITE_MASTER = &quot;sqlite_master&quot;;<br>    private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;;<br><br>    private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener;<br><br>    public interface ReCreateAllTableListener&#123;<br>        void onCreateAllTables(Database db, boolean ifNotExists);<br>        void onDropAllTables(Database db, boolean ifExists);<br>    &#125;<br><br>    public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        printLog(&quot;【The Old Database Version】&quot; + db.getVersion());<br>        Database database = new StandardDatabase(db);<br>        migrate(database, daoClasses);<br>    &#125;<br><br>    public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        weakListener = new WeakReference&lt;&gt;(listener);<br>        migrate(db, daoClasses);<br>    &#125;<br><br>    public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        weakListener = new WeakReference&lt;&gt;(listener);<br>        migrate(database, daoClasses);<br>    &#125;<br><br>    public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        printLog(&quot;【Generate temp table】start&quot;);<br>        generateTempTables(database, daoClasses);<br>        printLog(&quot;【Generate temp table】complete&quot;);<br><br>        ReCreateAllTableListener listener = null;<br>        if (weakListener != null) &#123;<br>            listener = weakListener.get();<br>        &#125;<br><br>        if (listener != null) &#123;<br>            listener.onDropAllTables(database, true);<br>            printLog(&quot;【Drop all table by listener】&quot;);<br>            listener.onCreateAllTables(database, false);<br>            printLog(&quot;【Create all table by listener】&quot;);<br>        &#125; else &#123;<br>            dropAllTables(database, true, daoClasses);<br>            createAllTables(database, false, daoClasses);<br>        &#125;<br>        printLog(&quot;【Restore data】start&quot;);<br>        restoreData(database, daoClasses);<br>        printLog(&quot;【Restore data】complete&quot;);<br>    &#125;<br><br>    private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        for (int i = 0; i &lt; daoClasses.length; i++) &#123;<br>            String tempTableName = null;<br><br>            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);<br>            String tableName = daoConfig.tablename;<br>            if (!isTableExists(db, false, tableName)) &#123;<br>                printLog(&quot;【New Table】&quot; + tableName);<br>                continue;<br>            &#125;<br>            try &#123;<br>                tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);<br>                StringBuilder dropTableStringBuilder = new StringBuilder();<br>                dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;);<br>                db.execSQL(dropTableStringBuilder.toString());<br><br>                StringBuilder insertTableStringBuilder = new StringBuilder();<br>                insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName);<br>                insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;);<br>                db.execSQL(insertTableStringBuilder.toString());<br>                printLog(&quot;【Table】&quot; + tableName +&quot;\n ---Columns--&gt;&quot;+getColumnsStr(daoConfig));<br>                printLog(&quot;【Generate temp table】&quot; + tempTableName);<br>            &#125; catch (SQLException e) &#123;<br>                Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123;<br>        if (db == null || TextUtils.isEmpty(tableName)) &#123;<br>            return false;<br>        &#125;<br>        String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER;<br>        String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;;<br>        Cursor cursor=null;<br>        int count = 0;<br>        try &#123;<br>            cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;);<br>            if (cursor == null || !cursor.moveToFirst()) &#123;<br>                return false;<br>            &#125;<br>            count = cursor.getInt(0);<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; finally &#123;<br>            if (cursor != null)<br>                cursor.close();<br>        &#125;<br>        return count &gt; 0;<br>    &#125;<br><br><br>    private static String getColumnsStr(DaoConfig daoConfig) &#123;<br>        if (daoConfig == null) &#123;<br>            return &quot;no columns&quot;;<br>        &#125;<br>        StringBuilder builder = new StringBuilder();<br>        for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123;<br>            builder.append(daoConfig.allColumns[i]);<br>            builder.append(&quot;,&quot;);<br>        &#125;<br>        if (builder.length() &gt; 0) &#123;<br>            builder.deleteCharAt(builder.length() - 1);<br>        &#125;<br>        return builder.toString();<br>    &#125;<br><br><br>    private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses);<br>        printLog(&quot;【Drop all table by reflect】&quot;);<br>    &#125;<br><br>    private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses);<br>        printLog(&quot;【Create all table by reflect】&quot;);<br>    &#125;<br><br>    /**<br>     * dao class already define the sql exec method, so just invoke it<br>     */<br>    private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        if (daoClasses.length &lt; 1) &#123;<br>            return;<br>        &#125;<br>        try &#123;<br>            for (Class cls : daoClasses) &#123;<br>                Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);<br>                method.invoke(null, db, isExists);<br>            &#125;<br>        &#125; catch (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125; catch (InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125; catch (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;<br>        for (int i = 0; i &lt; daoClasses.length; i++) &#123;<br>            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);<br>            String tableName = daoConfig.tablename;<br>            String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);<br><br>            if (!isTableExists(db, true, tempTableName)) &#123;<br>                continue;<br>            &#125;<br><br>            try &#123;<br>                // get all columns from tempTable, take careful to use the columns list<br>                List&lt;TableInfo&gt; newTableInfos = TableInfo.getTableInfo(db, tableName);<br>                List&lt;TableInfo&gt; tempTableInfos = TableInfo.getTableInfo(db, tempTableName);<br>                ArrayList&lt;String&gt; selectColumns = new ArrayList&lt;&gt;(newTableInfos.size());<br>                ArrayList&lt;String&gt; intoColumns = new ArrayList&lt;&gt;(newTableInfos.size());<br>                for (TableInfo tableInfo : tempTableInfos) &#123;<br>                    if (newTableInfos.contains(tableInfo)) &#123;<br>                        String column = &#x27;`&#x27; + tableInfo.name + &#x27;`&#x27;;<br>                        intoColumns.add(column);<br>                        selectColumns.add(column);<br>                    &#125;<br>                &#125;<br>                // NOT NULL columns list<br>                for (TableInfo tableInfo : newTableInfos) &#123;<br>                    if (tableInfo.notnull &amp;&amp; !tempTableInfos.contains(tableInfo)) &#123;<br>                        String column = &#x27;`&#x27; + tableInfo.name + &#x27;`&#x27;;<br>                        intoColumns.add(column);<br><br>                        String value;<br>                        if (tableInfo.dfltValue != null) &#123;<br>                            value = &quot;&#x27;&quot; + tableInfo.dfltValue + &quot;&#x27; AS &quot;;<br>                        &#125; else &#123;<br>                            value = &quot;&#x27;&#x27; AS &quot;;<br>                        &#125;<br>                        selectColumns.add(value + column);<br>                    &#125;<br>                &#125;<br><br>                if (intoColumns.size() != 0) &#123;<br>                    StringBuilder insertTableStringBuilder = new StringBuilder();<br>                    insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;);<br>                    insertTableStringBuilder.append(TextUtils.join(&quot;,&quot;, intoColumns));<br>                    insertTableStringBuilder.append(&quot;) SELECT &quot;);<br>                    insertTableStringBuilder.append(TextUtils.join(&quot;,&quot;, selectColumns));<br>                    insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;);<br>                    db.execSQL(insertTableStringBuilder.toString());<br>                    printLog(&quot;【Restore data】 to &quot; + tableName);<br>                &#125;<br>                StringBuilder dropTableStringBuilder = new StringBuilder();<br>                dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName);<br>                db.execSQL(dropTableStringBuilder.toString());<br>                printLog(&quot;【Drop temp table】&quot; + tempTableName);<br>            &#125; catch (SQLException e) &#123;<br>                Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    private static List&lt;String&gt; getColumns(Database db, String tableName) &#123;<br>        List&lt;String&gt; columns = null;<br>        Cursor cursor = null;<br>        try &#123;<br>            cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null);<br>            if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123;<br>                columns = Arrays.asList(cursor.getColumnNames());<br>            &#125;<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; finally &#123;<br>            if (cursor != null)<br>                cursor.close();<br>            if (null == columns)<br>                columns = new ArrayList&lt;&gt;();<br>        &#125;<br>        return columns;<br>    &#125;<br><br>    private static void printLog(String info)&#123;<br>        if(DEBUG)&#123;<br>            Log.d(TAG, info);<br>        &#125;<br>    &#125;<br><br>    private static class TableInfo &#123;<br>        int cid;<br>        String name;<br>        String type;<br>        boolean notnull;<br>        String dfltValue;<br>        boolean pk;<br><br>        @Override<br>        public boolean equals(Object o) &#123;<br>            return this == o<br>                    || o != null<br>                    &amp;&amp; getClass() == o.getClass()<br>                    &amp;&amp; name.equals(((TableInfo) o).name);<br>        &#125;<br><br>        @Override<br>        public String toString() &#123;<br>            return &quot;TableInfo&#123;&quot; +<br>                    &quot;cid=&quot; + cid +<br>                    &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +<br>                    &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +<br>                    &quot;, notnull=&quot; + notnull +<br>                    &quot;, dfltValue=&#x27;&quot; + dfltValue + &#x27;\&#x27;&#x27; +<br>                    &quot;, pk=&quot; + pk +<br>                    &#x27;&#125;&#x27;;<br>        &#125;<br><br>        private static List&lt;TableInfo&gt; getTableInfo(Database db, String tableName) &#123;<br>            String sql = &quot;PRAGMA table_info(&quot; + tableName + &quot;)&quot;;<br>            printLog(sql);<br>            Cursor cursor = db.rawQuery(sql, null);<br>            if (cursor == null)<br>                return new ArrayList&lt;&gt;();<br>            TableInfo tableInfo;<br>            List&lt;TableInfo&gt; tableInfos = new ArrayList&lt;&gt;();<br>            while (cursor.moveToNext()) &#123;<br>                tableInfo = new TableInfo();<br>                tableInfo.cid = cursor.getInt(0);<br>                tableInfo.name = cursor.getString(1);<br>                tableInfo.type = cursor.getString(2);<br>                tableInfo.notnull = cursor.getInt(3) == 1;<br>                tableInfo.dfltValue = cursor.getString(4);<br>                tableInfo.pk = cursor.getInt(5) == 1;<br>                tableInfos.add(tableInfo);<br>                // printLog(tableName + &quot;：&quot; + tableInfo);<br>            &#125;<br>            cursor.close();<br>            return tableInfos;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="8-GreenDao数据库加密"><a href="#8-GreenDao数据库加密" class="headerlink" title="8. GreenDao数据库加密"></a>8. GreenDao数据库加密</h1><p>开发中对于存储于数据库中的敏感数据，我们可以通过对数据库加密来进行保护。GreenDao可以通过SQLCipher来进行加密处理。下面我们简单讲解下加密过程：</p>
<p>步骤：</p>
<ol>
<li>导入加密库文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">implementation <span class="hljs-string">&#x27;net.zetetic:android-database-sqlcipher:3.5.6&#x27;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>修改DaoSession的生成方式：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//       MyDaoMaster helper = new MyDaoMaster(this, &quot;aserbaos.db&quot;);  //数据库升级写法</span><br>        DaoMaster.DevOpenHelper helper = <span class="hljs-keyword">new</span> DaoMaster.<span class="hljs-built_in">DevOpenHelper</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;aserbao.db&quot;</span>);<br>        <span class="hljs-comment">//SQLiteDatabase db = helper.getWritableDatabase(); //不加密的写法</span><br>        Database db = helper.<span class="hljs-built_in">getEncryptedWritableDb</span>(<span class="hljs-string">&quot;aserbao&quot;</span>); <span class="hljs-comment">//数据库加密密码为“aserbao&quot;的写法</span><br>        DaoMaster daoMaster = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DaoMaster</span>(db);<br>        daoSession = daoMaster.<span class="hljs-built_in">newSession</span>();<br></code></pre></td></tr></table></figure>

<h1 id="9-项目地址"><a href="#9-项目地址" class="headerlink" title="9. 项目地址"></a>9. 项目地址</h1><p>当前文章所有代码在AserbaosAndroid/app/src/main/java/com/aserbao/aserbaosandroid/functions/database/greenDao/relation目录下；（不过就我这脾气，可能在今后整理代码的过程中会修改！不过请放心，修改后会在github上进行说明的）</p>
<p><a href="https://links.jianshu.com/go?to=https://github.com/aserbao/AserbaosAndroid">AserbaosAndroid</a><br> aserbao的个人Android总结项目，希望这个项目能成为最全面的Android开发学习项目，这是个美好的愿景，项目中还有很多未涉及到的地方，有很多没有讲到的点，希望看到这个项目的朋友，如果你在开发中遇到什么问题，在这个项目中没有找到对应的解决办法，希望你能够提出来，给我留言或者在项目github地址提issues,我有时间就会更新项目没有涉及到的部分！项目会一直维护下去。当然，我希望是Aserbao’sAndroid 能为所有Android开发者提供到帮助！也期望更多Android开发者能参与进来，只要你熟悉Android某一块，都可以将你的代码pull上分支！</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a>10 总结</h1><p>这篇文章写到这里，零零碎碎花了差不多两周时间，从十月八号开始到今天正式准备发布，也算是对GreenDao数据库的进一步认识！如文章开头所说，我Android开发之初，使用的是自己编写SQLite来实现数据库存储，到后来使用第三方存储LitePal，最近，项目早期就使用了GreenDao，所以就又学习了一番GreenDao。对于开发者来说，我觉得无论是这三种中的哪一种，其实只要掌握一种我觉得就足够了！当然如果你有时间，可以多学习几种，多学无害嘛！最后，一如既往的说一下：如果你是Android开发者，你在开发路上遇到任何问题，欢迎来我的公众号给我留言，咱们一起讨论，加入Android开发讨论小组，一起进步！文章转载请注明出处。</p>
<h1 id="11-参考博客"><a href="#11-参考博客" class="headerlink" title="11. 参考博客"></a>11. 参考博客</h1><p><a href="https://links.jianshu.com/go?to=http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0703/8144.html">Android ORM 框架：GreenDao 使用详解</a><br> <a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/whoislcj/p/5651396.html">Android数据存储之GreenDao 3.0 详解</a><br> <a href="https://links.jianshu.com/go?to=https://xujiaojie.github.io/2017/11/22/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E4%B9%8BGreenDao%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">拆轮子系列之GreenDao框架原理分析</a></p>
<h1 id="12-修改记录"><a href="#12-修改记录" class="headerlink" title="12.修改记录"></a>12.修改记录</h1><ol>
<li>CreditCard中不能只使用一个useId来做关联，因为我这里Teacher和Student都和CreditCard是一对多关系，所以我们需要建两个对应关系字段。为了分辨添加了studentId和teacherId。</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Entity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreditCard</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    Long id;<br>    Long studentId;<br>    Long teacherId;<br>    <span class="hljs-built_in">String</span> userName;<span class="hljs-comment">//持有者名字</span><br>    <span class="hljs-built_in">String</span> cardNum;<span class="hljs-comment">//卡号</span><br>    <span class="hljs-built_in">String</span> whichBank;<span class="hljs-comment">//哪个银行的</span><br>    <span class="hljs-built_in">int</span> cardType;<span class="hljs-comment">//卡等级，分类 0 ~ 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>Student中的@ToMany（referencedJoinProperty =“id”）这个id对应的是CreditCard中的studentId，不是自增Id。（问题由@<a href="https://www.jianshu.com/u/c4d6deba2fb4">山豆几_</a>提出，感谢）<br> 修改后的代码应该是：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@ToMany</span>(referencedJoinProperty = <span class="hljs-string">&quot;studentId&quot;</span>)<br>  List&lt;CreditCard&gt; creditCardsList;<br></code></pre></td></tr></table></figure>



<p>参考：<a href="https://www.jianshu.com/p/53083f782ea2">https://www.jianshu.com/p/53083f782ea2</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
