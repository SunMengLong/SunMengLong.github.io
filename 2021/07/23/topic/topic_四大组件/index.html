

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>四大组件 - Android高级工程师</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1.App的启动流程当点击桌面图标时，Launcher...">
  <meta name="author" content="John Doe">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: false,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: false,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
      
      
    </div>
    <div class="center">四大组件</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">四大组件</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 23, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>20314</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <p>1.App的启动流程<br>当点击桌面图标时，Launcher会获取到点击View的Tag，判断Tag是否包含ShortCutInfo，包含的话从ShortCutInfo中拿到intent，然后调用startActivitySafely()，这个方法其实是对startActivity()的封装，然后调用startActivity()启动App的MainActivity，这就是App的启动流程。</p>
<p>2.View的绘制原理<br>Window、DocorView、ViewRootImpl之间的联系：</p>
<ol>
<li><p>一个Activity包含一个Window，Window是一个抽象基类，是Activity和整个View系统交互的接口。</p>
</li>
<li><p>PhoneWindow是Window的唯一实现类，提供了一系列窗口的方法，比如设置背景，标题等。</p>
</li>
<li><p>一个PhoneWindow对应一个DocorView和一个ViewRootImpl。</p>
</li>
<li><p>DocorView是整个ViewTree中的顶层布局，继承自FrameLayout，包含两个子View，状态栏View和LinearLayout</p>
</li>
<li><p>LinearLayout包含一个title和一个content，title就是平时用的TitleBar或者ActionBar。content也是framelayout，activity通过setContent将布局加载到这个view上。</p>
</li>
<li><p>ViewRootImpl就是建立在Window和DocorView之间的关系。</p>
</li>
</ol>
<p>measure、layout、draw方法的作用：</p>
<p>measure：根据父View传递的MeasureSpec进行计算大小</p>
<p>layout：根据measure子View的大小，将view放置到合适的位置上面</p>
<p>draw：将view对象绘制到屏幕上</p>
<p>measure、layout、draw方法的入口：</p>
<p>这三个核心阶段的入口是在ViewRootImpl的perFormTraversals() 方法中。</p>
<p>performTraversals会依次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程。其中performMeasure中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有子元素进行measure过程，这样就完成了一次measure过程；子元素会重复父容器的measure过程，如此反复完成了整个View数的遍历。</p>
<p>measure过程决定了View的宽/高，完成后可通过getMeasuredWidth/getMeasureHeight方法来获取View测量后的宽/高。</p>
<p>Layout过程决定了View的四个顶点的坐标和实际View的宽高，完成后可通过getTop、getBotton、getLeft和getRight拿到View的四个定点坐标。 </p>
<p>Draw过程决定了View的显示，完成后View的内容才能呈现到屏幕上。</p>
<p>measure方法：</p>
<p>首先要了解一下MeasureSpec，是一个32位二进制的整数型，前面两位代表的是mode，后面30为代表的是size。View的MeasureSpec并不是父View独自决定，它是根据父View的MeasureSpec和子View的LayoutParems通过相应的规则转化决定的。</p>
<p>mode主要分为三类：</p>
<p>EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。<br>AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content<br>UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况）</p>
<p>onMeasure(）<br>由于measure是final类型的，所以子类不能覆盖，但是onMeasure方法可以被重写，所以我们可以在onMeasure方法中重写测量设置View尺寸。onMeasure也是测量View的核心代码。<br>在这个方法中测量流程是会判断如果父类传递过来的模式是否是MeasureSpec.UNSPECIFIED，如果是就会获取到最小建议值，如果不是有返回值AT_MOST或者EXACTLY模式，则设置父类传递过来的大小。 然后调用setMeasuredDimension 方法进行存储大小。</p>
<p>layout方法：</p>
<ol>
<li><p>判断当前是否正在执行动画，如果在执行动画，则等待动画执行完调用requestLayout，如果没有添加动画或者动画已经执行完了，则调用layout，也就是View的layout。</p>
</li>
<li><p>在View的layout中设置view在父View中的位置，判断位置是都发生变化，是否需要重新进行排版布局，需要的话重新调用onLayout。</p>
</li>
<li><p>onLayout中，ViewGruop会遍历它里面的所有View然后调用每个view 的layout(l,t,r,b)方法进行位置设置。</p>
</li>
</ol>
<p>draw方法：</p>
<p>第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。<br>第三步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。<br>第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。<br>第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。<br>第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮</p>
<p>3.Activity的启动流程?<br>通常我们在一个Activity中启动另一个Activity，一般都是调用startActivity方法，这个最终会调用到Activity的startActivityForResult方法，那有没有想过Activity的启动到底经历了什么 ？现在我们一起来分析一下吧：</p>
<p>首先要了解一个类：<br>Instrumentation：<br>负责发起Activity的启动，并具体负责Activity的创建，以及Activity生命周期的回调，一个应用进程只会有一个Instrumentation对象，App内所有的Activity都持有该对象的引用。</p>
<p>启动流程：</p>
<ol>
<li><p>在startActivityForResult()方法中调用了Instrumentation中的execStartActivity()方法。</p>
</li>
<li><p>在execStartActivity()方法中，通过ActivityManagerNative.getDefaut()获取到ActivityManagerService的一个本地代理对象ActivityManagerProXY，然后调用了其startActivity()方法</p>
</li>
<li><p>ActivityManagerProXY的startActivity()最终会调用到AMS的startActivity()，并将ApplicationThread对象传入到AMS所在进程，当然AMS拿到的实际上是ApplicationThread代理对象ApplicationThreadProxy，AMS就要通过这个代理对象与我们的App进程进行通信。<br>无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； </p>
</li>
<li><p>ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息；</p>
</li>
<li><p>ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread指的是调用AMS的startActivity的进程，对于点击图标启动的Activity，这个进程就是Luncher了，对于在Activity内部通过调用startActivity启动的Activity，这个进程就是这个Activity所在的进程了。</p>
</li>
<li><p>ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity；</p>
</li>
<li><p>对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动；</p>
</li>
<li><p>ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作；</p>
</li>
<li><p>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</p>
</li>
</ol>
<p>4.Activity的启动流程<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9ecea420eb52">https://www.jianshu.com/p/9ecea420eb52</a></p>
<p>5.Android消息机制介绍？<br>Android消息机制中的四大概念：</p>
<p>ThreadLocal：当前线程存储的数据仅能从当前线程取出。<br>MessageQueue：具有时间优先级的消息队列。<br>Looper：轮询消息队列，看是否有新的消息到来。<br>Handler：具体处理逻辑的地方。<br>过程：</p>
<p>准备工作：创建Handler，如果是在子线程中创建，还需要调用Looper#prepare()，在Handler的构造函数中，会绑定其中的Looper和MessageQueue。<br>发送消息：创建消息，使用Handler发送。<br>进入MessageQueue：因为Handler中绑定着消息队列，所以Message很自然的被放进消息队列。<br>Looper轮询消息队列：Looper是一个死循环，一直观察有没有新的消息到来，之后从Message取出绑定的Handler，最后调用Handler中的处理逻辑，这一切都发生在Looper循环的线程，这也是Handler能够在指定线程处理任务的原因。</p>
<p>6.Activity中onStart和onResume的区别？onPause和onStop的区别？<br>首先，Activity有三类：</p>
<p>前台Activity：活跃的Activity，正在和用户交互的Activity。<br>可见但非前台的Activity：常见于栈顶的Activity背景透明，处在其下面的Activity就是可见但是不可和用户交互。<br>后台Activity：已经被暂停的Activity，比如已经执行了onStop方法。<br>所以，onStart和onStop通常指的是当前活动是否位于前台这个角度，而onResume和onPause从是否可见这个角度来讲的。</p>
<p>7.说下 Activity 跟 跟 window ， view 之间的关系？<br>Activity 创建时通过 attach()初始化了一个 Window 也就是PhoneWindow，一个 PhoneWindow 持有一个DecorView 的实例，DecorView 本身是一个 FrameLayout，继承于 View，Activty 通过setContentView 将xml 布局控件不断 addView()添加到 View 中，最终显示到 Window 于我们交互；</p>
<p>8.FragmentPagerAdapter 与 与 FragmentStatePagerAdapter 的区别与使用场景？<br>FragmentPagerAdapter 的每个 Fragment 会持久的保存在 FragmentManager 中，只要用户可以返回到页面中，它都不会被销毁。因此适用于那些数据 相对静态的页，Fragment 数量也比较少的那种;FragmentStatePagerAdapter 只保留当前页面，当页面不可见时，该 Fragment 就会被消除，释放其资源。因此适用于那些 数据动态性较大、 占用内存较多，多 Fragment 的情况；</p>
<p>9.Fragment中add与replace的区别？<br>add不会重新初始化fragment,replace每次都会；<br>添加相同的fragment时，replace不会有任何变化，add会报IllegalStateException 异常；<br>replace 先 remove 掉相同 id 的所有 fragment，然后在add 当前的这个 fragment，而 add 是覆盖前一个fragment。所以如果使用 add 一般会伴随 hide()和show()，避免布局重叠；<br>使用 add，如果应用放在后台，或以其他方式被系统销毁，再打开时，hide()中引用的 fragment 会销毁，所以依然会出现布局重叠 bug，可以使用 replace 或使用 add时，添加一个 tag 参数；</p>
<p>10.activity，fragment传值问题<br>通过Bundle传值，在activty定义变量传值，扩展fragment创建传值</p>
<p>11.推送到达率如何提高<br>判手机系统，小米使用小米推送，华为使用华为推送，其他手机使用友盟推送</p>
<p>12.启动优化<br>什么是逻辑异步？就是用多线程去替代之前单个主线程的工作，尽量保证让onCreate流畅不被堵塞。那么我们该怎么设计呢？设计的思路我们可以参考Gradle，将逻辑Task化。</p>
<p>1.将原本冗余的逻辑代码区分开来，抽象成一个Task</p>
<p>2.确定Task是否必须执行在主线程，是否必须在onCreate中执行完，执行上下是否存在依赖关系</p>
<p>3.设计一个Task分发管理类，负责将所有Task集合后生成一个有向无环图，这点也是参考Gradle的</p>
<p>1.逻辑异步</p>
<p>2.逻辑延迟</p>
<p>3.逻辑懒加载</p>
<p>13.什么是aar?aar是jar有什么区别?</p>
<p>jar打包不能包含资源文件<br>“aar”包是 Android 的类库项目的二进制发行包。文件扩展名是.aar</p>
<p>14.如何打开res aw目录中的数据库文件?</p>
<p>在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。<br>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。<br>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p>
<p>15.为什么Android引入广播机制?</p>
<p>ａ:从MVC的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。</p>
<p>android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构<br>它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。</p>
<p>b：程序间互通消息(例如在自己的应用程序内监听系统来电)<br>c：效率上(参考UDP的广播协议在局域网的方便性)<br>d：设计模式上(反转控制的一种应用，类似监听者模式)</p>
<p>16.onStart()与onResume()有什么区别？</p>
<p>onStart()是activity界面被显示出来的时候执行的，但不能与它交互；<br>onResume()是当该activity与用户能进行交互时被执行，用户可以获得activity的焦点，能够与用户交互。</p>
<p>17.AIDL解决了什么问题？</p>
<p>AIDL出现的目的就是为了解决一对多并发及时进程通信了</p>
<p>18.什么是AIDL？</p>
<p>AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。</p>
<p>19.Binder机制</p>
<p>直观来说，Binder是Android中的一个类，它实现了IBinder接口，从IPC的角度来说，Binder是Android中的一种跨进程通信的一种方式，同时还可以理解为是一种虚拟的物理设备，它的设备驱动是／dev/binder/。从Framework角度来说，Binder是ServiceManager的桥梁。从应用层来说，Binder是客户端和服务端进行通信的媒介。<br>我们先来了解一下这个类中每个方法的含义：<br>DESCRIPTOR：Binder的唯一标识，一般用于当前Binder的类名表示。<br>asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转化过程是区分进程的，如果客户端和服务端位于同一个进程，那么这个方法返回的是服务端的stub对象本身，否则返回的是系统封装后的Stub.proxy对象。<br>asBinder()：用于返回当前Binder对象。<br>onTransact：该方法运行在服务端的Binder线程池中，当客户端发起跨进程通信请求的时候，远程请求通过系统底层封装后交给该方法处理。注意这个方法public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)，服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就像reply中写入返回值。这个方法的执行过程就是这样的。如果这个方法返回false，客户端是会请求失败的，所以我们可以在这个方法中做一些安全验证。</p>
<p>Binder的工作机制但是要注意一些问题：1、当客户端发起请求时，由于当前线程会被挂起，直到服务端返回数据，如果这个远程方法很耗时的话，那么是不能够在UI线程，也就是主线程中发起这个远程请求的。<br>2、由于Service的Binder方法运行在线程池中，所以Binder方法不管是耗时还是不耗时都应该采用同步的方式，因为它已经运行在一个线程中了。</p>
<p>20.启动页白屏及黑屏解决？</p>
<p>把启动图bg_splash设置为窗体背景，避免刚刚启动App的时候出现，黑/白屏<br>@drawable/bg_splash</p>
<p>21.Android中开启摄像头的主要步骤<br>获得摄像头管理器CameraManager mCameraManager，mCameraManager.openCamera()来打开摄像头<br>指定要打开的摄像头，并创建openCamera()所需要的CameraDevice.StateCallback stateCallback<br>在CameraDevice.StateCallback stateCallback中调用takePreview()，这个方法中，使用CaptureRequest.Builder创建预览需要的CameraRequest，并初始化了CameraCaptureSession，最后调用了setRepeatingRequest(previewRequest, null, childHandler)进行了预览<br>点击屏幕，调用takePicture()，这个方法内，最终调用了capture(mCaptureRequest, null, childHandler)<br>在new ImageReader.OnImageAvailableListener(){}回调方法中，将拍照拿到的图片进行展示</p>
<p>22.下拉状态栏是不是影响activity的生命周期<br>不会影响</p>
<p>23.Android系统为什么会设计ContentProvider？<br>ContentProvider应用程序间非常通用的共享数据的一种方式，也是Android官方推荐的方式。Android中许多系统应用都使用该方式实现数据共享，比如通讯录、短信等。</p>
<p>设计用意在于：</p>
<p>封装。对数据进行封装，提供统一的接口，使用者完全不必关心这些数据是在DB，XML、Preferences或者网络请求来的。当项目需求要改变数据来源时，使用我们的地方完全不需要修改。<br>提供一种跨进程数据共享的方式。<br>就是数据更新通知机制了。因为数据是在多个应用程序中共享的，当其中一个应用程序改变了这些共享数据的时候，它有责任通知其它应用程序，让它们知道共享数据被修改了，这样它们就可以作相应的处理。</p>
<p>24.怎么去除重复代码？<br>1、为你的项目定义一个基Activity或Fragment<br>2、抽取相同部分<br>3、用include减少局部布局的重复<br>4、用ViewStub减少整体的布局的重复<br>5、多用引用而不是写死，对于资源文件的引用，比如文字text、文字大小textSize、文字颜色textColor等统一处理</p>
<p>25.有没有尝试简化Parcelable的使用？<br>as的插件<br>在Android studio上下载android parcelable code generator插件<br>点击右键弹出提示框，选择Parcelable生成即可：<br>序列化时选择需要的属性：<br>最后是自动生成的代码，也表示成功的实现了Parcelable接口</p>
<p>26.Android为什么引入Parcelable？<br>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p>Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递（除基本类外的类数据）</p>
<p>Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的</p>
<p>27.广播引起anr的时间限制是多少？<br>在Android中Activity中阻塞5秒、Service 20秒、BroadCastReceiver 10秒，就会造成ANR。</p>
<p>28.广播是否可以请求网络？<br>子线程可以，主线程超过10s引起anr</p>
<p>29.如何通过广播拦截和abort一条短信？<br>首先添加接收短信的权限</p>
<p>在清单文件中注册广播接收器，设置该广播接收器优先级,尽量设高一点<br>创建一个BroadcastReceiver来实现广播的处理，并设置拦截器abortBroadcast();</p>
<p>30.AndroidManifest的作用与理解<br>AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders， Services， 和Intent Receivers，还能指定permissions和instrumentation（安全控制和测试）。</p>
<p>31.进程和 Application 的生命周期<br>onCreate():Application创建的时候调用<br>onConfigurationChanged(Configuration newConfig):当配置信息改变的时候会调用，如屏幕旋转、语言切换时。<br>onLowMemory():Android系统整体内存较低时候调用，通常在这里释放一些不重要的资源，或者提醒用户清一下垃圾，来保证内存足够而让APP进程不被系统杀掉。它和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同。<br>onTrimMemory(int level)：Android 4.0 之后提供的一个API，用于取代onLowMemory()。在系统内存不足的时会被调用，提示开发者清理部分资源来释放内存，从而避免被 Android 系统杀死。详见《Android代码内存优化建议-OnTrimMemory优化》<br>onTerminate():Application结束的时候会调用,由系统决定调用的时机</p>
<p>32.说说Activity、Intent、Service 是什么关系<br>一个 Activity 通常是一个单独的屏幕，每一个 Activity 都被实现为一个单独的类，这些类都 是从 Activity 基类中继承来的， Activity 类会显示由视图控件组成的用户接口，并对视图控 件的事件做出响应。</p>
<p>Intent 的调用是用来进行架构屏幕之间的切换的。 Intent 是描述应用想要做什么。 Intent 数 据结构中两个最重要的部分是动作和动作 对应的数据， 一个动作对应一个动作数据。</p>
<p>Android Service 是运行在后台的代码，不能与用户交互，可以运行在自己的进程，也可以 运行在其他应用程序进程的上下文里。需要通过某一个 Activity 或者其他 Context 对象来调 用。 Activity 跳转到 Activity，Activity 启动 Service，Service 打开 Activity ，Activity 跳转到 Activity，Activity 启动 Service，Service 打开 Activity</p>
<p>33.IntentService原理及作用是什么？<br>IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。<br>所有请求都在一个单线程中，不会阻塞应用程序的主线程（UI Thread），同一时间只处理一个请求。</p>
<p>34.AndroidService与Activity之间通信的几种方式<br>通过 broadcast:通过广播发送消息到 activitry<br>通过 Binder：通过与 activity 进行绑定</p>
<p>35.请介绍下ContentProvider 是如何实现数据共享的？<br>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。<br>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。<br>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？<br>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p>
<p>36.ActivityThread，AMS，WMS的工作原理<br>Activity与Window：<br>Activity只负责生命周期和事件处理<br>Window只控制视图<br>一个Activity包含一个Window，如果Activity没有Window，那就相当于Service。</p>
<p>AMS与WMS：<br>AMS统一调度所有应用程序的Activity<br>WMS控制所有Window的显示与隐藏以及要显示的位置。在视图层次中，Activity在WIndow之上</p>
<p>ActivityThread：是Android应用的主线程（UI线程）</p>
<p>WMS(WindowManagerService)：管理的整个系统所有窗口的UI<br>作用:<br>为所有窗口分配Surface：客户端向WMS添加一个窗口的过程，其实就是WMS为其分配一块Suiface的过程，一块块Surface在WMS的管理下有序的排布在屏幕上。Window的本质就是Surface。（简单的说Surface对应了一块屏幕缓冲区）<br>管理Surface的显示顺序、尺寸、位置<br>管理窗口动画<br>输入系统相关：WMS是派发系统按键和触摸消息的最佳人选，当接收到一个触摸事件，它需要寻找一个最合适的窗口来处理消息，而WMS是窗口的管理者，系统中所有的窗口状态和信息都在其掌握之中，完成这一工作不在话下。</p>
<p>AMS（ActivityManagerService）<br>ActivityManager是客户端用来管理系统中正在运行的所有Activity包括Task、Memory、Service等信息的工具。但是这些这些信息的维护工作却不是又ActivityManager负责的。在ActivityManager中有大量的get()方法，那么也就说明了他只是提供信息给AMS，由AMS去完成交互和调度工作。</p>
<p>作用：<br>统一调度所有应用程序的Activity的生命周期<br>启动或杀死应用程序的进程<br>启动并调度Service的生命周期<br>注册BroadcastReceiver，并接收和分发Broadcast<br>启动并发布ContentProvider<br>调度task<br>处理应用程序的Crash<br>查询系统当前运行状态</p>
<p>37.Activity-Window-View三者的差别<br>这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。<br>1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。<br>2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。<br>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等<br>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。</p>
<p>38.讲解一下Context<br>Context是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。Context下有两个子类，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。<br>getApplicationContext()和getApplication()方法得到的对象都是同一个application对象，只是对象的类型不一样。<br>Context数量 = Activity数量 + Service数量 + 1 （1为Application）</p>
<p>39.BroadcastReceiver，LocalBroadcastReceiver 区别<br>一、应用场景不同<br>1、BroadcastReceiver用于应用之间的传递消息；<br>2、而LocalBroadcastManager用于应用内部传递消息，比broadcastReceiver更加高效。<br>二、使用安全性不同<br>1、BroadcastReceiver使用的Content API，所以本质上它是跨应用的，所以在使用它时必须要考虑到不要被别的应用滥用；<br>2、LocalBroadcastManager不需要考虑安全问题，因为它只在应用内部有效。</p>
<p>40.本地广播和全局广播有什么差别？<br>BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式<br>LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。</p>
<p>41.Broadcast注册方式与区别 （此处延伸：什么情况下用动态注册）<br>Broadcast广播，注册方式主要有两种.<br>第一种是静态注册，也可成为常驻型广播，这种广播需要在Androidmanifest.xml中进行注册，这中方式注册的广播，不受页面生命周期的影响，即使退出了页面，也可以收到广播这种广播一般用于想开机自启动啊等等，由于这种注册的方式的广播是常驻型广播，所以会占用CPU的资源。<br>第二种是动态注册，而动态注册的话，是在代码中注册的，这种注册方式也叫非常驻型广播，收到生命周期的影响，退出页面后，就不会收到广播，我们通常运用在更新UI方面。这种注册方式优先级较高。最后需要解绑，否会会内存泄露<br>广播是分为有序广播和无序广播。</p>
<p>42.请描述一下广播BroadcastReceiver的理解<br>广播，是一个全局的监听器，属于Android四大组件之一。Android 广播分为两个角色：广播发送者、广播接收者。作用是监听 / 接收 应用 App 发出的广播消息，并 做出响应<br>可应用在：<br>Android不同组件间的通信（含 ：应用内 / 不同应用之间）<br>多线程通信<br>与 Android 系统在特定情况下的通信<br>如：电话呼入时、网络可用时</p>
<p>43.service和activity怎么进行数据交互？<br>1.通过 broadcast:通过广播发送消息到 activitry<br>2.通过 Binder：通过与 activity 进行绑定<br>（1）添加一个继承 Binder 的内部类，并添加相应的逻辑方法。<br>（2）重写 Service 的 onBind 方法，返回我们刚刚定义的那个内部类实例。<br>（3）Activity 中创建一个 ServiceConnection 的匿名内部类，并且 重 写 里 面 的 onServiceConnected 方 法 和onServiceDisconnected 方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用（在onServiceConnected方法中，我们可以得到一个刚才那个 service 的 binder 对象，通过对这个 binder 对象进行向下转型，得到我们那个自定义的 Binder 实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了）。</p>
<p>44.Activity 怎么和Service 绑定？怎么在Activity 中启动自己对应的Service？<br>1、activity能进行绑定得益于Serviece的接口。为了支持Service的绑定，实现onBind方法。<br>2、Service和Activity的连接可以用ServiceConnection来实现。需要实现一个新的ServiceConnection，重现onServiceConnected和OnServiceDisconnected方法，一旦连接建立，就能得到Service实例的引用。<br>3、执行绑定，调用bindService方法，传入一个选择了要绑定的Service的Intent(显示或隐式)和一个你实现了的ServiceConnection的实例</p>
<p>45.fragment之间传递数据的方式？<br>1、在fragment中设置一个方法，然后进行调用<br>2、采取接口回调的方式进行数据传递。<br>3、广播或者是使用三方开源框架：EventBus</p>
<p>46.如何实现Fragment的滑动？<br>将Fragment与viewpager绑定，通过viewpager中的touch事件，会进行move事件的滑动处理。</p>
<p>47.Activity状态保存与恢复<br>当 Activity 在异常情况( 系统内存不足或者系统配置发生了改变等 )被销毁重建后， 在销毁的时候 Activity 会调用 onSaveInstanceState() 方法用于保存 Activity 相关的状态和数据，然后在重建后的 Activity 的中我们可以通过 onCreate() 或者 onRestoreInstanceState() 方法恢复数据，这里我们需要注意的是如果通过 onCreate() 方法恢复，那么得先判断它的 intent 参数 是否为空，如果在 onRestoreInstanceState() 方法恢复就不会，因为只要 onRestoreInstanceState() 方法被调用就说明一定有数据，不会为空。Google 推荐使用 onRestoreInstanceState() 方法。</p>
<p>48.Activity的四种启动模式对比<br>standard 模式：默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。<br>singleTop 模式：如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。<br>singleTask 模式：如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。<br>singleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p>
<p>49.两个Activity 之间跳转时必然会执行的是哪几个方法？</p>
<p>a. 正常情况下 Activity A 跳转到 Activity B 时:</p>
<p>A 调用 onPause() 方法，然后调用新的 Activity B 中的 onCreate() 方法 -&gt; onStart() 方法 -&gt; onResume() 方法。最后 A 再调用onStop()方法。</p>
<p>b. 当 Activity B 为透明主题时:</p>
<p>除了最后 Activity A 不调用 onStop() 方法之外，其它都和 a 中的一样。</p>
<p>50.Activity上有Dialog的时候按Home键时的生命周期<br>有 Dialog 和 无 Dialog 按 Home 键效果一样：</p>
<p>正常启动: onCreate() -&gt; onStart() -&gt; onResume()<br>按 home 键: onPause() -&gt; onStop()<br>再次启动: onRestart() -&gt; onStart() -&gt; onResume()</p>
<p>51.Activity与Fragment之间生命周期比较<br>a. 在创建的过程中，是 Activity 带领 Fragment 执行生命周期的方法，所以它们生命周期执行的顺序如下:<br>Activity – onCreate() ，<br>Fragment – onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated  .</p>
<p>Activity – onStart()<br>Fragment – onStart()</p>
<p>Activity – onResume()<br>Fragment – onResume()</p>
<p>最后，在销毁时是 Fragment 带领 Activity 执行生命周期的方法:<br>Fragment – onPause()<br>Activity – onPause()</p>
<p>Fragment – onStop()<br>Activity – onStop()</p>
<p>Fragment – onDestroyView() -&gt; onDestroy() -&gt; onDetach()<br>Activity – onDestroy()</p>
<p>52.横竖屏切换的时候，Activity 各种情况下的生命周期<br>分两种情况：<br>1.不设置Activity的android:configChanges，或设置Activity的android:configChanges=”orientation”，或设置Activity的android:configChanges=”orientation|keyboardHidden”，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。<br>横竖屏切换造成 activity 的生命周期<br>onPause()-onSaveInstanceState()-onStop()-onDestroy()-onCreat()-onStart()-onRestoreInstanceState()-onResume()即会导致 activity 的销毁和重建 。</p>
<p>2.配置 android:configChanges=”orientation|keyboardHidden|screenSize”，才不会销毁 activity，且只调用 onConfigurationChanged方法。<br>onSaveInstanceState() 与onRestoreIntanceState() 资源相关的系统配置发生改变或者资源不足时(例如屏幕旋转)，当前 Activity 会销毁，并且在 onStop 之前回调 onSaveInstanceState 保存数据，在重新创建 Activity 的时候在onStart 之后回调 onRestoreInstanceState。其中 Bundle 数据会传到 onCreate（不一定有数据）和 onRestoreInstanceState（一定有数据）。<br>用户或者程序员主动去销毁一个 Activity 的时候不会回调（如代码中 finish（）或用户按下 back，不会回调），其他情况都会调用，来保存界面信息。</p>
<p>53.Activity之间的通信方式<br>Intent<br>借助类的静态变量<br>借助全局变量/Application<br>借助外部工具<br>借助SharedPreference<br>使用Android数据库SQLite<br>赤裸裸的使用File<br>Android剪切板<br>借助Service</p>
<p>54.四大组件的生命周期和简单用法<br>activity：</p>
<p>onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDetroy() ，onReStart</p>
<p>Service：<br>service 启动方式有两种，一种是通过startService()方式进行启动，另一种是通过bindService()方式进行启动。不同的启动方式他们的生命周期是不一样.</p>
<p>startService()：调用startService() –&gt; onCreate()–&gt; onStartConmon()–&gt; onDestroy()。</p>
<pre><code>        这种方式启动的话，需要注意一下几个问题

        第一：当我们通过startService被调用以后，多次在调用startService(),onCreate()方法也只会被调用一次，而onStartConmon()会被多次调用当我们调用stopService()的时候，onDestroy()就会被调用，从而销毁服务。

        第二：当我们通过startService启动时候，通过intent传值，在onStartConmon()方法中获取值的时候，一定要先判断intent是否为null。
</code></pre>
<p>bindService()方式进行绑定：bindService–&gt;onCreate()–&gt;onBind()–&gt;unBind()–&gt;onDestroy()<br>            好处：更加便利activity中操作service，比如加入service中有几个方法，a,b ，如果要在activity中调用，在需要在activity获取ServiceConnection对象，通过ServiceConnection来获取service中内部类的类对象，然后通过这个类对象就可以调用类中的方法，当然这个类需要继承Binder对象<br>contentProvider：</p>
<p>contentProvider的生命周期、理解应该跟进程一样，它作为系统应用组件、其生命周期应该跟app应用的生命周期类似，只是它属于系统应用、所以随系统启动而初始化，随系统关机而结束；但也存在其他状态下结束进程、比如说系统内存不够时，进行内存回收、会根据生成时间态、用户操作等情况进行是否内存回收。</p>
<p>BroadcastReceiver：</p>
<p>广播的生命周期从调用开始到onReceiver执行完毕结束，需要注意的是，一般广播的生命周期都极短，需要在10s内处理完onReceiver中的所有工作，所以，一般不进行耗时长的工作，如果有耗时长的工作，应当通过Intent传递给Service进行处理。（注意，不要在onReceiver中开启线程进行耗时任务处理，否则，在10s后，该线程会变成空线程，从而导致任务的丢失。同样的，也不要使用bindService来绑定服务。）<br>值得注意的是，如果是在代码中动态注册的广播，如：在Activity注册，那么在Activity的onDestory中需要使用unregisterReceiver注销广播。</p>
<p>55.四大组件是什么？<br>Activity<br>Service服务<br>Content Provider内容提供者<br>BroadcastReceiver</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>John Doe</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/07/23/topic/topic_%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;23&#x2F;topic&#x2F;topic_%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;23&#x2F;topic&#x2F;topic_%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
  <nav class="nav">
    <a href="/2021/07/23/topic/topic_java%E5%9F%BA%E7%A1%80/"><i class="iconfont iconleft"></i>java基础</a>
    <a href="/2021/07/23/topic/topic_%E8%BF%9B%E7%A8%8B:%E7%BA%BF%E7%A8%8B/">进程/线程<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
  
  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>